diff --git a/app/constants.py b/app/constants.py
index 9ad7b803..ef1e86e2 100644
--- a/app/constants.py
+++ b/app/constants.py
@@ -1,10 +1,21 @@
-TILEWIDTH, TILEHEIGHT = 16, 16
-TILEX, TILEY = 15, 10
-WINWIDTH, WINHEIGHT = TILEX * TILEWIDTH, TILEY * TILEHEIGHT
-COLORKEY = 128, 160, 128
-FPS = 60
-FRAMERATE = 1000//FPS
-
-AUTOTILE_FRAMES = 16
-
-VERSION = "2021.09.15b"
+MEMENTO_MODE = True
+if MEMENTO_MODE:
+    TILEWIDTH, TILEHEIGHT = 16, 16
+    TILEX, TILEY = 17, 13.5
+    FULLTILEX = 24
+    WINWIDTH, WINHEIGHT = int(FULLTILEX * TILEWIDTH), int(TILEY * TILEHEIGHT)
+    MAPWIDTH = int(TILEX * TILEWIDTH)
+else:
+    TILEWIDTH, TILEHEIGHT = 16, 16
+    TILEX, TILEY = 15, 10
+    FULLTILEX = TILEX
+    WINWIDTH, WINHEIGHT = int(TILEX * TILEWIDTH), int(TILEY * TILEHEIGHT)
+    MAPWIDTH = WINWIDTH
+STATWIDTH = WINWIDTH - MAPWIDTH
+COLORKEY = 128, 160, 128
+FPS = 60
+FRAMERATE = 1000//FPS
+
+AUTOTILE_FRAMES = 16
+
+VERSION = "2021.07.27a"
diff --git a/app/data/constants.py b/app/data/constants.py
index 40656e26..7b4d5a8a 100644
--- a/app/data/constants.py
+++ b/app/data/constants.py
@@ -65,6 +65,8 @@ constants = ConstantCatalog([
     Constant('boss_crit', "Final blow on boss will use critical animation", bool),
     Constant('convoy_on_death', "Items held by dead player units are sent to convoy", bool),
     Constant('give_and_take', "Units can give a unit after taking a unit", bool),
+    Constant('reset_mana', "Mana resets to full for units upon completion of the chapter", bool),
+    Constant('double_splash', "When doubling, splash/aoe damage is applied on the second strike as well", bool),
     Constant('num_save_slots', "Number of save slots", int, 3, 'title'),
     Constant('attack_zero_hit', "Enemy AI attacks even if Hit is 0", bool, True, 'ai'),
     Constant('attack_zero_dam', "Enemy AI attacks even if Damage is 0", bool, True, 'ai'),
diff --git a/app/editor/icons.py b/app/editor/icons.py
index 2f742305..23a5f510 100644
--- a/app/editor/icons.py
+++ b/app/editor/icons.py
@@ -2,6 +2,7 @@ from PyQt5.QtWidgets import QWidget, QHBoxLayout, QPushButton
 from PyQt5.QtGui import QPixmap, QIcon
 from PyQt5.QtCore import Qt, pyqtSignal
 
+from app.constants import MEMENTO_MODE
 from app.resources.resources import RESOURCES
 
 import app.editor.utilities as editor_utilities
@@ -100,7 +101,10 @@ class ItemIcon80(ItemIcon16):
 
 class UnitPortrait(QPushButton):
     sourceChanged = pyqtSignal(str)
-    width, height = 96, 80
+    if MEMENTO_MODE:
+        width, height = 128, 128
+    else:
+        width, height = 96, 80
     database = RESOURCES.portraits
 
     def __init__(self, parent):
diff --git a/app/editor/level_editor/unit_group_painter_menu.py b/app/editor/level_editor/unit_group_painter_menu.py
index 90f631ce..b12b26f4 100644
--- a/app/editor/level_editor/unit_group_painter_menu.py
+++ b/app/editor/level_editor/unit_group_painter_menu.py
@@ -2,7 +2,7 @@ import functools
 
 from PyQt5.QtWidgets import QPushButton, QLineEdit, \
     QWidget, QDialog, QVBoxLayout, QMessageBox, QListWidgetItem, \
-    QGridLayout
+    QGridLayout, QApplication
 from PyQt5.QtCore import QSize, Qt
 from PyQt5.QtGui import QBrush, QColor, QIcon
 
@@ -311,7 +311,7 @@ class GroupUnitModel(DragDropCollectionModel):
         elif role == Qt.ForegroundRole:
             unit_nid = self._data[index.row()]
             if unit_nid in self.positions:
-                return QBrush()
+                return QBrush(QApplication.palette().text().color())
             else:
                 return QBrush(QColor("red"))
         return None
diff --git a/app/editor/portrait_editor/portrait_model.py b/app/editor/portrait_editor/portrait_model.py
index 49cf7990..651aa9c1 100644
--- a/app/editor/portrait_editor/portrait_model.py
+++ b/app/editor/portrait_editor/portrait_model.py
@@ -11,6 +11,7 @@ from app.resources.resources import RESOURCES
 
 from app.utilities.data import Data
 from app.data.database import DB
+from app.constants import MEMENTO_MODE
 
 from app.extensions.custom_gui import DeletionDialog
 from app.editor.base_database_gui import ResourceCollectionModel
@@ -88,7 +89,10 @@ class PortraitModel(ResourceCollectionModel):
             if not portrait.pixmap:
                 portrait.pixmap = QPixmap(portrait.full_path)
             pixmap = portrait.pixmap
-            chibi = pixmap.copy(96, 16, 32, 32)
+            if MEMENTO_MODE:
+                chibi = pixmap.copy(128, 0, 32, 32)
+            else:
+                chibi = pixmap.copy(96, 16, 32, 32)
             chibi = QPixmap.fromImage(editor_utilities.convert_colorkey(chibi.toImage()))
             return QIcon(chibi)
         elif role == Qt.EditRole:
@@ -114,6 +118,9 @@ class PortraitModel(ResourceCollectionModel):
                         auto_colorkey(new_portrait)
                         auto_frame_portrait(new_portrait)
                         RESOURCES.portraits.append(new_portrait)
+                    elif MEMENTO_MODE:
+                        new_portrait = Portrait(nid, fn, pix)
+                        RESOURCES.portraits.append(new_portrait)
                     else:
                         QMessageBox.critical(self.window, "Error", "Image is not correct size (128x112 px)")
                 else:
diff --git a/app/editor/portrait_editor/portrait_properties.py b/app/editor/portrait_editor/portrait_properties.py
index 30344914..f71ac9e9 100644
--- a/app/editor/portrait_editor/portrait_properties.py
+++ b/app/editor/portrait_editor/portrait_properties.py
@@ -7,6 +7,7 @@ from PyQt5.QtWidgets import QMessageBox, QWidget, QHBoxLayout, \
 from PyQt5.QtCore import Qt, QSize
 from PyQt5.QtGui import QPixmap, QPainter, QIcon
 
+from app.constants import MEMENTO_MODE
 from app.extensions.spinbox_xy import SpinBoxXY
 from app.extensions.custom_gui import PropertyBox
 from app.editor import timer
@@ -52,7 +53,10 @@ class PortraitProperties(QWidget):
         left_section = QGridLayout()
 
         self.portrait_view = IconView(self)
-        self.portrait_view.setMinimumHeight(80 + 2)
+        if MEMENTO_MODE:
+            self.portrait_view.setMinimumHeight(128 + 2)
+        else:
+            self.portrait_view.setMinimumHeight(80 + 2)
         left_section.addWidget(self.portrait_view, 0, 0, 1, 3)
 
         self.smile_button = QPushButton(self)
@@ -173,7 +177,10 @@ class PortraitProperties(QWidget):
         self.update_talk()
         if not self.current:
             return
-        main_portrait = self.current.pixmap.copy(0, 0, 96, 80)
+        if MEMENTO_MODE:
+            main_portrait = self.current.pixmap.copy(0, 0, 128, 128)
+        else:
+            main_portrait = self.current.pixmap.copy(0, 0, 96, 80)
         main_portrait = main_portrait.toImage()
         # For smile image
         if self.smile_on:
@@ -201,13 +208,14 @@ class PortraitProperties(QWidget):
         else:
             blink_image = None
         # Draw image
-        painter = QPainter()
-        painter.begin(main_portrait)
-        if blink_image:
-            blink_image = blink_image.toImage()
-            painter.drawImage(self.current.blinking_offset[0], self.current.blinking_offset[1], blink_image)
-        painter.drawImage(self.current.smiling_offset[0], self.current.smiling_offset[1], mouth_image)
-        painter.end()
+        if not MEMENTO_MODE:
+            painter = QPainter()
+            painter.begin(main_portrait)
+            if blink_image:
+                blink_image = blink_image.toImage()
+                painter.drawImage(self.current.blinking_offset[0], self.current.blinking_offset[1], blink_image)
+            painter.drawImage(self.current.smiling_offset[0], self.current.smiling_offset[1], mouth_image)
+            painter.end()
 
         final_pix = QPixmap.fromImage(editor_utilities.convert_colorkey(main_portrait))
         self.portrait_view.set_image(final_pix)
diff --git a/app/editor/unit_editor/unit_model.py b/app/editor/unit_editor/unit_model.py
index 28927128..da63d011 100644
--- a/app/editor/unit_editor/unit_model.py
+++ b/app/editor/unit_editor/unit_model.py
@@ -1,6 +1,7 @@
 from PyQt5.QtGui import QPixmap, QIcon
 from PyQt5.QtCore import Qt
 
+from app.constants import MEMENTO_MODE
 from app.resources.resources import RESOURCES
 from app.utilities.data import Data
 from app.data.database import DB
@@ -19,7 +20,10 @@ def get_chibi(unit):
         return None
     if not res.pixmap:
         res.pixmap = QPixmap(res.full_path)
-    pixmap = res.pixmap.copy(96, 16, 32, 32)
+    if MEMENTO_MODE:
+        pixmap = res.pixmap.copy(128, 0, 32, 32)
+    else:
+        pixmap = res.pixmap.copy(96, 16, 32, 32)
     pixmap = QPixmap.fromImage(editor_utilities.convert_colorkey(pixmap.toImage()))
     return pixmap
 
diff --git a/app/engine/action.py b/app/engine/action.py
index 8b410310..7097d0fa 100644
--- a/app/engine/action.py
+++ b/app/engine/action.py
@@ -5,8 +5,9 @@ import sys
 
 from app.constants import TILEHEIGHT, TILEWIDTH
 from app.data.database import DB
+from app.resources.resources import RESOURCES
 from app.engine import (aura_funcs, banner, equations, item_funcs, item_system,
-                        particles, skill_system, static_random, unit_funcs)
+                        particles, skill_system, static_random, unit_funcs, animations)
 from app.engine.game_state import game
 from app.engine.objects.item import ItemObject
 from app.engine.objects.skill import SkillObject
@@ -1968,6 +1969,39 @@ class RemoveWeather(Action):
             new_ps = particles.create_system(self.weather_nid, game.tilemap.width, game.tilemap.height)
             game.tilemap.weather.append(new_ps)
 
+class AddMapAnim(Action):
+    def __init__(self, nid, pos, speed_mult):
+        self.nid = nid
+        self.pos = pos
+        self.speed_mult = speed_mult
+
+    def do(self):
+        anim = RESOURCES.animations.get(self.nid)
+        anim = animations.MapAnimation(anim, self.pos, loop=True, speed_mult=self.speed_mult)
+        game.tilemap.animations.append(anim)
+
+    def reverse(self):
+        for anim in game.tilemap.animations[:]:
+            if anim.nid == self.nid and anim.xy_pos == self.pos:
+                game.tilemap.animations.remove(anim)
+                break
+
+class RemoveMapAnim(Action):
+    def __init__(self, nid, pos):
+        self.nid = nid
+        self.pos = pos
+        self.speed_mult = 1
+
+    def do(self):
+        for anim in game.tilemap.animations[:]:
+            if anim.nid == self.nid and anim.xy_pos == self.pos:
+                self.speed_mult = anim.speed_adj
+                game.tilemap.animations.remove(anim)
+
+    def reverse(self):
+        anim = RESOURCES.animations.get(self.nid)
+        anim = animations.MapAnimation(anim, self.pos, loop=True, speed_mult=self.speed_mult)
+        game.tilemap.animations.append(anim)
 
 class ChangeObjective(Action):
     def __init__(self, key, string):
diff --git a/app/engine/animations.py b/app/engine/animations.py
index 74e25a54..d8b70a63 100644
--- a/app/engine/animations.py
+++ b/app/engine/animations.py
@@ -1,4 +1,4 @@
-from app.constants import TILEHEIGHT, TILEWIDTH
+from app.constants import TILEHEIGHT, TILEWIDTH, STATWIDTH
 from app.engine import engine, image_mods
 from app.utilities import str_utils, utils
 
@@ -6,11 +6,13 @@ from app.utilities import str_utils, utils
 # Used, for instance, for miss and no damage animations
 
 class Animation():
-    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1 ):
+    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1):
+        self.nid = anim.nid
         if not anim.image:
             anim.image = engine.image_load(anim.full_path)
             anim.image = anim.image.convert_alpha()
         self.sprite = anim.image
+        self.xy_pos = position
         self.position = position
         self.frame_x, self.frame_y = anim.frame_x, anim.frame_y
         self.num_frames = anim.num_frames
@@ -33,6 +35,14 @@ class Animation():
         self.frames_held = 0
         self.first_update = engine.get_time()
 
+    def save(self) -> tuple:
+        return {'nid': self.nid, 
+                'pos': self.xy_pos,
+                'loop': self.loop,
+                'hold': self.hold, 
+                'reverse': self.reverse, 
+                'speed_adj': self.speed_adj}
+
     @property
     def speed(self):
         if str_utils.is_int(self.anim_speed):
@@ -129,9 +139,9 @@ class Animation():
         return surf
 
 class MapAnimation(Animation):
-    def __init__(self, anim, position, delay=0, loop=False, hold=False, speed_adj: float = 1):
-        super().__init__(anim, position, delay, loop, hold, speed_adj=speed_adj)
-        self.position = self.position[0] * TILEWIDTH, self.position[1] * TILEHEIGHT
+    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1):
+        super().__init__(anim, position, delay, loop, hold, reverse, speed_adj=speed_adj)
+        self.position = STATWIDTH + self.position[0] * TILEWIDTH, self.position[1] * TILEHEIGHT
         self.use_center()
 
     def use_center(self):
diff --git a/app/engine/bmpfont.py b/app/engine/bmpfont.py
index 006243ee..4ac2ee93 100644
--- a/app/engine/bmpfont.py
+++ b/app/engine/bmpfont.py
@@ -50,7 +50,7 @@ class BmpFont():
         # string = string.replace('_', ' ')
         return string
 
-    def blit(self, string, surf, pos=(0, 0)):
+    def blit(self, string, surf, pos=(0, 0), reverse=False):
         def normal_render(left, top, string):
             for c in string:
                 if c not in self.memory:
@@ -72,6 +72,31 @@ class BmpFont():
                 engine.blit(surf, subsurf, (left, top))
                 left += char_width + self.space_offset
 
+        def reverse_render(left, top, string):
+            positions = []
+            for c in string:
+                if c not in self.memory:
+                    try:
+                        char_pos_x = self.chartable[c][0]
+                        char_pos_y = self.chartable[c][1]
+                        char_width = self.chartable[c][2]
+                    except KeyError as e:
+                        char_pos_x = 0
+                        char_pos_y = 0
+                        char_width = 8
+                        print(e)
+                        print("%s is not chartable" % c)
+                        print("string: ", string)
+                    subsurf = engine.subsurface(self.surface, (char_pos_x, char_pos_y, self._width, self.height))
+                    self.memory[c] = (subsurf, char_width)
+                else:
+                    subsurf, char_width = self.memory[c]
+                left += char_width + self.space_offset
+                positions.append((left, subsurf))
+            # Now reversed
+            for left, subsurf in reversed(positions):
+                engine.blit(surf, subsurf, (left, top))
+
         def stacked_render(left, top, string):
             orig_left = left
             for c in string:
@@ -107,6 +132,8 @@ class BmpFont():
 
         if self.stacked:
             stacked_render(x, y, string)
+        elif reverse:
+            reverse_render(x, y, string)
         else:
             normal_render(x, y, string)
 
diff --git a/app/engine/combat/animation_combat.py b/app/engine/combat/animation_combat.py
index df170a32..e9e3f701 100644
--- a/app/engine/combat/animation_combat.py
+++ b/app/engine/combat/animation_combat.py
@@ -764,6 +764,8 @@ class AnimationCombat(BaseCombat, MockCombat):
         a_broke, d_broke = self.find_broken_items()
         self.handle_broken_items(a_broke, d_broke)
 
+        game.stat_screen.reset_surfs()
+
     def handle_state_stack(self):
         """
         Map combat has the implementation I want of this, so let's just use it
diff --git a/app/engine/combat/simple_combat.py b/app/engine/combat/simple_combat.py
index d0d9aa40..5312df08 100644
--- a/app/engine/combat/simple_combat.py
+++ b/app/engine/combat/simple_combat.py
@@ -107,14 +107,17 @@ class SimpleCombat():
 
         all_units = self._all_units()
 
+        for unit in all_units:
+            if unit.get_hp() > 0:
+                unit.sprite.change_state('normal')
+                unit.sprite.reset()
+
         self.cleanup_combat()
 
         # Handle death
         for unit in all_units:
             if unit.get_hp() <= 0:
                 game.death.should_die(unit)
-            else:
-                unit.sprite.change_state('normal')
 
         self.turnwheel_death_messages(all_units)
 
@@ -142,6 +145,8 @@ class SimpleCombat():
         a_broke, d_broke = self.find_broken_items()
         self.handle_broken_items(a_broke, d_broke)
 
+        game.stat_screen.reset_surfs()
+
     def start_event(self, full_animation=False):
         # region is set to True or False depending on whether we are in a battle anim
         game.events.trigger('combat_start', self.attacker, self.defender, self.main_item, self.attacker.position, full_animation)
diff --git a/app/engine/combat/solver.py b/app/engine/combat/solver.py
index 5065b64e..c02390e3 100644
--- a/app/engine/combat/solver.py
+++ b/app/engine/combat/solver.py
@@ -78,7 +78,12 @@ class AttackerState(SolverState):
         skill_system.start_sub_combat(actions, playback, solver.attacker, solver.main_item, solver.defender, 'attack', attack_info)
         for idx, item in enumerate(solver.items):
             defender = solver.defenders[idx]
-            splash = solver.splashes[idx]
+            if DB.constants.value('double_splash'):
+                splash = solver.splashes[idx]
+            elif solver.num_attacks == 0 and solver.num_subattacks == 0:
+                splash = solver.splashes[idx]
+            else:
+                splash = []
             target_pos = solver.target_positions[idx]
             if defender:
                 skill_system.start_sub_combat(actions, playback, defender, defender.get_weapon(), solver.attacker, 'defense', attack_info)
diff --git a/app/engine/component_system_compiler/compile_skill_system.py b/app/engine/component_system_compiler/compile_skill_system.py
index e9638cb6..5f957fdd 100644
--- a/app/engine/component_system_compiler/compile_skill_system.py
+++ b/app/engine/component_system_compiler/compile_skill_system.py
@@ -8,7 +8,8 @@ default_behaviours = (
     'ignore_rescue_penalty', 'ignore_forced_movement', 'distant_counter',
     'ignore_fatigue')
 # Takes in unit, returns default value
-exclusive_behaviours = ('can_select', 'movement_type', 'sight_range', 'empower_splash', 'num_items_offset', 'num_accessories_offset', 'change_variant', 'change_animation')
+exclusive_behaviours = ('can_select', 'movement_type', 'sight_range', 'empower_splash', 'num_items_offset', 'num_accessories_offset', 'change_variant', 'change_animation', 'witch_warp')
+
 exclusive_behaviours += formula
 # Takes in unit and item, returns default value
 item_behaviours = ('modify_buy_price', 'modify_sell_price', 'limit_maximum_range', 'modify_maximum_range')
diff --git a/app/engine/component_system_compiler/item_system_base.py b/app/engine/component_system_compiler/item_system_base.py
index 1c796ebe..58702ce3 100644
--- a/app/engine/component_system_compiler/item_system_base.py
+++ b/app/engine/component_system_compiler/item_system_base.py
@@ -124,6 +124,19 @@ def stat_change(unit, item, stat_nid) -> int:
             bonus += d.get(stat_nid, 0)
     return bonus
 
+def stat_change_contribution(unit, item, stat_nid) -> list:
+    contribution = {}
+    for component in item.components:
+        if component.defines('stat_change'):
+            d = component.stat_change(unit)
+            val = d.get(stat_nid, 0)
+            if val != 0:
+                if item.nid in contribution:
+                    contribution[item.nid] += val
+                else:
+                    contribution[item.nid] = val
+    return contribution
+
 def is_broken(unit, item) -> bool:
     """
     If any hook reports true, then it is true
diff --git a/app/engine/component_system_compiler/skill_system_base.py b/app/engine/component_system_compiler/skill_system_base.py
index 2212154b..3763446f 100644
--- a/app/engine/component_system_compiler/skill_system_base.py
+++ b/app/engine/component_system_compiler/skill_system_base.py
@@ -33,6 +33,10 @@ class Defaults():
     def num_accessories_offset(unit) -> int:
         return 0
 
+    @staticmethod
+    def witch_warp(unit) -> list:
+        return []
+
     @staticmethod
     def exp_multiplier(unit1, unit2) -> float:
         return 1.0
@@ -158,6 +162,21 @@ def stat_change(unit, stat_nid) -> int:
                     bonus += d.get(stat_nid, 0)
     return bonus
 
+def stat_change_contribution(unit, stat_nid) -> dict:
+    contribution = {}
+    for skill in unit.skills:
+        for component in skill.components:
+            if component.defines('stat_change'):
+                if component.ignore_conditional or condition(skill, unit):
+                    d = component.stat_change(unit)
+                    val = d.get(stat_nid, 0)
+                    if val != 0:
+                        if skill.nid in contribution:
+                            contribution[skill.nid] += val
+                        else:
+                            contribution[skill.nid] = val
+    return contribution
+
 def growth_change(unit, stat_nid) -> int:
     bonus = 0
     for skill in unit.skills:
diff --git a/app/engine/fog_particles.py b/app/engine/fog_particles.py
new file mode 100644
index 00000000..059560d6
--- /dev/null
+++ b/app/engine/fog_particles.py
@@ -0,0 +1,98 @@
+import math, random
+
+from dataclasses import dataclass
+
+from app.constants import TILEWIDTH, TILEHEIGHT
+from app.engine.sprites import SPRITES
+
+from app.engine import engine, image_mods
+from app.engine.game_state import game
+from app.utilities import utils
+
+@dataclass
+class FogParticle():
+    x: float = 0
+    y: float = 0
+    x_speed: float = 0
+    y_speed: float = 0
+    size: int = 0
+    transparency: float = 0
+    time_offset: float = 0
+
+class FogParticleSystem():
+    def __init__(self, nid, abundance, bounds, size):
+        width, height = size
+        self.nid = nid
+        self.abundance = int(abundance * width * height)
+        self.particles = []
+        self.remove_me_flag = False
+
+        self.lx, self.ux, self.ly, self.uy = bounds
+
+        # Build sprites
+        _fog_sprite = SPRITES.get('particle_fog_mote')
+        _fog_sprites = [engine.subsurface(_fog_sprite, (0, 0, 3, 3)),
+                        engine.subsurface(_fog_sprite, (3 + 1, 0, 5, 5)),
+                        engine.subsurface(_fog_sprite, (8 + 2, 0, 7, 7)),
+                        engine.subsurface(_fog_sprite, (15 + 3, 0, 9, 9)),
+                        engine.subsurface(_fog_sprite, (24 + 4, 0, 11, 11))]
+        self.transparencies = []
+        for sprite in _fog_sprites:
+            self.transparencies.append([image_mods.make_translucent(sprite, k) for k in (0.9, 0.92, 0.94, 0.96, 0.98, 1.0)])
+    
+    def save(self):
+        return self.nid
+
+    def add_particle(self, x, y):
+        transparency = .8
+        time_offset = random.randrange(0, 100) * 100
+        size = random.randrange(0, 5)
+        speed = utils.clamp(random.normalvariate(1, .5), 0.1, 5)
+        angle = random.uniform(315, 359) * math.pi / 180
+        x_speed = speed * (2.5 - size/2) * math.cos(angle)
+        y_speed = speed * (2.5 - size/2) * math.sin(angle)
+        new_particle = FogParticle(x, y, x_speed, y_speed, size, transparency, time_offset)
+        return new_particle
+        
+    def update(self):
+        current_time = engine.get_time()
+
+        for particle in self.particles:
+            particle.x += particle.x_speed
+            particle.y -= particle.y_speed
+            t_offset = math.sin((current_time + particle.time_offset) / 500)
+            particle.transparency = .95 + 0.1 * t_offset
+
+        # Remove particles that have left the map
+        self.particles = [p for p in self.particles if (p.x < game.tilemap.width * TILEWIDTH and p.y < game.tilemap.height * TILEHEIGHT)]
+
+        if len(self.particles) < self.abundance:
+            xpos = random.randint(self.lx, self.ux)
+            ypos = random.randint(self.ly, self.uy)
+            new_particle = self.add_particle(xpos, ypos)
+            self.particles.append(new_particle)
+
+        if self.abundance <= 0 and not self.particles:
+            self.remove_me_flag = True
+
+    def prefill(self):
+        for _ in range(300):
+            self.update()
+
+    def draw(self, surf, offset_x=0, offset_y=0):
+        for particle in self.particles:
+            closest_transparency = utils.clamp(particle.transparency, 0.9, 1.0)
+            if 0.9 <= closest_transparency < 0.91:
+                idx = 0
+            elif 0.91 <= closest_transparency < 0.93:
+                idx = 1
+            elif 0.93 <= closest_transparency < 0.95:
+                idx = 2
+            elif 0.95 <= closest_transparency < 0.97:
+                idx = 3
+            elif 0.97 <= closest_transparency < 0.99:
+                idx = 4
+            else:
+                idx = 5
+            sprite = self.transparencies[particle.size][idx]
+            surf.blit(sprite, (particle.x - offset_x, particle.y - offset_y))
diff --git a/app/engine/fonts.py b/app/engine/fonts.py
index 9c6d5c02..cc8c7a56 100644
--- a/app/engine/fonts.py
+++ b/app/engine/fonts.py
@@ -18,6 +18,15 @@ text.colors['grey'] = ((184, 176, 176, 255), (136, 128, 120, 255), (56, 48, 40,
 text.colors['yellow'] = ((248, 240, 136, 255), (168, 168, 72, 255), (72, 64, 8, 255))
 text.colors['brown'] = ((248, 248, 248, 255), (144, 112, 88, 255), (80, 40, 0, 255))
 
+runes = FontType('runes', 'white')
+runes.colors['white'] = ((248, 248, 248, 255), (160, 136, 216, 255), (56, 48, 40, 255))
+runes.colors['blue'] = ((192, 248, 248, 255), (80, 112, 248, 255), (24, 24, 88, 255))
+runes.colors['green'] = ((72, 232, 32, 255), (112, 160, 72, 255), (24, 88, 24, 255))
+runes.colors['red'] = ((224, 96, 80, 255), (160, 88, 72, 255), (88, 24, 24, 255))
+runes.colors['grey'] = ((184, 176, 176, 255), (136, 128, 120, 255), (56, 48, 40, 255))
+runes.colors['yellow'] = ((248, 240, 136, 255), (168, 168, 72, 255), (72, 64, 8, 255))
+runes.colors['brown'] = ((248, 248, 248, 255), (144, 112, 88, 255), (80, 40, 0, 255))
+
 narrow = FontType('narrow', 'white')
 narrow.colors['white'] = ((248, 248, 248, 255), (160, 136, 216, 255), (56, 48, 40, 255))
 narrow.colors['blue'] = ((192, 248, 248, 255), (80, 112, 248, 255), (24, 24, 88, 255))
@@ -57,7 +66,7 @@ chapter.colors['green'] = ((232, 232, 232, 255), (144, 224, 160, 255), (128, 208
                            (104, 184, 120, 255), (112, 160, 104, 255), (56, 112, 64, 255),
                            (16, 8, 8, 255))
 
-font_types = [text, narrow, small, info, convo, chapter]
+font_types = [text, narrow, small, info, convo, chapter, runes]
 
 # Load in default, uncolored fonts
 FONT = {}
diff --git a/app/engine/game_state.py b/app/engine/game_state.py
index 00bc7e72..94d97b45 100644
--- a/app/engine/game_state.py
+++ b/app/engine/game_state.py
@@ -8,7 +8,7 @@ from typing import TYPE_CHECKING, Dict, List, Tuple
 if TYPE_CHECKING:
     from app.engine import (ai_controller, death,
         game_board, highlight, map_view, movement, phase,
-        promotion, ui_view, banner, boundary, camera, cursor,
+        promotion, ui_view, stat_screen, banner, boundary, camera, cursor,
         initiative, records, save, supports, turnwheel, unit_sprite)
     from app.engine.combat.simple_combat import SimpleCombat
     from app.engine.overworld.overworld_movement_manager import \
@@ -91,6 +91,7 @@ class GameState():
         self.movement: movement.MovementManager | OverworldMovementManager = None
         self.death: death.DeathManager = None
         self.ui_view: ui_view.UIView = None
+        self.stat_screen: stat_screen.StatScreen = None
         self.combat_instance: List[SimpleCombat] = []
         self.exp_instance: List[Tuple[UnitObject, int, promotion.PromotionState, str]] = []
         self.mana_instance = []
@@ -189,7 +190,7 @@ class GameState():
         Done on loading a level, whether from overworld, last level, save_state, etc.
         """
         from app.engine import (ai_controller, camera, death, highlight,
-                                map_view, movement, phase, ui_view)
+                                map_view, movement, phase, ui_view, stat_screen)
 
         # Systems
         self.camera = camera.Camera(self)
@@ -199,6 +200,7 @@ class GameState():
         self.movement = movement.MovementManager()
         self.death = death.DeathManager()
         self.ui_view = ui_view.UIView()
+        self.stat_screen = stat_screen.StatScreen()
         self.combat_instance = []
         self.exp_instance = []
         self.mana_instance = []
@@ -434,7 +436,8 @@ class GameState():
                 unit.traveler = None
                 action.execute(action.RemoveSkill(unit, 'Rescue'))
             unit.set_hp(1000)  # Set to full health
-            unit.set_mana(1000)  # Set to full mana
+            if DB.constants.value('reset_mana'):
+                unit.set_mana(1000)  # Set to full mana
             unit.position = None
             unit.sprite.change_state('normal')
             unit.reset()
diff --git a/app/engine/general_states.py b/app/engine/general_states.py
index d8424e36..3919e6fb 100644
--- a/app/engine/general_states.py
+++ b/app/engine/general_states.py
@@ -12,7 +12,7 @@ from app.engine.game_state import game
 from app.engine import engine, action, menus, image_mods, \
     banner, save, phase, skill_system, target_system, item_system, \
     item_funcs, ui_view, info_menu, base_surf, gui, background, dialog, \
-    text_funcs, equations, evaluate, supports
+    text_funcs, equations, evaluate, supports, stat_screen
 from app.engine.combat import interaction
 from app.engine.selection_helper import SelectionHelper
 from app.engine.abilities import ABILITIES, PRIMARY_ABILITIES, OTHER_ABILITIES
@@ -175,7 +175,7 @@ class FreeState(MapState):
         game.cursor.take_input()
 
         if event == 'INFO':
-            info_menu.handle_info()
+            stat_screen.handle_info()
 
         elif event == 'AUX':
             info_menu.handle_aux()
@@ -316,7 +316,6 @@ class OptionMenuState(MapState):
                     game.state.change('turn_change')
                     game.state.change('status_endstep')
                     game.state.change('ai')
-                    game.ui_view.remove_unit_display()
                     return 'repeat'
             elif selection == 'Suspend' or selection == 'Save':
                 if cf.SETTINGS['confirm_end']:
@@ -400,7 +399,6 @@ class OptionChildState(State):
                     game.state.change('turn_change')
                     game.state.change('status_endstep')
                     game.state.change('ai')
-                    game.ui_view.remove_unit_display()
                     return 'repeat'
                 elif self.menu.owner == 'Suspend':
                     game.state.back()
@@ -495,10 +493,14 @@ class MoveState(MapState):
                 if game.board.in_vision(game.cursor.position) and game.board.get_unit(game.cursor.position):
                     SOUNDTHREAD.play_sfx('Error')
                 else:
+                    witch_warp = set(skill_system.witch_warp(cur_unit))
                     # Sound -- ADD FOOTSTEP SOUNDS
                     if cur_unit.has_attacked or cur_unit.has_traded:
                         cur_unit.current_move = action.CantoMove(cur_unit, game.cursor.position)
                         game.state.change('canto_wait')
+                    elif game.cursor.position in witch_warp:
+                        cur_unit.current_move = action.Warp(cur_unit, game.cursor.position)
+                        game.state.change('menu')
                     else:
                         cur_unit.current_move = action.Move(cur_unit, game.cursor.position)
                         game.state.change('menu')
@@ -597,6 +599,7 @@ class MenuState(MapState):
         # Play this here because there's a gap in sound while unit is moving
         SOUNDTHREAD.play_sfx('Select 2')
         game.cursor.hide()
+        game.stat_screen.reset_surfs()
         self.cur_unit = game.cursor.cur_unit
         if not self.cur_unit or not self.cur_unit.position:
             # Could happen if unit escaped
@@ -710,6 +713,7 @@ class MenuState(MapState):
                 if self.cur_unit.current_move:
                     action.reverse(self.cur_unit.current_move)
                     self.cur_unit.current_move = None
+                    game.stat_screen.reset_surfs()
                 # game.cursor.set_pos(self.cur_unit.position)
                 game.state.change('move')
                 game.cursor.construct_arrows(game.cursor.path[::-1])
@@ -997,6 +1001,11 @@ class WeaponChoiceState(MapState):
             options = game.memory['valid_weapons']
         else:
             options = target_system.get_all_weapons(unit)
+        # Handle memento staff
+        if options and options[0].memento_staff:
+            staff = options[0]
+            spells = target_system.get_all_spells(unit)
+            options = [staff.memento_staff.get_ward(spell) for spell in spells]
         # Skill straining
         options = [option for option in options if target_system.get_valid_targets(unit, option)]
         return options
@@ -1053,6 +1062,9 @@ class WeaponChoiceState(MapState):
             # If the item is in our inventory, bring it to the top
             if selection in self.cur_unit.items:
                 action.do(action.BringToTopItem(self.cur_unit, selection))
+            elif selection.memento_ward:
+                spell = selection.memento_ward.get_spell(self.cur_unit, selection)
+                action.do(action.BringToTopItem(self.cur_unit, spell))
 
             game.memory['item'] = selection
             game.state.change('combat_targeting')
diff --git a/app/engine/help_menu.py b/app/engine/help_menu.py
index 623ec0ca..7b41d912 100644
--- a/app/engine/help_menu.py
+++ b/app/engine/help_menu.py
@@ -10,7 +10,7 @@ from app.engine.game_state import game
 
 class HelpDialog():
     help_logo = SPRITES.get('help_logo')
-    font = FONT['convo-black']
+    font = FONT['convo-white']
 
     def __init__(self, desc, num_lines=2, name=False):
         self.name = name
@@ -124,6 +124,66 @@ class HelpDialog():
 
         return surf
 
+class StatDialog(HelpDialog):
+    font_green = FONT['text-green']
+    font_red = FONT['text-red']
+
+    def __init__(self, desc, bonuses):
+        self.last_time = self.start_time = 0
+        self.transition_in = False
+        self.transition_out = 0
+
+        self.desc = text_funcs.translate(desc)
+        self.bonuses = bonuses
+        
+        self.lines = text_funcs.line_wrap(self.font, self.desc, 148)
+        self.size_y = self.font.height * (len(self.lines) + len(self.bonuses)) + 16
+
+        self.help_surf = base_surf.create_base_surf(160, self.size_y, 'message_bg_base')
+        self.h_surf = engine.create_surface((160, self.size_y + 3), transparent=True)
+
+    def draw(self, surf, pos, right=False):
+        time = engine.get_time()
+        if time > self.last_time + 1000:  # If it's been at least a second since last update
+            self.start_time = time - 16
+            self.transition_in = True
+            self.transition_out = 0
+        self.last_time = time
+
+        help_surf = engine.copy_surface(self.help_surf)
+        if cf.SETTINGS['text_speed'] > 0:
+            num_characters = int(2 * (time - self.start_time) / float(cf.SETTINGS['text_speed']))
+        else:
+            num_characters = 1000
+        
+        for idx, line in enumerate(self.lines):
+            if num_characters > 0:
+                self.font.blit(line[:num_characters], help_surf, (8, self.font.height * idx + 6))
+                num_characters -= len(line)
+
+        y_height = len(self.lines) * 16
+        bonuses = sorted(self.bonuses.items(), key=lambda x: x[0] != 'Base Value')
+        for idx, (bonus, val) in enumerate(bonuses):
+            if num_characters > 0:
+                top = self.font.height * idx + 6 + y_height
+                if idx == 0:
+                    self.font.blit(str(val), help_surf, (8, top))
+                elif val > 0:
+                    self.font_green.blit("+" + str(val), help_surf, (8, top))
+                elif val < 0:
+                    self.font_red.blit(str(val), help_surf, (8, top))
+                else:
+                    self.font.blit(str(val), help_surf, (8, top))
+                self.font.blit(bonus[:num_characters], help_surf, (32, top))
+                num_characters -= len(bonus)
+
+        if right:
+            surf = self.final_draw(surf, (pos[0] - help_surf.get_width(), pos[1]), time, help_surf)
+        else:
+            surf = self.final_draw(surf, pos, time, help_surf)
+        return surf
+
+
 class ItemHelpDialog(HelpDialog):
     font_blue = FONT['text-blue']
     font_yellow = FONT['text-yellow']
@@ -170,7 +230,6 @@ class ItemHelpDialog(HelpDialog):
         self.h_surf = engine.create_surface((160, size_y + 3), transparent=True)
 
     def draw(self, surf, pos, right=False):
-        time = engine.get_time()
         time = engine.get_time()
         if time > self.last_time + 1000:  # If it's been at least a second since last update
             self.start_time = time - 16
diff --git a/app/engine/icons.py b/app/engine/icons.py
index b0cc2ecd..d2d01b65 100644
--- a/app/engine/icons.py
+++ b/app/engine/icons.py
@@ -1,6 +1,6 @@
 from app.utilities import utils
 
-from app.constants import COLORKEY
+from app.constants import COLORKEY, MEMENTO_MODE
 from app.resources.resources import RESOURCES
 from app.data.database import DB
 
@@ -95,7 +95,10 @@ def get_portrait(unit):
     if image:
         if not image.image:
             image.image = engine.image_load(image.full_path)
-        image = engine.subsurface(image.image, (0, 0, 96, 80))
+        if MEMENTO_MODE:
+            image = engine.subsurface(image.image, (0, 0, 128, 128))
+        else:
+            image = engine.subsurface(image.image, (0, 0, 96, 80))
     else:  # Generic class portrait
         klass = DB.classes.get(unit.klass)
         image = RESOURCES.icons80.get(klass.icon_nid)
@@ -164,7 +167,7 @@ def draw_stat(surf, stat_nid, unit, topright, compact=False):
             typeface = FONT['text-yellow']
         else:
             typeface = FONT['text-blue']
-        typeface.blit_right(str(value), surf, topright)
+        typeface.blit_right(str(value + bonus), surf, topright)
     else:
         if value >= class_obj.max_stats.get(stat_nid, 30):
             FONT['text-yellow'].blit_right(str(value), surf, topright)
diff --git a/app/engine/item_components/hit_components.py b/app/engine/item_components/hit_components.py
index b9d170fe..9420a0b2 100644
--- a/app/engine/item_components/hit_components.py
+++ b/app/engine/item_components/hit_components.py
@@ -166,7 +166,7 @@ class ShoveOnEndCombat(Shove):
     value = 1
 
     def end_combat(self, playback, unit, item, target, mode):
-        if not skill_system.ignore_forced_movement(target):
+        if not skill_system.ignore_forced_movement(target) and mode:
             new_position = self._check_shove(target, unit.position, self.value)
             if new_position:
                 action.do(action.ForcedMovement(target, new_position))
diff --git a/app/engine/item_components/memento_components.py b/app/engine/item_components/memento_components.py
new file mode 100644
index 00000000..074da0e4
--- /dev/null
+++ b/app/engine/item_components/memento_components.py
@@ -0,0 +1,187 @@
+from app.data.item_components import ItemComponent
+from app.data.components import Type
+
+from app.utilities import utils
+from app.engine import target_system, skill_system, action, equations
+from app.engine.game_state import game 
+
+class MementoStaff(ItemComponent):
+    nid = 'memento_staff'
+    desc = "Item contains a ward of the weapon types you want to use"
+    tag = 'memento'
+
+    expose = (Type.List, Type.Item)
+
+    def get_ward(self, spell):
+        for subitem in spell.subitems:
+            if subitem.memento_rune_type.value == spell.memento_rune_type.value:
+                return subitem
+        return None
+
+class MementoWard(ItemComponent):
+    nid = 'memento_ward'
+    desc = "Item is a ward"
+    tag = 'memento'
+
+    def get_spell(self, unit, selection):
+        spells = target_system.get_all_spells(self.cur_unit)
+        spells_that_share_memento_type = \
+            [spell for spell in spells if spell.memento_rune_type.value == selection.memento_rune_type.value]
+        return spells_that_share_memento_type[0]
+
+class MementoRuneType(ItemComponent):
+    nid = 'memento_rune_type'
+    desc = "Item has a rune type and can only be used by those with the right affinity"
+    tag = 'memento'
+
+    expose = Type.Affinity  # Nid
+
+    def available(self, unit, item) -> bool:
+        return self.value in unit.affinity
+
+class MementoSkillOnHold(ItemComponent):
+    nid = 'memento_skill_on_hold'
+    desc = "Item gives status while in unit's inventory"
+    tag = 'memento'
+
+    expose = Type.Skill  # Nid
+
+    def on_add_item(self, unit, item):
+        if not item.memento_rune_type or item.memento_rune_type.available(unit, item):
+            action.do(action.AddSkill(unit, self.value))
+
+    def on_remove_item(self, unit, item):
+        action.do(action.RemoveSkill(unit, self.value))
+
+class MementoEnemyCleaveAOE(ItemComponent):
+    nid = 'memento_enemy_cleave_aoe'
+    desc = "Gives Enemy Memento Cleave AOE"
+    tag = 'memento'
+
+    def splash(self, unit, item, position) -> tuple:
+        pos = unit.position
+        x_diff = position[0] - pos[0]
+        y_diff = position[1] - pos[1]
+        if x_diff in (1, -1):
+            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
+        elif y_diff in (1, -1):
+            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
+        else:
+            splash_positions = set()
+        
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        splash = [game.board.get_unit(pos) for pos in splash_positions]
+        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
+        main_target = position if game.board.get_unit(position) else None
+        return main_target, splash
+
+    def splash_positions(self, unit, item, position) -> set:
+        pos = unit.position
+        x_diff = position[0] - pos[0]
+        y_diff = position[1] - pos[1]
+        if x_diff in (1, -1):
+            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
+        elif y_diff in (1, -1):
+            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
+        else:
+            splash_positions = set()
+        
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        # Doesn't highlight allies positions
+        splash = {pos for pos in splash_positions if not game.board.get_unit(pos) or skill_system.check_enemy(unit, game.board.get_unit(pos))}
+        return splash
+
+class MementoEnemyPierceAOE(ItemComponent):
+    nid = 'memento_enemy_pierce_aoe'
+    desc = "Gives Enemy Memento Pierce AOE"
+    tag = 'memento'
+
+    def splash(self, unit, item, position) -> tuple:
+        pos = unit.position
+        x_diff = position[0] - pos[0]
+        y_diff = position[1] - pos[1]
+        splash_positions = {(position[0] + x_diff, position[1] + y_diff)}
+
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        splash = [game.board.get_unit(pos) for pos in splash_positions]
+        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
+        main_target = position if game.board.get_unit(position) else None
+        return main_target, splash
+
+    def splash_positions(self, unit, item, position) -> set:
+        pos = unit.position
+        x_diff = position[0] - pos[0]
+        y_diff = position[1] - pos[1]
+        splash_positions = {(position[0] + x_diff, position[1] + y_diff)}
+
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        # Doesn't highlight allies positions
+        splash = {pos for pos in splash_positions if not game.board.get_unit(pos) or skill_system.check_enemy(unit, game.board.get_unit(pos))}
+        return splash
+
+class MementoBurstAOE(ItemComponent):
+    nid = 'memento_burst_aoe'
+    desc = "Gives Memento Burst AOE"
+    tag = 'memento'
+
+    expose = Type.Int
+    value = 1
+
+    def splash(self, unit, item, position) -> tuple:
+        pos = unit.position
+        x_diff = position[0] - pos[0]
+        y_diff = position[1] - pos[1]
+        if x_diff in (1, -1):
+            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
+        elif y_diff in (1, -1):
+            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
+        else:
+            splash_positions = set()
+        
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        splash = [game.board.get_unit(pos) for pos in splash_positions]
+        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
+        main_target = position if game.board.get_unit(position) else None
+        return main_target, splash
+
+    def splash_positions(self, unit, item, position) -> set:
+        unit_pos = unit.position
+        splash_positions = {
+            (unit_pos[0], unit_pos[1] - 1),
+            (unit_pos[0], unit_pos[1] + 1),
+            (unit_pos[0] - 1, unit_pos[1]),
+            (unit_pos[0] + 1, unit_pos[1])
+        }
+        
+        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
+        return splash_positions
+
+class MementoPull(ItemComponent):
+    nid = 'memento_pull'
+    desc = "Item moves target toward user on hit, and if it cannot, applies this status instead"
+    tag = 'memento'
+
+    expose = Type.Skill
+
+    def _pull(self, user, target, magnitude: int) -> tuple:
+        offset_x = utils.clamp(target.position[0] - user.position[0], -1, 1)
+        offset_y = utils.clamp(target.position[1] - user.position[1], -1, 1)
+        new_position_target = (target.position[0] - offset_x * magnitude,
+                               target.position[1] - offset_y * magnitude)
+
+        mcost_target = game.movement.get_mcost(target, new_position_target)
+
+        if game.tilemap.check_bounds(new_position_target) and \
+                not game.board.get_unit(new_position_target) and \
+                mcost_target <= equations.parser.movement(target):
+            return new_position_target
+        return None
+
+    def end_combat(self, playback, unit, item, target, mode):
+        if not skill_system.ignore_forced_movement(target):
+            new_position_target = self._pull(unit, target, 1)
+            if new_position_target:
+                action.do(action.ForcedMovement(target, new_position_target))
+                playback.append(('shove_hit', unit, item, target))
+            else:  # Immobilize Status
+                action.do(action.AddSkill(target, self.value, unit))
diff --git a/app/engine/item_components/weapon_components.py b/app/engine/item_components/weapon_components.py
index e01343bd..1d2ef9a3 100644
--- a/app/engine/item_components/weapon_components.py
+++ b/app/engine/item_components/weapon_components.py
@@ -19,8 +19,11 @@ class WeaponType(ItemComponent):
 
     def available(self, unit, item) -> bool:
         klass = DB.classes.get(unit.klass)
-        klass_usable = klass.wexp_gain.get(self.value).usable
-        return unit.wexp[self.value] > 0 and klass_usable
+        wexp_gain = klass.wexp_gain.get(self.value)
+        if wexp_gain:
+            klass_usable = wexp_gain.usable
+            return unit.wexp[self.value] > 0 and klass_usable
+        return False
 
 class WeaponRank(ItemComponent):
     nid = 'weapon_rank'
diff --git a/app/engine/item_funcs.py b/app/engine/item_funcs.py
index c6f6ac5d..b5b4553d 100644
--- a/app/engine/item_funcs.py
+++ b/app/engine/item_funcs.py
@@ -90,6 +90,10 @@ def create_item(unit, item_nid, droppable=False):
         for subitem_nid in item.sequence_item.value:
             create_subitem(subitem_nid)
 
+    elif item.memento_staff:
+        for subitem_nid in item.memento_staff.value:
+            create_subitem(subitem_nid)
+
     return item
 
 def create_items(unit, item_nid_list: list) -> list:
diff --git a/app/engine/level_cursor.py b/app/engine/level_cursor.py
index c7e94aac..90ec20c5 100644
--- a/app/engine/level_cursor.py
+++ b/app/engine/level_cursor.py
@@ -1,8 +1,9 @@
+import math
 from typing import Tuple
 
-from app.constants import TILEHEIGHT, TILEWIDTH
+from app.constants import TILEHEIGHT, TILEWIDTH, STATWIDTH
 from app.counters import generic3counter
-from app.engine import engine, target_system
+from app.engine import engine, target_system, image_mods, skill_system
 from app.engine.cursor import BaseCursor
 from app.engine.game_state import GameState
 from app.engine.input_manager import INPUT
@@ -68,10 +69,6 @@ class LevelCursor(BaseCursor):
         else:
             self._transition_speed = 1
 
-    def set_pos(self, pos):
-        super().set_pos(pos)
-        self.game.ui_view.remove_unit_display()
-
     def _get_path(self) -> list:
         if not self._last_valid_position:
             self.path.clear()
@@ -87,7 +84,7 @@ class LevelCursor(BaseCursor):
                 if target_system.check_path(self.cur_unit, self.path):
                     return self.path
 
-        self.path = target_system.get_path(self.cur_unit, self._last_valid_position)
+        self.path = target_system.get_path(self.cur_unit, self._last_valid_position, use_limit=True)
         return self.path
 
     def move(self, dx, dy, mouse=False, sound=True):
@@ -100,10 +97,6 @@ class LevelCursor(BaseCursor):
             self.path = self._get_path()
             self.construct_arrows(self.path[::-1])
 
-        # Remove unit info display
-        if dx != 0 or dy != 0:
-            self.game.ui_view.remove_unit_display()
-
     def autocursor(self, immediate=False):
         player_units = [unit for unit in self.game.units if unit.team == 'player' and unit.position]
         lord_units = [unit for unit in player_units if 'Lord' in unit.tags]
@@ -135,23 +128,23 @@ class LevelCursor(BaseCursor):
             if idx == 0:  # Start of path
                 direction = (path[idx + 1][0] - path[idx][0], path[idx + 1][1] - path[idx][1])
                 if direction == (1, 0):  # Right
-                    self.arrows.append(Arrow(0, 0, path[idx]))
+                    self.arrows.append(Arrow(0, 0, path[idx], idx))
                 elif direction == (-1, 0):  # Left
-                    self.arrows.append(Arrow(1, 1, path[idx]))
+                    self.arrows.append(Arrow(1, 1, path[idx], idx))
                 elif direction == (0, -1):  # Up
-                    self.arrows.append(Arrow(0, 1, path[idx]))
+                    self.arrows.append(Arrow(0, 1, path[idx], idx))
                 elif direction == (0, 1):  # Down
-                    self.arrows.append(Arrow(1, 0, path[idx]))
+                    self.arrows.append(Arrow(1, 0, path[idx], idx))
             elif idx == len(path) - 1:  # End of path
                 direction = (path[idx][0] - path[idx - 1][0], path[idx][1] - path[idx - 1][1])
                 if direction == (1, 0):  # Right
-                    self.arrows.append(Arrow(6, 0, path[idx]))
+                    self.arrows.append(Arrow(6, 0, path[idx], idx))
                 elif direction == (-1, 0):  # Left
-                    self.arrows.append(Arrow(7, 1, path[idx]))
+                    self.arrows.append(Arrow(7, 1, path[idx], idx))
                 elif direction == (0, -1):  # Up
-                    self.arrows.append(Arrow(6, 1, path[idx]))
+                    self.arrows.append(Arrow(6, 1, path[idx], idx))
                 elif direction == (0, 1):  # Down
-                    self.arrows.append(Arrow(7, 0, path[idx]))
+                    self.arrows.append(Arrow(7, 0, path[idx], idx))
             else:  # Neither beginning nor end of path
                 next_p = path[idx + 1]
                 current_p = path[idx]
@@ -159,19 +152,19 @@ class LevelCursor(BaseCursor):
                 direction = (next_p[0] - prev_p[0], next_p[1] - prev_p[1])
                 modifier = (current_p[0] - prev_p[0], current_p[1] - prev_p[1])
                 if direction == (2, 0) or direction == (-2, 0):  # Right or Left
-                    self.arrows.append(Arrow(3, 0, path[idx]))
+                    self.arrows.append(Arrow(3, 0, path[idx], idx))
                 elif direction == (0, 2) or direction == (0, -2):  # Up or Down
-                    self.arrows.append(Arrow(2, 0, path[idx]))
+                    self.arrows.append(Arrow(2, 0, path[idx], idx))
                 elif direction == (1, -1) or direction == (-1, 1):  # Topleft or Bottomright
                     if modifier == (0, -1) or modifier == (-1, 0):
-                        self.arrows.append(Arrow(4, 0, path[idx]))
+                        self.arrows.append(Arrow(4, 0, path[idx], idx))
                     elif modifier == (1, 0) or modifier == (0, 1):
-                        self.arrows.append(Arrow(5, 1, path[idx]))
+                        self.arrows.append(Arrow(5, 1, path[idx], idx))
                 elif direction == (1, 1) or direction == (-1, -1):  # Topright or Bottomleft
                     if modifier == (0, -1) or modifier == (1, 0):
-                        self.arrows.append(Arrow(5, 0, path[idx]))
+                        self.arrows.append(Arrow(5, 0, path[idx], idx))
                     else:
-                        self.arrows.append(Arrow(4, 1, path[idx]))
+                        self.arrows.append(Arrow(4, 1, path[idx], idx))
 
     def remove_arrows(self):
         self._last_valid_position = None
@@ -233,7 +226,7 @@ class LevelCursor(BaseCursor):
             mouse_pos = INPUT.get_real_mouse_position()
             if mouse_pos:
                 from_mouse = True
-                new_pos = mouse_pos[0] // TILEWIDTH, mouse_pos[1] // TILEHEIGHT
+                new_pos = (mouse_pos[0] - STATWIDTH) // TILEWIDTH, mouse_pos[1] // TILEHEIGHT
                 new_pos = int(new_pos[0] + self.game.camera.get_x()), int(new_pos[1] + self.game.camera.get_y())
                 dpos = new_pos[0] - self.position[0], new_pos[1] - self.position[1]
                 dx = dpos[0]
@@ -284,17 +277,50 @@ class LevelCursor(BaseCursor):
         if self._display_arrows:
             for arrow in self.arrows:
                 surf = arrow.draw(surf, cull_rect)
+
+            draw_unit_sprite = False
+            if self.cur_unit:    
+                if self.path and len(self.path) > 1 and \
+                        self.position == self.path[0]:
+                    draw_unit_sprite = True
+                    x_offset = self.path[0][0] - self.path[1][0]
+                    y_offset = self.path[0][1] - self.path[1][1]
+                elif self.position in set(skill_system.witch_warp(self.cur_unit)):
+                    draw_unit_sprite = True
+                    x_offset, y_offset = 0, 0
+
+            if draw_unit_sprite:
+                # Draw unit's sprite
+                if x_offset > 0:
+                    state = 'right'
+                elif x_offset < 0:
+                    state = 'left'
+                elif y_offset < 0:
+                    state = 'up'
+                else:
+                    state = 'down'
+                active_sprite = self.cur_unit.sprite.create_image(state)
+                active_sprite = image_mods.make_translucent(active_sprite.convert_alpha(), .5)
+                x_pos = self.position[0] * TILEWIDTH - cull_rect[0] - max(0, (active_sprite.get_width() - 16)//2)
+                y_pos = self.position[1] * TILEHEIGHT - cull_rect[1] - 24
+                surf.blit(active_sprite, (x_pos, y_pos))
         return surf
 
 class Arrow(object):
     sprite = SPRITES.get('movement_arrows')
+    sprite = image_mods.make_translucent(sprite, 0.1)
 
-    def __init__(self, x, y, position):
+    def __init__(self, x, y, position, idx):
         self.image = engine.subsurface(self.sprite, (x * TILEWIDTH, y * TILEHEIGHT, TILEWIDTH, TILEHEIGHT))
         self.position = position
+        self.idx = idx
 
     def draw(self, surf, cull_rect):
+        t = math.sin(math.radians((engine.get_time()//5 - self.idx * 6) % 180))
+        new_color = image_mods.blend_colors((200, 40, 0), (0, 0, 0), t)
+
         x, y = self.position
         topleft = x * TILEWIDTH - cull_rect[0], y * TILEHEIGHT - cull_rect[1]
-        surf.blit(self.image, topleft)
+        image = image_mods.change_color(self.image, new_color)
+        surf.blit(image, topleft)
         return surf
diff --git a/app/engine/level_up.py b/app/engine/level_up.py
index 9643f0ef..918a58ce 100644
--- a/app/engine/level_up.py
+++ b/app/engine/level_up.py
@@ -104,7 +104,7 @@ class ExpState(State):
             self.exp_bar = ExpBar(self.old_exp, center=not self.combat_object)
             self.start_time = current_time
 
-            if self.mana_to_gain or (self.unit.get_max_mana() > 0 and self.unit.get_mana() != self.unit.get_max_mana()):
+            if self.mana_to_gain:
                 self.mana_bar = ManaBar(self.old_mana, center=not self.combat_object)
                 self.mana_bar.bar_max = self.unit.get_max_mana()
 
diff --git a/app/engine/map_view.py b/app/engine/map_view.py
index 10f08199..db91f656 100644
--- a/app/engine/map_view.py
+++ b/app/engine/map_view.py
@@ -1,14 +1,15 @@
-from app.constants import TILEWIDTH, TILEHEIGHT, WINWIDTH, WINHEIGHT
+from app.constants import TILEWIDTH, TILEHEIGHT, WINWIDTH, WINHEIGHT, MAPWIDTH
 
 from app.engine import engine
+from app.engine.value_noise import ValueNoise
 from app.engine.game_state import game
 
 class MapView():
     def __init__(self):
-        self._unit_surf = engine.create_surface((WINWIDTH, WINHEIGHT), transparent=True)
+        self._unit_surf = engine.create_surface((MAPWIDTH, WINHEIGHT), transparent=True)
+        # self._value_noise = ValueNoise()
 
     def draw_units(self, surf, cull_rect, subsurface_rect=None):
-        # Surf is always 240x160 WxH
         unit_surf = engine.copy_surface(self._unit_surf)
 
         # Update all units except the cur unit
@@ -68,6 +69,11 @@ class MapView():
         surf = game.boundary.draw_fog_of_war(surf, full_size, cull_rect)
         surf = game.highlight.draw(surf, cull_rect)
 
+        game.tilemap.animations = [anim for anim in game.tilemap.animations if not anim.update()]
+        for anim in game.tilemap.animations:
+            # anim.draw(surf, offset=(-game.camera.get_x(), -game.camera.get_y()))
+            anim.draw(surf, offset=(-cull_rect[0], -cull_rect[1]))
+
         if subsurface_cull:  # Forced smaller cull rect from animation combat black background
             # Make sure it has a width
             # Make the cull rect even smaller
@@ -79,8 +85,9 @@ class MapView():
         else:
             self.draw_units(surf, cull_rect)
 
-        surf = game.cursor.draw(surf, cull_rect)
+        # surf = self._value_noise.draw(surf)
 
+        surf = game.cursor.draw(surf, cull_rect)
 
         for weather in game.tilemap.weather:
             weather.update()
diff --git a/app/engine/memento_dialog.py b/app/engine/memento_dialog.py
new file mode 100644
index 00000000..1c11bb4b
--- /dev/null
+++ b/app/engine/memento_dialog.py
@@ -0,0 +1,323 @@
+import re
+
+from app.utilities import utils
+from app.constants import WINWIDTH, WINHEIGHT
+from app.engine.fonts import FONT
+from app.engine.sprites import SPRITES
+from app.engine import text_funcs, engine, image_mods, dialog
+from app.engine import config as cf
+
+class MementoDialogBackground():
+    background = SPRITES.get('memento_dialog_background')
+    transition_in_speed = 200  # 12 frames
+    transition_out_speed = 166  # 10 frames
+
+    def __init__(self):
+        # off, transition_in, normal, transition_out
+        self.state = 'off'
+        self.transition_progress = 0
+        self.last_update = engine.get_time()
+        self.height = self.background.get_height()
+        self.position = (0, WINHEIGHT - self.height)
+
+    def update(self) -> bool:
+        # Returns true if in normal state
+        current_time = engine.get_time()
+
+        if self.state == 'transition_in':
+            perc = (current_time - self.last_update) / self.transition_in_speed
+            self.transition_progress = utils.clamp(perc, 0, 1)
+            if self.transition_progress == 1:
+                self.state = 'normal'
+
+        elif self.state == 'transition_out':
+            perc = (current_time - self.last_update) / self.transition_out_speed
+            self.transition_progress = utils.clamp(perc, 0, 1)
+            if self.transition_progress == 1:
+                self.state = 'off'
+
+        return self.state == 'normal'
+
+    def start(self):
+        self.state = 'transition_in'
+        self.transition_progress = 0
+        self.last_update = engine.get_time()
+
+    def end(self):
+        self.state = 'transition_out'
+        self.transition_progress = 0
+        self.last_update = engine.get_time()
+
+    def ready(self):
+        return self.state == 'normal'
+
+    def draw(self, surf):
+        if self.state == 'transition_in':
+            new_width = int(max(1, self.background.get_width() * self.transition_progress))
+            new_height = max(1, self.background.get_height() - 10 + int(10*self.transition_progress))
+            bg = engine.transform_scale(self.background, (new_width, new_height))
+            bg = image_mods.make_translucent(bg, (1 - self.transition_progress))
+            surf.blit(bg, (self.position[0] + self.background.get_width()//2 - new_width//2, self.position[1] + self.height//2 - bg.get_height()//2))
+        elif self.state == 'transition_out':
+            new_width = max(1, self.background.get_width() - 10 - int(10*self.transition_progress))
+            new_height = max(1, self.background.get_height() - 10 - int(10*self.transition_progress))
+            bg = engine.transform_scale(self.background, (new_width, new_height))
+            bg = image_mods.make_translucent(bg, self.transition_progress)
+            surf.blit(bg, (self.position[0], self.position[1] + self.height//2 - bg.get_height()//2))
+        elif self.state == 'normal':
+            surf.blit(self.background, self.position)
+
+class MementoDialog(dialog.Dialog):
+    solo_flag = True
+    cursor = SPRITES.get('waiting_cursor')
+    name_tag = SPRITES.get('memento_nametag')
+    draw_cursor_flag = False
+    pause_before_wait_time = 150  # 9 frames
+    pause_time = 150  # 9 frames
+    text_width = WINWIDTH - 40
+    text_height = 64
+
+    def __init__(self, text, background, portrait=None):
+        self.plain_text = text
+        self.background = background
+        self.portrait = portrait
+        self.speaker = self.portrait.name
+        self.font_type = 'convo'
+        self.font_color = 'black'
+        self.font = FONT[self.font_type + '-' + self.font_color]
+
+        # States: 
+        # transition_in -- waiting for the dialog box to appear
+        # write -- actually adding text to the screen, one character at a time
+        # pause -- occasionally pauses for a period
+        # pause_before_wait -- will pause for some time between write and wait states (to account for player mashing A)
+        # wait -- Done writing, now waiting for the player to press A
+        # done -- No more dialog to show, waiting for the event to clean me up
+        # transition_out -- waiting for the dialog box to disappear
+        self.state = 'transition_in'
+
+        self.no_wait: bool = False  # Whether to wait for the player to press
+        self.text_commands = self.format_text(text)
+        self.text_blocks = self.get_text_blocks()
+        self.current_block = 0
+
+        # Size & Position
+        self.num_lines = self.determine_num_lines(self.current_block)
+
+        # For drawing
+        self.text_index = 0
+        self.text_lines = []
+        self.total_num_updates = 0
+
+        # For state transitions
+        self.last_update = engine.get_time()
+
+        # For sound
+        self.last_sound_update = 0
+
+    def get_text_blocks(self) -> list:
+        blocks = []
+        current_block = []
+        for command in self.text_commands:
+            if command in ('{w}', '{wait}', '{clear}'):
+                blocks.append(current_block)
+                current_block = []
+            else:
+                current_block.append(command)
+        return blocks
+
+    def line_wrap(self, line: str) -> list:
+        max_line_width = self.text_width
+        return text_funcs.line_wrap(self.font, line, max_line_width)
+
+    def determine_num_lines(self, current_block: int) -> int:
+        # Figure out how many lines we need to display this
+        block: list = self.text_blocks[current_block]
+        lines = []
+        current_line = ''
+        for command in block:
+            if command in ('{br}', '{break}'):
+                new_lines = self.line_wrap(current_line)
+                lines += new_lines
+                current_line = ''
+            elif command.startswith('{'):
+                pass
+            else:
+                current_line += command
+        new_lines = self.line_wrap(current_line)
+        lines += new_lines
+        num_lines = len(lines)
+        return num_lines
+
+    def _next_line(self):
+        self.text_lines.append([])
+
+    def _add_letter(self, letter):
+        self.text_lines[-1].append(letter)
+
+    def _next_char(self, sound=True):  # Add the next character to the text_lines list
+        if self.text_index >= len(self.text_commands):
+            self.pause_before_wait()
+            return
+        command = self.text_commands[self.text_index]
+        if command == '{br}' or command == '{break}':
+            self._next_line()
+        elif command == '{w}' or command == '{wait}':
+            self.pause_before_wait()
+        elif command == '{clear}':
+            self._next_block()
+        elif command == ' ':  # Check to see if we should move to next line
+            current_line = ''.join(self.text_lines[-1])
+            # Remove any commands from line
+            current_line = re.sub(r'\{[^}]*\}', '', current_line)
+            next_word = self._get_next_word(self.text_index)
+            if self.font.width(current_line + ' ' + next_word) > self.text_width:
+                self._next_line()
+            else:
+                self._add_letter(' ')
+        elif command in self.aesthetic_commands:
+            self._add_letter(command)
+        elif command in ('.', ',', ';', '!', '?'):
+            self._add_letter(command)
+            self.pause()
+        else:
+            self._add_letter(command)
+        self.text_index += 1
+
+    def _get_next_word(self, text_index):
+        word = ''
+        for letter in self.text_commands[self.text_index + 1:]:
+            if letter == ' ':
+                break
+            elif len(letter) > 1:  # Command
+                if letter in self.aesthetic_commands:
+                    continue
+                else:
+                    break
+            else:
+                word += letter
+        return word
+
+    def _next_block(self):
+        self.text_lines.clear()
+        self._next_line()
+        self.current_block += 1
+        self.num_lines = self.determine_num_lines(self.current_block)
+
+    def is_complete(self):
+        """
+        Should no longer be drawn
+        """
+        return self.state == 'transition_out'
+
+    def is_done(self):
+        """
+        Can move onto processing other commands
+        """
+        return self.state == 'done'
+
+    def is_done_or_wait(self):
+        return self.state in ('done', 'wait')
+
+    def pause(self):
+        self.state = 'pause'
+        self.last_update = engine.get_time()
+
+    def pause_before_wait(self):
+        self.state = 'pause_before_wait'
+        self.last_update = engine.get_time()
+
+    def hurry_up(self):
+        if self.state == 'write':
+            while self.state == 'write':
+                self._next_char()
+                # Skip regular pauses
+                if self.state == 'pause':
+                    self.state = 'write'
+        elif self.state == 'wait':
+            if self.text_index >= len(self.text_commands):
+                self.state = 'done'
+            else:
+                self._next_block()
+                self.state = 'write'
+
+    def update(self):
+        current_time = engine.get_time()
+
+        if self.state == 'transition_in':
+            if self.background.ready():
+                self._next_line()
+                self.state = 'write'
+        elif self.state == 'transition_out':
+            self.background.update()
+        elif self.state == 'write':
+            if cf.SETTINGS['text_speed'] > 0:
+                num_updates = engine.get_delta() / float(cf.SETTINGS['text_speed'])
+                self.total_num_updates += num_updates
+                while self.total_num_updates >= 1 and self.state == 'write':
+                    self.total_num_updates -= 1
+                    self._next_char()
+                    if self.state != 'write':
+                        self.total_num_updates = 0
+            else:
+                while self.state == 'write':
+                    self._next_char()
+                    # Skip regular pauses
+                    if self.state == 'pause':
+                        self.state = 'write'
+        elif self.state == 'pause_before_wait':
+            if current_time - self.last_update > self.pause_before_wait_time:
+                if self.no_wait:
+                    self.state = 'done'
+                else:
+                    self.state = 'wait'
+        elif self.state == 'pause':  # Regular pause for periods
+            if current_time - self.last_update > self.pause_time:
+                self.state = 'write'
+
+    def draw_text(self, surf):
+        text_surf = engine.create_surface((self.text_width, self.text_height), transparent=True)
+
+        current_color = self.font_color
+
+        for idx, line in enumerate(self.text_lines):
+            x_pos = 0
+            y_pos = 16 * idx + (8 * (4 - self.num_lines))
+
+            line_chunks, current_color = self.chunkify(line, current_color)
+            for chunk in line_chunks:
+                text, color = chunk
+                font = FONT[self.font_type + '-' + color]
+                width = font.width(text)
+                font.blit(text, text_surf, (x_pos, y_pos))
+                x_pos += width
+
+        surf.blit(text_surf, (20, WINHEIGHT - 64 - 12))
+
+    def draw_nametag(self, surf, name):
+        if self.portrait:
+            position = self.portrait.position
+            x_pos = position[0] - 4
+            y_pos = position[1] + 118
+            if x_pos < 0:
+                x_pos = position[0] + 16
+        else:
+            x_pos, y_pos = (8, 8)
+        name_tag_surf = self.name_tag.copy()
+        FONT['text-white'].blit_center(name, name_tag_surf, (name_tag_surf.get_width()//2, name_tag_surf.get_height()//2 - self.font.height//2))
+        surf.blit(name_tag_surf, (x_pos, y_pos))
+        return surf
+
+    def draw(self, surf):
+        if self.state not in ('transition_in', 'transition_out'):
+            # Draw nametag
+            if self.portrait:
+                self.draw_nametag(surf, self.speaker)
+            # Draw text
+            self.draw_text(surf)
+
+            if self.state == 'wait' and self.draw_cursor_flag:
+                cursor_pos = WINWIDTH//2 - self.cursor.get_width()//2, WINHEIGHT - 24
+                surf.blit(self.cursor, cursor_pos)
+
+        return surf
diff --git a/app/engine/menu_options.py b/app/engine/menu_options.py
index e59e5685..7ce6c009 100644
--- a/app/engine/menu_options.py
+++ b/app/engine/menu_options.py
@@ -4,7 +4,7 @@ from app.data.database import DB
 
 from app.engine.sprites import SPRITES
 from app.engine.fonts import FONT
-from app.engine import engine, image_mods, icons, help_menu, text_funcs, item_system, item_funcs
+from app.engine import engine, image_mods, icons, help_menu, text_funcs, item_system, item_funcs, skill_system
 from app.engine.game_state import game
 
 class EmptyOption():
@@ -249,6 +249,82 @@ class ItemOption(BasicOption):
         left = x + 99
         FONT[uses_font].blit_right(uses_string, surf, (left, y))
 
+class MementoAccessoryItemOption(ItemOption):
+    def get_color(self):
+        owner = game.get_unit(self.item.owner_nid)
+        main_font = 'runes-grey'
+        uses_font = 'runes-grey'
+        if self.ignore:
+            pass
+        elif self.color:
+            main_font = self.color
+            if owner and not item_funcs.available(owner, self.item):
+                pass
+            else:
+                uses_font = 'runes-blue'
+        elif self.item.droppable:
+            main_font = 'runes-green'
+            uses_font = 'runes-green'
+        elif not owner or (not self.item.memento_rune_type or self.item.memento_rune_type.available(owner, self.item)):
+            main_font = 'runes-white'
+            uses_font = 'runes-blue'
+        return main_font, uses_font
+
+class SkillOption(ItemOption):
+    """
+    Skill Objects, not Skill Prefabs
+    """
+    def _is_skill_form(self, owner) -> bool:
+        return not item_funcs.available(owner, self.item) and self.item.memento_skill_on_hold
+
+    def __init__(self, idx, skill):
+        self.idx = idx
+        self.skill = skill
+        self.help_box = None
+        self.ignore = False
+
+    def get(self):
+        return self.skill
+
+    def set_text(self, text):
+        pass
+
+    def set_skill(self, skill):
+        self.skill = skill
+
+    def width(self):
+        return 104
+
+    def height(self):
+        return 16
+
+    def get_color(self):
+        owner = game.get_unit(self.skill.owner_nid)
+        main_font = 'runes-grey'
+        uses_font = 'runes-grey'
+        if self.ignore:
+            pass
+        elif not owner or (not self.skill.memento_rune_type or self.skill.memento_rune_type.available(owner, self.skill)):
+            main_font = 'runes-white'
+            uses_font = 'runes-blue'
+        return main_font, uses_font
+
+    def get_help_box(self):
+        return help_menu.HelpDialog(self.skill.desc)
+
+    def draw(self, surf, x, y):
+        icon = icons.get_icon(self.skill)
+        if icon:
+            surf.blit(icon, (x + 2, y))
+        main_font, uses_font = self.get_color()
+        FONT[main_font].blit(self.skill.name, surf, (x + 20, y))
+        uses_string = '--'
+        text = skill_system.get_text(self.skill)
+        if text:
+            uses_string = text
+        left = x + 99
+        FONT[uses_font].blit_right(uses_string, surf, (left, y))
+
 class ConvoyItemOption(ItemOption):
     def __init__(self, idx, item, owner):
         super().__init__(idx, item)
@@ -272,7 +348,7 @@ class ConvoyItemOption(ItemOption):
 
 class FullItemOption(ItemOption):
     def width(self):
-        return 120
+        return 108
 
     def draw(self, surf, x, y):
         icon = icons.get_icon(self.item)
@@ -295,9 +371,9 @@ class FullItemOption(ItemOption):
         elif self.item.data.get('cooldown') is not None:
             uses_string_a = str(self.item.data['cooldown'])
             uses_string_b = str(self.item.data['starting_cooldown'])
-        FONT[uses_font].blit_right(uses_string_a, surf, (x + 96, y))
-        FONT['text-white'].blit("/", surf, (x + 98, y))
-        FONT[uses_font].blit_right(uses_string_b, surf, (x + 120, y))
+        FONT[uses_font].blit_right(uses_string_a, surf, (x + 84, y))
+        FONT['text-white'].blit("/", surf, (x + 86, y))
+        FONT[uses_font].blit_right(uses_string_b, surf, (x + 108, y))
 
 class ValueItemOption(ItemOption):
     def __init__(self, idx, item, disp_value):
diff --git a/app/engine/menus.py b/app/engine/menus.py
index 17dbb458..3036165b 100644
--- a/app/engine/menus.py
+++ b/app/engine/menus.py
@@ -1,6 +1,6 @@
 import math
 
-from app.constants import TILEX, WINWIDTH, WINHEIGHT
+from app.constants import TILEX, WINWIDTH, WINHEIGHT, STATWIDTH
 from app.data.database import DB
 from app.utilities import utils
 
@@ -299,7 +299,7 @@ class Simple():
     def get_topleft(self):
         if not self.topleft:
             if game.cursor.position[0] > TILEX//2 + game.camera.get_x():
-                return (14, 8)
+                return (STATWIDTH + 14, 8)
             else:
                 return (WINWIDTH - self.get_menu_width() - 14, 8)
         elif self.topleft == 'center':
diff --git a/app/engine/objects/tilemap.py b/app/engine/objects/tilemap.py
index 12b4cc3b..5a8f3c5e 100644
--- a/app/engine/objects/tilemap.py
+++ b/app/engine/objects/tilemap.py
@@ -5,7 +5,7 @@ from app.utilities.data import Data, Prefab
 
 from app.resources.resources import RESOURCES
 
-from app.engine import engine, image_mods, particles
+from app.engine import engine, image_mods, particles, animations
 
 class LayerObject():
     transition_speed = 333
@@ -116,6 +116,7 @@ class TileMapObject(Prefab):
     def __init__(self):
         super().__init__()
         self.weather: List[particles.ParticleSystem] = []
+        self.animations: List[animations.MapAnimation] = []
         self.width: int = 0
         self.height: int = 0
         self.nid: NID = None
@@ -188,6 +189,7 @@ class TileMapObject(Prefab):
         self.layers.get('base').visible = True
 
         self.weather = []
+        self.animations = []
 
         return self
 
@@ -236,6 +238,7 @@ class TileMapObject(Prefab):
         s_dict['nid'] = self.nid
         s_dict['layers'] = [layer.save() for layer in self.layers]
         s_dict['weather'] = [weather.save() for weather in self.weather]
+        s_dict['animations'] = [anim.save() for anim in self.animations]
         return s_dict
 
     @classmethod
@@ -245,6 +248,19 @@ class TileMapObject(Prefab):
         self.restore_layers(s_dict['layers'])
         weather = s_dict.get('weather', [])
         self.weather = [particles.create_system(nid, self.width, self.height) for nid in weather]
+        # Handle tile animations
+        anims = s_dict.get('animations', [])
+        self.animations = []
+        for anim in anims:
+            new_anim = animations.MapAnimation(
+                RESOURCES.animations.get(anim['nid']), 
+                anim['pos'], 
+                loop=anim['loop'], 
+                hold=anim['hold'], 
+                reverse=anim['reverse'], 
+                speed_adj=anim['speed_adj'])
+            self.animations.append(new_anim)
+
         return self
 
     def restore_layers(self, layer_list):
diff --git a/app/engine/objects/unit.py b/app/engine/objects/unit.py
index fc547149..c4f768d8 100644
--- a/app/engine/objects/unit.py
+++ b/app/engine/objects/unit.py
@@ -243,6 +243,13 @@ class UnitObject(Prefab):
             bonus += item_system.stat_change(self, weapon, stat_nid)
         return bonus
 
+    def stat_contribution(self, stat_nid: str) -> list:
+        contribution = skill_system.stat_change_contribution(self, stat_nid)
+        weapon = self.equipped_weapon
+        if weapon:
+            contribution.update(item_system.stat_change_contribution(self, weapon, stat_nid))
+        return contribution
+
     def get_stat(self, stat_nid):
         return self.stats.get(stat_nid, 0) + self.stat_bonus(stat_nid)
 
@@ -334,6 +341,9 @@ class UnitObject(Prefab):
                     self.equip(item)
                     _weapon = item
                     break
+        # Handle memento_staff mechanic
+        if _weapon and _weapon.memento_staff:
+            _weapon = _weapon.memento_staff.get_ward(_weapon)
         return _weapon
 
     def get_spell(self):
@@ -496,6 +506,7 @@ class UnitObject(Prefab):
     def wait(self):
         game.events.trigger('unit_wait', self, position=self.position)
         action.do(action.Wait(self))
+        game.stat_screen.reset_surfs()
         if game.cursor and game.cursor.cur_unit == self:
             game.cursor.cur_unit = None
 
diff --git a/app/engine/particles.py b/app/engine/particles.py
index 84f8413d..9c88eeda 100644
--- a/app/engine/particles.py
+++ b/app/engine/particles.py
@@ -5,6 +5,7 @@ from app.engine.sprites import SPRITES
 
 from app.engine import engine, image_mods
 from app.engine.game_state import game
+from app.engine.fog_particles import FogParticleSystem
 
 class ParticleSystem():
     def __init__(self, nid, particle, abundance, bounds, size, blend=None):
@@ -64,7 +65,7 @@ class Particle():
 
 class Raindrop(Particle):
     sprite = SPRITES.get('particle_raindrop')
-    speed = 2
+    speed = 3
 
     def update(self):
         self.x += self.speed
@@ -244,6 +245,9 @@ def create_system(nid, width, height):
     elif nid == 'dark':
         creation_bounds = 0, twidth, 0, theight
         ps = ParticleSystem(nid, DarkMote, .02, creation_bounds, (width, height))
+    elif nid == 'fog':
+        creation_bounds = -16, 0, -twidth//2, theight
+        ps = FogParticleSystem(nid, .2, creation_bounds, (width, height))
     elif nid == 'fire':
         creation_bounds = 0, WINWIDTH + 64, WINHEIGHT, WINHEIGHT + 16
         blend = SPRITES.get('particle_bg_fire')
diff --git a/app/engine/skill_components/combat2_components.py b/app/engine/skill_components/combat2_components.py
index 799756a3..db417a24 100644
--- a/app/engine/skill_components/combat2_components.py
+++ b/app/engine/skill_components/combat2_components.py
@@ -53,6 +53,26 @@ class LiveToServe(SkillComponent):
             actions.append(action.ChangeHP(unit, amount))
             actions.append(action.TriggerCharge(unit, self.skill))
 
+class Lifetaker(SkillComponent):
+    nid = 'lifetaker'
+    desc = r"Heal % of total HP after a kill"
+    tag = 'combat2'
+
+    expose = Type.Float
+    value = 0.5
+
+    def end_combat(self, playback, unit, item, target, mode):
+        playbacks = [p for p in playback if p[0] in ('mark_hit', 'mark_crit') and p[1] is unit and p[2] and p[2] is not unit and p[2].is_dying]
+        unique_units = {p[2] for p in playbacks}
+        num_playbacks = len(unique_units)
+        if num_playbacks > 0:
+            amount = max(2, int(unit.get_max_hp() * self.value * num_playbacks))
+            if amount > 0:
+                true_heal = min(amount, unit.get_max_hp() - unit.get_hp())
+                playback.append(('heal_hit', unit, item, unit, true_heal, true_heal))
+                action.do(action.ChangeHP(unit, amount))
+                action.do(action.TriggerCharge(unit, self.skill))
+
 class Lifelink(SkillComponent):
     nid = 'lifelink'
     desc = "Heals user %% of damage dealt"
diff --git a/app/engine/skill_components/combat_components.py b/app/engine/skill_components/combat_components.py
index e487b11d..4e38300f 100644
--- a/app/engine/skill_components/combat_components.py
+++ b/app/engine/skill_components/combat_components.py
@@ -11,7 +11,7 @@ class StatChange(SkillComponent):
     expose = (Type.Dict, Type.Stat)
     value = []
 
-    def stat_change(self, unit):
+    def stat_change(self, unit=None):
         return {stat[0]: stat[1] for stat in self.value}
 
     def tile_def(self):
@@ -171,6 +171,21 @@ class DamageMultiplier(SkillComponent):
     def damage_multiplier(self, unit, item, target, mode, attack_info, base_value):
         return self.value
 
+class DynamicDamageMultiplier(SkillComponent):
+    nid = 'dynamic_damage_multiplier'
+    desc = "Multiplies damage given by a fraction"
+    tag = 'combat'
+
+    expose = Type.String
+
+    def damage_multiplier(self, unit, item, target, mode, attack_info, base_value):
+        from app.engine import evaluate
+        try:
+            return float(evaluate.evaluate(self.value, unit, target, item, mode=mode, skill=self.skill, attack_info=attack_info, base_value=base_value))
+        except Exception:
+            print("Couldn't evaluate %s conditional" % self.value)
+            return 1
+
 class ResistMultiplier(SkillComponent):
     nid = 'resist_multiplier'
     desc = "Multiplies damage taken by a fraction"
diff --git a/app/engine/skill_components/memento_components.py b/app/engine/skill_components/memento_components.py
new file mode 100644
index 00000000..a246fc00
--- /dev/null
+++ b/app/engine/skill_components/memento_components.py
@@ -0,0 +1,117 @@
+from app.data.skill_components import SkillComponent
+from app.data.components import Type
+
+from app.utilities import utils
+from app.engine import equations, action, item_funcs, static_random, skill_system, combat_calcs, target_system
+from app.engine.game_state import game
+
+class MementoHitBonus(SkillComponent):
+    nid = 'memento_hit_bonus'
+    desc = "Gives out bonus to hit when another character can attack the same unit"
+    tag = 'memento'
+
+    expose = Type.Int
+    value = 10
+
+    def dynamic_accuracy(self, unit, item, target, mode):
+        if mode == 'attack' and target and target.position:
+            for other_unit in game.get_all_units():
+                if other_unit is unit:
+                    continue
+                if skill_system.check_ally(unit, other_unit):
+                    # Unit and other unit can both attack target
+                    if target.position in target_system.get_attacks(other_unit, force=True):
+                        return self.value
+        return 0
+
+class MementoShove(SkillComponent):
+    nid = 'memento_shove'
+    desc = "All attacks shove target after combat"
+    tag = 'memento'
+
+    def _check_shove(self, unit_to_move, anchor_pos, magnitude):
+        offset_x = utils.clamp(unit_to_move.position[0] - anchor_pos[0], -1, 1)
+        offset_y = utils.clamp(unit_to_move.position[1] - anchor_pos[1], -1, 1)
+        new_position = (unit_to_move.position[0] + offset_x,
+                        unit_to_move.position[1] + offset_y)
+
+        mcost = game.movement.get_mcost(unit_to_move, new_position)
+        if game.tilemap.check_bounds(new_position) and \
+                not game.board.get_unit(new_position) and \
+                mcost < 99:
+            return new_position
+        return False
+
+    def cleanup_combat(self, playback, unit, item, target, mode):
+        marks = [mark[0] for mark in playback if mark[0] in ('mark_hit', 'mark_crit') and mark[1] is unit and mark[2] is target]
+        did_hit = len(marks) > 0
+        if did_hit and not skill_system.ignore_forced_movement(target) and mode != 'splash':
+            new_position = self._check_shove(target, unit.position, 1)
+            if new_position:
+                action.do(action.ForcedMovement(target, new_position))
+                playback.append(('shove_hit', unit, item, target))
+            else:
+                # Do half damage again when you shove into a wall
+                damage = combat_calcs.compute_damage(unit, target, item, target.get_weapon(), mode)
+                damage = damage // 2
+                action.do(action.ChangeHP(target, -damage))
+
+class MementoTempo(SkillComponent):
+    nid = 'memento_tempo'
+    desc = "Gives +4 DEF if attacked last player phase, +4 POW otherwise"
+    tag = 'memento'
+
+    def init(self, skill):
+        self.skill.data['_has_attacked'] = False
+        self.skill.data['_last_turn'] = -1
+
+    def end_combat(self, playback, attacker, main_item, defender, mode):
+        if mode == 'attack' and defender and skill_system.check_enemy(attacker, defender):
+            action.do(action.SetObjData(self.skill, '_has_attacked', True))
+
+    def on_endstep(self, actions, playback, unit):
+        if self.skill.data['_has_attacked']:
+            action.do(action.SetObjData(self.skill, '_last_turn', game.turncount))
+            action.do(action.SetObjData(self.skill, '_has_attacked', False))
+        else:
+            action.do(action.SetObjData(self.skill, '_last_turn', -1))
+            
+    def on_end_chapter(self, unit, skill):
+        action.do(action.SetObjData(self.skill, '_last_turn', -1))
+
+    def stat_change(self, unit) -> dict:
+        if game.turncount > 0:
+            if game.turncount > self.skill.data['_last_turn'] + 1:
+                return {'POW': 4}
+            else:
+                return {'DEF': 4}
+        return {}
+
+class WitchWarp(SkillComponent):
+    nid = 'witch_warp'
+    desc = "Allows unit to witch warp to the given units"
+    tag = 'memento'
+
+    expose = (Type.List, Type.Unit)
+
+    def witch_warp(self, unit) -> list:
+        positions = []
+        for val in self.value:
+            u = game.get_unit(val)
+            if u and u.position:
+                partner_pos = u.position
+            else:
+                continue
+            if partner_pos:
+                positions += target_system.get_adjacent_positions(partner_pos)
+        return positions
+
+class MementoRuneType(SkillComponent):
+    nid = 'memento_rune_type'
+    desc = "Skill has a rune type and can only be used by those with the right affinity"
+    tag = 'memento'
+
+    expose = Type.Affinity  # Nid
+
+    def available(self, unit, skill) -> bool:
+        return self.value in unit.affinity
diff --git a/app/engine/skill_components/status_components.py b/app/engine/skill_components/status_components.py
index 06c4524b..d0882816 100644
--- a/app/engine/skill_components/status_components.py
+++ b/app/engine/skill_components/status_components.py
@@ -64,6 +64,20 @@ class UpkeepDamage(SkillComponent):
     def on_upkeep(self, actions, playback, unit):
         hp_change = -self.value
         actions.append(action.ChangeHP(unit, hp_change))
+        actions.append(action.TriggerCharge(unit, self.skill))
+
+class EndstepDamage(SkillComponent):
+    nid = 'endstep_damage'
+    desc = "Unit takes damage at endstep"
+    tag = "status"
+
+    expose = Type.Int
+    value = 5
+
+    def on_endstep(self, actions, playback, unit):
+        hp_change = -self.value
+        actions.append(action.ChangeHP(unit, hp_change))
+        actions.append(action.TriggerCharge(unit, self.skill))
 
 class GBAPoison(SkillComponent):
     nid = 'gba_poison'
diff --git a/app/engine/stat_screen.py b/app/engine/stat_screen.py
new file mode 100644
index 00000000..64b61685
--- /dev/null
+++ b/app/engine/stat_screen.py
@@ -0,0 +1,314 @@
+from app.constants import STATWIDTH, WINHEIGHT
+
+from app.data.database import DB
+from app.utilities import utils
+
+from app.engine.fonts import FONT
+from app.engine.sound import SOUNDTHREAD
+from app.engine.sprites import SPRITES
+from app.engine.input_manager import INPUT
+from app.engine.state import MapState
+from app.engine import engine, info_menu, text_funcs, \
+    icons, image_mods, item_funcs, menu_options, help_menu
+from app.engine.game_state import game
+from app.engine.fluid_scroll import FluidScroll
+
+def handle_info():
+    if game.cursor.get_hover():
+        SOUNDTHREAD.play_sfx('Select 1')
+        game.state.change('stat_screen')
+    else:
+        SOUNDTHREAD.play_sfx('Select 3')
+        game.boundary.toggle_all_enemy_attacks()
+
+def build_groove(surf, topleft, width, fill):
+    bg = SPRITES.get('groove_back')
+    start = engine.subsurface(bg, (0, 0, 2, 5))
+    mid = engine.subsurface(bg, (2, 0, 1, 5))
+    end = engine.subsurface(bg, (3, 0, 2, 5))
+    fg = SPRITES.get('groove_fill')
+
+    # Build back groove
+    surf.blit(start, topleft)
+    for idx in range(width - 2):
+        mid_pos = (topleft[0] + 2 + idx, topleft[1])
+        surf.blit(mid, mid_pos)
+    surf.blit(end, (topleft[0] + width, topleft[1]))
+
+    # Build fill groove
+    number_needed = int(fill * (width - 1))  # Width of groove minus section for start and end
+    for groove in range(number_needed):
+        surf.blit(fg, (topleft[0] + 1 + groove, topleft[1] + 1))
+
+class StatScreenState(MapState):
+    name = 'stat_screen'
+
+    def start(self):
+        self.fluid = FluidScroll(200, 1)
+
+        SOUNDTHREAD.play_sfx('Info In')
+        game.stat_screen.toggle_info(True)
+        game.stat_screen.info_graph.set_transition_in()
+
+    def take_input(self, event):
+        first_push = self.fluid.update()
+        directions = self.fluid.get_directions()
+
+        self.handle_mouse()
+        if game.stat_screen.info_flag:
+            if event == 'INFO' or event == 'BACK':
+                SOUNDTHREAD.play_sfx('Info Out')
+                game.stat_screen.info_graph.set_transition_out()
+                game.state.back()
+
+            if 'RIGHT' in directions:
+                SOUNDTHREAD.play_sfx('Select 6')
+                game.stat_screen.info_graph.move_right()
+            elif 'LEFT' in directions:
+                SOUNDTHREAD.play_sfx('Select 6')
+                game.stat_screen.info_graph.move_left()
+            elif 'UP' in directions:
+                SOUNDTHREAD.play_sfx('Select 6')
+                game.stat_screen.info_graph.move_up()
+            elif 'DOWN' in directions:
+                SOUNDTHREAD.play_sfx('Select 6')
+                game.stat_screen.info_graph.move_down()
+
+    def handle_mouse(self):
+        mouse_position = INPUT.get_mouse_position()
+        if not mouse_position:
+            return
+        if game.stat_screen.info_flag:
+            game.stat_screen.info_graph.handle_mouse(mouse_position)
+
+    def finish(self):
+        game.stat_screen.toggle_info(False)
+
+class StatScreen():
+    def __init__(self):
+        self.bg = SPRITES.get('stat_screen_background')
+        self.unit = None
+        self._next_unit = None
+
+        self.info_graph = info_menu.InfoGraph()
+        self.info_flag = False
+        self.info_graph.set_current_state('personal_data')
+        self.reset_surfs()
+
+        self.transition = None
+        self.transition_counter = 0
+
+    def reset_surfs(self):
+        self.info_graph.clear()
+        self.portrait_surf = None
+        self.personal_data_surf = None
+
+    def toggle_info(self, val=False):
+        self.info_flag = val
+
+    def update(self):
+        hover = game.cursor.get_hover()
+        if hover and game.state.current() == 'free':
+            if hover != self.unit:
+                self._next_unit = hover
+                self.transition = 'out'
+
+        if self.transition == 'out':
+            self.transition_counter += 1
+            self.transparency = self.transition_counter / 5
+            if self.transparency >= 1:
+                self.transition = 'in'
+                self.transparency = 1
+                self.unit = self._next_unit
+                self._next_unit = None
+                self.reset_surfs()
+
+        elif self.transition == 'in':
+            self.transition_counter -= 1
+            self.transparency = self.transition_counter / 5
+            if self.transparency <= 0:
+                self.transition = None
+                self.transparency = 0
+
+    def draw(self, surf):
+        self.update()
+        if self.bg:
+            surf.blit(self.bg, (0, 0))
+        if self.unit:
+            self.draw_portrait(surf)
+            self.draw_slide(surf)
+        if self.info_graph.current_bb:
+            self.info_graph.draw(surf)
+        return surf
+
+    def draw_portrait(self, surf):
+        if not self.portrait_surf:
+            self.portrait_surf = self.create_portrait()
+
+        # Stick it on the surface
+        if self.transparency:
+            im = image_mods.make_translucent(self.portrait_surf, self.transparency)
+            surf.blit(im, (0, 0))
+        else:
+            surf.blit(self.portrait_surf, (0, 0))
+
+    def create_portrait(self):
+        surf = engine.create_surface((STATWIDTH, WINHEIGHT), transparent=True)
+        surf.blit(SPRITES.get('info_unit'), (54, 82))
+
+        im = icons.get_portrait(self.unit)
+        if im:
+            width = im.get_width()
+            if width < 112:
+                x_pos = (width - 80)//2
+                portrait_surf = engine.subsurface(im, (x_pos, 0, 80, 72))
+                portrait_surf = engine.flip_horiz(portrait_surf)
+                surf.blit(portrait_surf, (16, 2))
+            else:
+                x_pos = (width - 112)//2
+                portrait_surf = engine.subsurface(im, (x_pos, 0, 112, 72))
+                portrait_surf = engine.flip_horiz(portrait_surf)
+                surf.blit(portrait_surf, (0, 2))
+
+        class_obj = DB.classes.get(self.unit.klass)
+        if self.unit.generic:
+            FONT['text-white'].blit(class_obj.name, surf, (8, 80))
+            self.info_graph.register((8, 80, 72, 16), class_obj.desc, 'all', first=True)
+        else:
+            FONT['text-white'].blit(self.unit.name, surf, (8, 80))
+            self.info_graph.register((8, 80, 72, 16), self.unit.desc, 'all', first=True)
+        FONT['text-blue'].blit_right(str(self.unit.level), surf, (86, 80))
+        self.info_graph.register((50, 80, 30, 16), 'Level_desc', 'all')
+        FONT['text-blue'].blit_right(str(self.unit.exp), surf, (110, 80))
+        self.info_graph.register((86, 80, 30, 16), 'Exp_desc', 'all')
+        # FONT['text-blue'].blit_right(str(self.unit.get_hp()), surf, (86, 96))
+        self.info_graph.register((50, 96, 72, 16), 'HP_desc', 'all')
+        max_hp = self.unit.get_max_hp()
+        FONT['text-blue'].blit_right(str(max_hp), surf, (110, 96))
+        affinity = DB.affinities.get(self.unit.affinity)
+        # Affinity needs icons!
+        if affinity:
+            icons.draw_item(surf, affinity, (4, 16))
+            self.info_graph.register((4, 24, 16, 16), affinity.desc, 'all')
+
+        # Skills
+        skills = [skill for skill in self.unit.skills if skill.class_skill and not skill.hidden]
+        for idx, skill in enumerate(skills):
+            left_pos = idx * 24
+            icons.draw_skill(surf, skill, (left_pos + 8, 96), compact=True)
+            help_box = help_menu.HelpDialog(skill.desc, name=skill.name)
+            self.info_graph.register((left_pos + 8, 96, 16, 16), help_box, 'all')
+
+        return surf
+
+    def draw_slide(self, surf):
+        if not self.personal_data_surf:
+            self.personal_data_surf = self.create_slide()
+        
+        buffer_surf = self.personal_data_surf.copy()
+        FONT['text-blue'].blit_right(str(self.unit.get_hp()), buffer_surf, (86, 96))
+
+        # Stick it on the surface
+        if self.transparency:
+            im = image_mods.make_translucent(buffer_surf, self.transparency)
+            surf.blit(im, (0, 0))
+        else:
+            surf.blit(buffer_surf, (0, 0))
+
+    def create_slide(self):
+        menu_size = STATWIDTH, WINHEIGHT
+        surf = engine.create_surface(menu_size, transparent=True)
+
+        self.draw_stats(surf, 116)
+        self.draw_equipment(surf, 152)
+
+        return surf
+
+    def draw_stats(self, surf, top):
+        class_obj = DB.classes.get(self.unit.klass)
+        max_stats = class_obj.max_stats
+
+        stats = [stat.nid for stat in DB.stats if stat.position == 'left']
+        # Make sure we only display up to 6 on each
+
+        for idx, stat_nid in enumerate(stats):
+            left = 37 * (idx // 2)
+            y_pos = top + 16 * (idx % 2)
+            icons.draw_stat(surf, stat_nid, self.unit, (36 + left, y_pos), compact=True)
+            # Name
+            name = DB.stats.get(stat_nid).name
+            FONT['text-yellow'].blit(name, surf, (1 + left, y_pos))
+            base_value = self.unit.stats.get(stat_nid, 0)
+            contribution = self.unit.stat_contribution(stat_nid)
+            contribution['Base Value'] = base_value
+            help_box = help_menu.StatDialog('%s_desc' % stat_nid, contribution)
+            self.info_graph.register((1 + left, y_pos, 40, 16), help_box, 'all')
+
+        # Mana / MEM
+        mana = str(self.unit.get_mana())
+        left, y_pos = (37*2, top + 16 * 1)
+        FONT['text-blue'].blit_right(mana, surf, (36 + left, y_pos))
+        FONT['text-yellow'].blit(text_funcs.translate('MANA'), surf, (1 + left, y_pos))
+        self.info_graph.register((1 + left, y_pos, 40, 16), 'MANA_desc', 'all')
+
+        return surf
+
+    def draw_equipment(self, surf, top):
+        # Equipment
+        weapon = self.unit.get_weapon()
+        accessory = self.unit.get_accessory()
+
+        # Blit items
+        for idx, item in enumerate(self.unit.nonaccessories):
+            y_pos = idx * 16 + top
+            if item.multi_item and any(subitem is weapon for subitem in item.subitems):
+                surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
+                for subitem in item.subitems:
+                    if subitem is weapon:
+                        item_option = menu_options.ItemOption(idx, subitem)
+                        break
+                else:  # Shouldn't happen
+                    item_option = menu_options.ItemOption(idx, item)
+            else:
+                if item is weapon:
+                    surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
+                item_option = menu_options.ItemOption(idx, item)
+            item_option.draw(surf, 2, y_pos)
+            self.info_graph.register((2, y_pos, 108, 16), item_option.get_help_box(), 'all')
+
+        # Blit accessories
+        for idx, item in enumerate(self.unit.accessories):
+            aidx = item_funcs.get_num_items(self.unit) + idx
+            y_pos = aidx * 16 + top
+            if item.multi_item and any(subitem is accessory for subitem in item.subitems):
+                surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
+                for subitem in item.subitems:
+                    if subitem is accessory:
+                        if not item_funcs.available(self.unit, subitem) and subitem.memento_skill_on_hold:
+                            skill = [s for s in self.unit.skills if s.nid == subitem.memento_skill_on_hold.value][0]
+                            item_option = menu_options.SkillOption(aidx, skill)
+                        else:
+                            item_option = menu_options.MementoAccessoryItemOption(aidx, subitem)
+                        break
+                else:  # Shouldn't happen
+                    if not item_funcs.available(self.unit, subitem) and subitem.memento_skill_on_hold:
+                        skill = [s for s in self.unit.skills if s.nid == subitem.memento_skill_on_hold.value][0]
+                        item_option = menu_options.SkillOption(aidx, skill)
+                    else:
+                        item_option = menu_options.MementoAccessoryItemOption(aidx, subitem)
+            else:
+                if item is accessory:
+                    surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
+                if not item_funcs.available(self.unit, item) and item.memento_skill_on_hold:
+                    skills = [s for s in self.unit.skills if s.nid == item.memento_skill_on_hold.value]
+                    if skills:
+                        item_option = menu_options.SkillOption(aidx, skills[0])
+                    else:
+                        item_option = menu_options.MementoAccessoryItemOption(aidx, item)
+                else:
+                    item_option = menu_options.MementoAccessoryItemOption(aidx, item)
+            item_option.draw(surf, 2, y_pos)
+            first = (idx == 0 and not self.unit.nonaccessories)
+            self.info_graph.register((2, y_pos, 108, 16), item_option.get_help_box(), 'all', first=first)
+
+        return surf
diff --git a/app/engine/state.py b/app/engine/state.py
index acbb662a..6b89741f 100644
--- a/app/engine/state.py
+++ b/app/engine/state.py
@@ -1,6 +1,7 @@
-from app.constants import TILEHEIGHT, TILEWIDTH, WINHEIGHT, WINWIDTH
+from app.constants import TILEHEIGHT, TILEWIDTH, WINHEIGHT, WINWIDTH, MAPWIDTH, STATWIDTH
 from app.engine.fluid_scroll import FluidScroll
 from app.engine.game_state import game
+from app.engine import engine
 
 class State():
     name = None
@@ -51,8 +52,18 @@ class MapState(State):
         pass
 
     def draw(self, surf, culled_rect=None):
+        if game.game_vars.get('stat_screen', True):
+            stat_width = STATWIDTH
+            map_width = MAPWIDTH
+        else:
+            stat_width = 0
+            map_width = WINWIDTH
         game.camera.update()
         game.highlight.update()
-        camera_cull = int(game.camera.get_x() * TILEWIDTH), int(game.camera.get_y() * TILEHEIGHT), WINWIDTH, WINHEIGHT
+        full_surf = engine.create_surface((WINWIDTH, WINHEIGHT))
+        camera_cull = int(game.camera.get_x() * TILEWIDTH), int(game.camera.get_y() * TILEHEIGHT), map_width, WINHEIGHT
         surf = game.map_view.draw(camera_cull, culled_rect)
-        return surf
+        full_surf.blit(surf, (stat_width, 0))
+        if stat_width > 0:
+            game.stat_screen.draw(full_surf)
+        return full_surf
diff --git a/app/engine/state_machine.py b/app/engine/state_machine.py
index 0a003904..0ea23e43 100644
--- a/app/engine/state_machine.py
+++ b/app/engine/state_machine.py
@@ -29,7 +29,8 @@ class StateMachine():
         from app.engine import title_screen, transitions, general_states, level_up, \
             turnwheel, game_over, settings, info_menu, prep, base, trade, promotion, \
             status_upkeep, debug_mode, chapter_title, player_choice, feat_choice, \
-            victory_screen, objective_menu, minimap, roam_state, game_menus, dialog_log
+            victory_screen, objective_menu, minimap, roam_state, game_menus, dialog_log, \
+            stat_screen
         from app.engine.overworld import overworld_states
         from app.events import event_state
         self.all_states = \
@@ -59,6 +60,7 @@ class StateMachine():
              'objective_menu': objective_menu.ObjectiveMenuState,
              'unit_menu': game_menus.UnitMenuState,
              'info_menu': info_menu.InfoMenuState,
+             'stat_screen': stat_screen.StatScreenState,
              'phase_change': general_states.PhaseChangeState,
              'move': general_states.MoveState,
              'movement': general_states.MovementState,
diff --git a/app/engine/target_system.py b/app/engine/target_system.py
index 2980c8c9..979be82f 100644
--- a/app/engine/target_system.py
+++ b/app/engine/target_system.py
@@ -147,9 +147,11 @@ def get_valid_moves(unit, force=False) -> set:
 
     valid_moves = pathfinder.process(game.board, movement_left)
     valid_moves.add(unit.position)
+    witch_warp = set(skill_system.witch_warp(unit))
+    valid_moves |= witch_warp
     return valid_moves
 
-def get_path(unit, position, ally_block=False) -> list:
+def get_path(unit, position, ally_block=False, use_limit=False) -> list:
     from app.engine.movement import MovementManager
     mtype = MovementManager.get_movement_group(unit)
     grid = game.board.get_grid(mtype)
@@ -159,7 +161,8 @@ def get_path(unit, position, ally_block=False) -> list:
     ai_fog_of_war = DB.constants.value('ai_fog_of_war')
     pathfinder = pathfinding.AStar(unit.position, position, grid, width, height, unit.team, pass_through, ai_fog_of_war)
 
-    path = pathfinder.process(game.board, ally_block=ally_block)
+    limit = unit.movement_left if use_limit else None
+    path = pathfinder.process(game.board, ally_block=ally_block, limit=limit)
     if path is None:
         return []
     return path
diff --git a/app/engine/ui_view.py b/app/engine/ui_view.py
index b820a0d4..90d02a1a 100644
--- a/app/engine/ui_view.py
+++ b/app/engine/ui_view.py
@@ -1,5 +1,5 @@
 import app.engine.config as cf
-from app.constants import TILEX, TILEY, WINHEIGHT, WINWIDTH
+from app.constants import TILEX, TILEY, WINHEIGHT, WINWIDTH, STATWIDTH, MAPWIDTH
 from app.data.database import DB
 from app.data.difficulty_modes import RNGOption
 from app.engine import (base_surf, combat_calcs, engine, equations, evaluate,
@@ -19,7 +19,7 @@ class UIView():
     y_positions = (0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0)
 
     def __init__(self):
-        self.unit_info_disp = None
+        # self.unit_info_disp = None
         self.tile_info_disp = None
         self.obj_info_disp = None
         self.attack_info_disp = None
@@ -28,7 +28,7 @@ class UIView():
 
         self.cursor_right: bool = False
 
-        self.unit_info_offset = 0
+        # self.unit_info_offset = 0
         self.obj_info_offset = 0
         self.attack_info_offset = 0
         self.initiative_info_offset = 0
@@ -39,11 +39,11 @@ class UIView():
         self.tile_last_update: int = 0
         self.current_tile_pos = None
 
-        self.remove_unit_info = True
+        # self.remove_unit_info = True
         self.obj_top = False
 
-    def remove_unit_display(self):
-        self.remove_unit_info = True
+    # def remove_unit_display(self):
+    #     self.remove_unit_info = True
 
     def get_cursor_right(self):
         return game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1
@@ -78,19 +78,19 @@ class UIView():
     def draw(self, surf):
         self.update()
         # Unit info handling
-        if self.remove_unit_info:
-            hover = game.cursor.get_hover()
-            if game.state.current() in self.legal_states and hover:
-                self.remove_unit_info = False
-                self.unit_info_disp = self.create_unit_info(hover)
-                self.unit_info_offset = min(self.unit_info_disp.get_width(), self.unit_info_offset)
-            elif self.unit_info_disp:
-                self.unit_info_offset += 20
-                if self.unit_info_offset >= 200:
-                    self.unit_info_disp = None
-        else:
-            self.unit_info_offset -= 20
-            self.unit_info_offset = max(0, self.unit_info_offset)
+        # if self.remove_unit_info:
+        #     hover = game.cursor.get_hover()
+        #     if game.state.current() in self.legal_states and hover:
+        #         self.remove_unit_info = False
+        #         self.unit_info_disp = self.create_unit_info(hover)
+        #         self.unit_info_offset = min(self.unit_info_disp.get_width(), self.unit_info_offset)
+        #     elif self.unit_info_disp:
+        #         self.unit_info_offset += 20
+        #         if self.unit_info_offset >= 200:
+        #             self.unit_info_disp = None
+        # else:
+        #     self.unit_info_offset -= 20
+        #     self.unit_info_offset = max(0, self.unit_info_offset)
 
         # Objective info handling
         if game.state.current() in self.legal_states and cf.SETTINGS['show_objective']:
@@ -116,16 +116,16 @@ class UIView():
 
         # === Final drawing
         # Should be in topleft, unless cursor is in topleft, in which case it should be in bottomleft
-        if self.unit_info_disp:
-            # If in top and not in right
-            if not DB.constants.value('initiative') or not game.initiative.draw_me:
-                if game.cursor.position[1] < TILEY // 2 + game.camera.get_y() and \
-                        not (game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1):
-                    surf.blit(self.unit_info_disp, (-self.unit_info_offset, WINHEIGHT - self.unit_info_disp.get_height()))
-                else:
-                    surf.blit(self.unit_info_disp, (-self.unit_info_offset, 0))
-            else:
-                pass
+        # if self.unit_info_disp:
+        #     # If in top and not in right
+        #     if not DB.constants.value('initiative') or not game.initiative.draw_me:
+        #         if game.cursor.position[1] < TILEY // 2 + game.camera.get_y() and \
+        #                 not (game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1):
+        #             surf.blit(self.unit_info_disp, (-self.unit_info_offset, WINHEIGHT - self.unit_info_disp.get_height()))
+        #         else:
+        #             surf.blit(self.unit_info_disp, (-self.unit_info_offset, 0))
+        #     else:
+        #         pass
 
         if game.state.current() in self.legal_states and cf.SETTINGS['show_terrain'] and \
                 (game.level_vars['_fog_of_war'] != 2 or game.board.in_vision(game.cursor.position)):
@@ -146,7 +146,7 @@ class UIView():
                 if right:
                     surf.blit(self.tile_info_disp, (5 - offset, WINHEIGHT - self.tile_info_disp.get_height() - 3)) # Bottomleft
                 else:
-                    xpos = WINWIDTH - self.tile_info_disp.get_width() - 5 + offset
+                    xpos = MAPWIDTH - self.tile_info_disp.get_width() - 5 + offset
                     ypos = WINHEIGHT - self.tile_info_disp.get_height() - 3
                     surf.blit(self.tile_info_disp, (xpos, ypos)) # Bottomright
 
@@ -263,16 +263,18 @@ class UIView():
         else:
             bg_surf = SPRITES.get('tile_info_quick_opaque').copy()
             bg_surf = image_mods.make_translucent(bg_surf, .1)
-            tile_def, tile_avoid = 0, 0
+            stat_changes = {}
             if terrain.status:
                 status_prefab = DB.skills.get(terrain.status)
                 for component in status_prefab.components:
-                    if component.defines('tile_def'):
-                        tile_def += component.tile_def()
-                    if component.defines('tile_avoid'):
-                        tile_avoid += component.tile_avoid()
-            FONT['small-white'].blit_right(str(tile_def), bg_surf, (bg_surf.get_width() - 4, 17))
-            FONT['small-white'].blit_right(str(tile_avoid), bg_surf, (bg_surf.get_width() - 4, 25))
+                    if component.defines('stat_change'):
+                        stat_changes.update(component.stat_change())
+            for idx, (stat_nid, stat_change) in enumerate(list(stat_changes.items())[:2]):
+                text = str(stat_change)
+                if stat_change > 0:
+                    text = "+" + text
+                FONT['small-white'].blit(stat_nid, bg_surf, (1, 17 + idx * 8))
+                FONT['small-white'].blit_right(text, bg_surf, (bg_surf.get_width() - 4, 17 + idx * 8))
 
         name = terrain.name
         width, height = FONT['text-white'].size(name)
@@ -432,7 +434,7 @@ class UIView():
         crit = DB.constants.get('crit').value
 
         if game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1:
-            topleft = (8 - self.attack_info_offset, 4)
+            topleft = (STATWIDTH + 8 - self.attack_info_offset, 4)
         else:
             topleft = (WINWIDTH - 77 + self.attack_info_offset, 4)
         if self.attack_info_offset > 0:
@@ -581,7 +583,7 @@ class UIView():
             mt = combat_calcs.damage(attacker, spell)
             if mt is not None:
                 height += 16
-            real_surf = base_surf.create_base_surf((80, height), 'menu_bg_base_opaque')
+            real_surf = base_surf.create_base_surf((80, height), 'menu_bg_base')
             bg_surf = engine.create_surface((real_surf.get_width() + 2, real_surf.get_height() + 4), transparent=True)
             bg_surf.blit(real_surf, (2, 4))
             bg_surf.blit(SPRITES.get('menu_gem_small'), (0, 0))
@@ -623,9 +625,9 @@ class UIView():
             unit_surf = defender.sprite.create_image('passive')
 
         if game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1:
-            topleft = (4, 4)
+            topleft = (STATWIDTH + 4, 4)
             if defender:
-                u_topleft = (16 - max(0, (unit_surf.get_width() - 16)//2), 12 - max(0, (unit_surf.get_width() - 16)//2))
+                u_topleft = (STATWIDTH + 16 - max(0, (unit_surf.get_width() - 16)//2), 12 - max(0, (unit_surf.get_width() - 16)//2))
         else:
             topleft = (WINWIDTH - 4 - width, 4)
             if defender:
@@ -702,7 +704,7 @@ class ItemDescriptionPanel():
 
     def create_surf(self):
         width, height = 96, 56
-        sub_bg_surf = base_surf.create_base_surf(width, height, 'menu_bg_base_opaque')
+        sub_bg_surf = base_surf.create_base_surf(width, height, 'menu_bg_base')
         bg_surf = engine.create_surface((width + 2, height + 4), transparent=True)
         bg_surf.blit(sub_bg_surf, (2, 4))
         bg_surf.blit(SPRITES.get('menu_gem_small'), (0, 0))
diff --git a/app/engine/unit_funcs.py b/app/engine/unit_funcs.py
index cb17b91d..1a492f81 100644
--- a/app/engine/unit_funcs.py
+++ b/app/engine/unit_funcs.py
@@ -276,3 +276,5 @@ def check_flanked(unit) -> bool:
         if left and right and skill_system.check_enemy(unit, left) and skill_system.check_enemy(unit, right):
             return True
     return False
+
+check_flanking = check_flanked
diff --git a/app/engine/value_noise.py b/app/engine/value_noise.py
new file mode 100644
index 00000000..ad4f92d4
--- /dev/null
+++ b/app/engine/value_noise.py
@@ -0,0 +1,21 @@
+import glob
+
+from app.engine import engine
+
+class ValueNoise():
+    transparency = 16  # 0 - 255 (opaque)
+    speed = 50  # ms
+
+    def __init__(self):
+        self.ims = [engine.image_load(im) for im in glob.glob('fog/im*.png')]
+        self.reset_transparency()
+
+    def reset_transparency(self):
+        for im in self.ims:
+            im.set_alpha(self.transparency)
+
+    def draw(self, surf):
+        pz = int(engine.get_time() // self.speed) % len(self.ims)
+        im = self.ims[pz]
+        surf.blit(im, (0, 0))
+        return surf
diff --git a/app/events/event.py b/app/events/event.py
index 1ef90b22..0271dc98 100644
--- a/app/events/event.py
+++ b/app/events/event.py
@@ -6,11 +6,11 @@ from typing import Callable, Dict, List, Tuple
 
 import app.engine.config as cf
 import app.engine.graphics.ui_framework as uif
-from app.constants import WINHEIGHT, WINWIDTH
+from app.constants import WINHEIGHT, WINWIDTH, MEMENTO_MODE
 from app.data.database import DB
 from app.data.level_units import GenericUnit, UniqueUnit
 from app.engine import (action, background, banner, dialog, engine, evaluate,
-                        icons, image_mods, item_funcs, item_system,
+                        icons, image_mods, item_funcs, item_system, memento_dialog,
                         skill_system, static_random, target_system, unit_funcs)
 from app.engine.animations import MapAnimation
 from app.engine.combat import interaction
@@ -21,33 +21,45 @@ from app.engine.objects.overworld import OverworldNodeObject
 from app.engine.objects.tilemap import TileMapObject
 from app.engine.objects.unit import UnitObject
 from app.engine.overworld.overworld_actions import OverworldMove
-from app.engine.overworld.overworld_map_view import OverworldMapView
 from app.engine.overworld.overworld_movement_manager import \
     OverworldMovementManager
 from app.engine.sound import SOUNDTHREAD
-from app.engine.game_state import game
 from app.events import event_commands, regions
-from app.events.event_portrait import EventPortrait
+from app.events.event_portrait import EventPortrait, MementoEventPortrait
 from app.resources.resources import RESOURCES
 from app.utilities import str_utils, utils
-from app.utilities.algorithms.interpolation import cubic_easing, tcubic_easing
 from app.utilities.typing import NID, Point
 
-screen_positions = {'OffscreenLeft': -96,
-                    'FarLeft': -24,
-                    'Left': 0,
-                    'MidLeft': 24,
-                    'CenterLeft': 24,
-                    'CenterRight': 120,
-                    'MidRight': 120,
-                    'LevelUpRight': 140,
-                    'Right': 144,
-                    'FarRight': 168,
-                    'OffscreenRight': 240}
+if MEMENTO_MODE:
+    screen_positions = {'OffscreenLeft': -128,
+                        'FarLeft': 0,
+                        'Left': 36,
+                        'MidLeft': 72,
+                        'CenterLeft': 72,
+                        'CenterRight': 184,
+                        'MidRight': 184,
+                        'LevelUpRight': 216,
+                        'Right': 220,
+                        'FarRight': 256,
+                        'OffscreenRight': 384}
+else:
+    screen_positions = {'OffscreenLeft': -96,
+                        'FarLeft': -24,
+                        'Left': 0,
+                        'MidLeft': 24,
+                        'CenterLeft': 24,
+                        'CenterRight': 120,
+                        'MidRight': 120,
+                        'LevelUpRight': 140,
+                        'Right': 144,
+                        'FarRight': 168,
+                        'OffscreenRight': 240}
 
 vertical_screen_positions = {'Top': 0,
                              'Middle': 40,
                              'Bottom': 80}
+if MEMENTO_MODE:
+    vertical_screen_positions['Top'] = 2
 
 class Event():
     _transition_speed = 250
@@ -71,6 +83,10 @@ class Event():
         self.position = position
         self.region = region
 
+        if MEMENTO_MODE:
+            self.dialog_background = memento_dialog.MementoDialogBackground()
+        else:
+            self.dialog_background = None
         self.portraits: Dict[str, EventPortrait] = {}
         self.text_boxes = []
         self.other_boxes = []
@@ -254,6 +270,9 @@ class Event():
 
         # Draw text/dialog boxes
         # if self.state == 'dialog':
+        if self.dialog_background:
+            self.dialog_background.update()
+            self.dialog_background.draw(surf)
         if not self.do_skip:
             to_draw = []
             for dialog_box in reversed(self.text_boxes):
@@ -367,6 +386,11 @@ class Event():
         if self.text_boxes:
             self.text_boxes[-1].hurry_up()
 
+    def saturate_portrait(self, portrait):
+        for port in self.portraits.values():
+            port.desaturate()
+        portrait.saturate()
+
     def run_command(self, command: event_commands.EventCommand):
         logging.info('%s: %s', command.nid, command.values)
         current_time = engine.get_time()
@@ -459,6 +483,12 @@ class Event():
             self.wait_time = current_time + int(self.transition_speed * 1.33)
             self.state = 'waiting'
 
+        elif command.nid == 'dialog_start':
+            self.dialog_background.start()
+
+        elif command.nid == 'dialog_end':
+            self.dialog_background.end()
+
         elif command.nid == 'speak':
             self.speak(command)
 
@@ -1074,16 +1104,19 @@ class Event():
             values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
             nid = values[0]
             if nid not in RESOURCES.animations.keys():
-                logging.error("Could not find map animtion %s" % nid)
+                logging.error("Could not find map animation %s" % nid)
                 return
             pos = self.parse_pos(values[1])
             if len(values) > 2:
                 speed_mult = int(values[2])
             else:
                 speed_mult = 1
-            anim = RESOURCES.animations.get(nid)
-            anim = MapAnimation(anim, pos, speed_adj=speed_mult)
-            self.animations.append(anim)
+            if 'permanent' in flags:
+                action.do(action.AddMapAnim(nid, pos, speed_mult))
+            else:
+                anim = RESOURCES.animations.get(nid)
+                anim = MapAnimation(anim, pos, speed_adj=speed_mult)
+                self.animations.append(anim)
 
             if 'no_block' in flags or self.do_skip:
                 pass
@@ -1091,6 +1124,12 @@ class Event():
                 self.wait_time = engine.get_time() + anim.get_wait()
                 self.state = 'waiting'
 
+        elif command.nid == 'remove_map_anim':
+            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+            nid = values[0]
+            pos = self.parse_pos(values[1])
+            action.do(action.RemoveMapAnim(nid, pos))
+
         elif command.nid == 'merge_parties':
             self.merge_parties(command)
 
@@ -1358,7 +1397,9 @@ class Event():
             return False
 
         pos = values[1]
-        if len(values) > 4 and values[4]: # there's a vertical position as well
+        if MEMENTO_MODE:
+            vert_pos = 'Top'
+        elif len(values) > 4 and values[4]: # there's a vertical position as well
             vert_pos = values[4]
         else:
             vert_pos = 'Bottom'
@@ -1385,7 +1426,13 @@ class Event():
         if len(values) > 2 and values[2]:
             slide = values[2]
 
-        new_portrait = EventPortrait(portrait, position, priority, transition, slide, mirror)
+        if MEMENTO_MODE:
+            new_portrait = MementoEventPortrait(portrait, position, priority, transition, 'right', mirror, name)
+        else:
+            new_portrait = EventPortrait(portrait, position, priority, transition, slide, mirror, name)
+        
+        if 'desaturate' in flags:
+            new_portrait.saturation = 0
         self.portraits[name] = new_portrait
 
         if len(values) > 3 and values[3]:
@@ -1520,7 +1567,11 @@ class Event():
             if not width:
                 width = WINWIDTH - 8
 
-        new_dialog = dialog.Dialog(text, portrait, bg, position, width, speaker=speaker, variant=variant)
+        if MEMENTO_MODE:
+            new_dialog = memento_dialog.MementoDialog(text, self.dialog_background, portrait)
+            self.saturate_portrait(portrait)
+        else:
+            new_dialog = dialog.Dialog(text, portrait, bg, position, width, speaker=speaker, variant=variant)
         self.text_boxes.append(new_dialog)
         self.state = 'dialog'
         # Bring portrait to forefront
diff --git a/app/events/event_commands.py b/app/events/event_commands.py
index 8f18f45f..62443da4 100644
--- a/app/events/event_commands.py
+++ b/app/events/event_commands.py
@@ -252,7 +252,7 @@ Extra flags:
 
     keywords = ['Portrait', 'ScreenPosition']
     optional_keywords = ['Slide', 'ExpressionList', 'VerticalScreenPosition']
-    flags = ["mirror", "low_priority", "immediate", "no_block"]
+    flags = ["mirror", "low_priority", "immediate", "no_block", "desaturate"]
 
 class MultiAddPortrait(EventCommand):
     nid = "multi_add_portrait"
@@ -372,6 +372,14 @@ Extra flags:
     optional_keywords = ['ScreenPosition', 'Width', 'DialogVariant']
     flags = ['low_priority']
 
+class DialogStart(EventCommand):
+    nid = 'dialog_start'
+    tag = Tags.DIALOGUE_TEXT
+
+class DialogEnd(EventCommand):
+    nid = 'dialog_end'
+    tag = Tags.DIALOGUE_TEXT
+
 class Narrate(EventCommand):
     nid = "narrate"
     tag = Tags.DIALOGUE_TEXT
@@ -1469,10 +1477,18 @@ Stores a given position (*Condition*) as the event's home position. It can later
 class MapAnim(EventCommand):
     nid = 'map_anim'
     tag = Tags.TILEMAP
-    desc = ( 'Plays a map animation denoted by the nid *MapAnim* at *Position*. Optional args: a speed multiplier'
-             ' *Float*, which increases the length of time it takes to play the animation (larger is slower)')
+    desc = ('Plays a map animation denoted by the nid *MapAnim* at *Position*. Optional args: a speed multiplier'
+            ' *Float*, which increases the length of time it takes to play the animation (larger is slower)')
     keywords = ["MapAnim", "Position"]
     optional_keywords = ["Float"]
+    flags = ["no_block", "permanent"]
+
+class RemoveMapAnim(EventCommand):
+    nid = 'remove_map_anim'
+    tag = Tags.TILEMAP
+    desc = ('Removes a map animation denoted by the nid *MapAnim* at *Position*. Only removes MapAnims that were created using'
+            ' the "permanent" flag')
+    keywords = ["MapAnim", "Position"]
 
 class MergeParties(EventCommand):
     nid = 'merge_parties'
diff --git a/app/events/event_portrait.py b/app/events/event_portrait.py
index 63812684..2574be93 100644
--- a/app/events/event_portrait.py
+++ b/app/events/event_portrait.py
@@ -10,6 +10,8 @@ from app.engine import engine, image_mods
 
 class EventPortrait():
     width, height = 128, 112
+    main_portrait_coords = (0, 0, 96, 80)
+    chibi_coords = (96, 16, 32, 32)
 
     halfblink = (96, 48, 32, 16)
     fullblink = (96, 64, 32, 16)
@@ -25,11 +27,14 @@ class EventPortrait():
     transition_speed = utils.frames2ms(14)
     travel_time = utils.frames2ms(15)
     bop_time = utils.frames2ms(8)
+    saturation_time = utils.frames2ms(60)
 
-    def __init__(self, portrait: Portrait, position: Point, priority, transition=False, slide=None, mirror=False, expressions=None):
+    def __init__(self, portrait: Portrait, position: Point, priority, transition=False, slide=None, mirror=False, name='', expressions=None):
         self.portrait = portrait
         if not self.portrait.image:
             self.portrait.image = engine.image_load(self.portrait.full_path)
+        self.width = self.portrait.image.get_width()
+        self.height = self.portrait.image.get_height()
         self.portrait.image = self.portrait.image.convert()
         engine.set_colorkey(self.portrait.image, COLORKEY, rleaccel=True)
         self.position = position
@@ -38,10 +43,11 @@ class EventPortrait():
         self.transition_update = engine.get_time()
         self.slide = slide
         self.mirror = mirror
+        self.name = name
         self.expressions = expressions or set()
 
-        self.main_portrait = engine.subsurface(self.portrait.image, (0, 0, 96, 80))
-        self.chibi = engine.subsurface(self.portrait.image, (96, 16, 32, 32))
+        self.main_portrait = engine.subsurface(self.portrait.image, self.main_portrait_coords)
+        self.chibi = engine.subsurface(self.portrait.image, self.chibi_coords)
 
         self.talk_on = False
         self.remove = False
@@ -68,6 +74,10 @@ class EventPortrait():
         self.bop_height = 2
         self.last_bop = None
 
+        # For saturation
+        self.saturation = 1.
+        self.saturation_state = 0
+
     def get_width(self):
         return 96
 
@@ -189,9 +199,17 @@ class EventPortrait():
 
     def update(self) -> bool:
         current_time = engine.get_time()
+        delta_time = engine.get_delta()
         self.update_talk(current_time)
         self.blink_counter.update(current_time)
 
+        if self.saturation_state != 0:
+            self.saturation += self.saturation_state * delta_time / self.saturation_time
+            self.saturation = utils.clamp(self.saturation, 0, 1)
+            # If reached one of the two extremes
+            if self.saturation == 0 or self.saturation == 1:
+                self.saturation_state = 0
+
         if self.transition:
             # 14 frames for unit face to appear
             perc = (current_time - self.transition_update) / self.transition_speed
@@ -243,6 +261,10 @@ class EventPortrait():
         if self.mirror:
             image = engine.flip_horiz(image)
 
+        if self.saturation < 1:
+            blackness = 0.5 * (1 - self.saturation)
+            image = image_mods.make_black_colorkey(image, blackness)
+
         if self.transition:
             if self.slide:
                 image = image_mods.make_translucent(image.convert_alpha(), 1 - self.transition_progress)
@@ -251,10 +273,11 @@ class EventPortrait():
 
         position = self.position
 
+        slide_length = 24
         if self.slide == 'right':
-            position = position[0] - int(24 * self.transition_progress), self.position[1]
+            position = position[0] + slide_length - int(slide_length * self.transition_progress), self.position[1]
         elif self.slide == 'left':
-            position = position[0] + int(24 * self.transition_progress), self.position[1]
+            position = position[0] - slide_length + int(slide_length * self.transition_progress), self.position[1]
 
         if self.bop_state:
             position = position[0], position[1] + self.bop_height
@@ -265,3 +288,23 @@ class EventPortrait():
         self.transition = True
         self.remove = True
         self.transition_update = engine.get_time()
+
+class MementoEventPortrait(EventPortrait):
+    width, height = 128 + 32, 128
+    main_portrait_coords = 0, 0, 128, 128
+
+    def get_width(self):
+        return 128
+
+    def get_height(self):
+        return 128
+
+    def create_image(self):
+        main_image = self.main_portrait.copy()
+        return main_image
+
+    def saturate(self):
+        self.saturation_state = 1
+
+    def desaturate(self):
+        self.saturation_state = -1
diff --git a/app/events/event_validators.py b/app/events/event_validators.py
index 0f890913..d25c7375 100644
--- a/app/events/event_validators.py
+++ b/app/events/event_validators.py
@@ -578,7 +578,7 @@ class RegionType(OptionValidator):
     valid = ['normal', 'event', 'status', 'formation']
 
 class Weather(OptionValidator):
-    valid = ["rain", "sand", "snow", "fire", "light", "dark", "smoke"]
+    valid = ["rain", "sand", "snow", "fire", "light", "dark", "smoke", "fog"]
 
 class CombatScript(Validator):
     valid_commands = ['hit1', 'hit2', 'crit1', 'crit2', 'miss1', 'miss2', '--', 'end']
diff --git a/app/resources/combat_palettes.py b/app/resources/combat_palettes.py
index cc3845f1..4490632a 100644
--- a/app/resources/combat_palettes.py
+++ b/app/resources/combat_palettes.py
@@ -18,7 +18,7 @@ class Palette(Prefab):
             if color in my_colors:
                 counter += 1
         # Similar if more than 75% of colors match
-        return counter / len(colors) > .75
+        return (counter / len(colors)) > .75
 
     def assign_colors(self, colors: list):
         self.colors = {
diff --git a/app/resources/tiles.py b/app/resources/tiles.py
index 532f389b..41de3a4b 100644
--- a/app/resources/tiles.py
+++ b/app/resources/tiles.py
@@ -9,7 +9,7 @@ from app.utilities import str_utils
 class TileMapPrefab(Prefab):
     def __init__(self, nid):
         self.nid = nid
-        self.width, self.height = TILEX, TILEY
+        self.width, self.height = TILEX, int(TILEY)
         self.autotile_fps = 29
         self.layers = Data()
         self.layers.append(LayerGrid('base', self))
diff --git a/app/utilities/pair_up_notes.txt b/app/utilities/pair_up_notes.txt
new file mode 100644
index 00000000..2890709c
--- /dev/null
+++ b/app/utilities/pair_up_notes.txt
@@ -0,0 +1,65 @@
+pair up notes
+What is difference between strike partner and paired partner
+strike_partner IS unit, paired partner is unit NID
+target_ally item nid component? line 102 of animation combat
+battle_anim copy?
+
+Consider rewriting draw_under, draw, draw_over section in animation combat
+self.right_gauge and self.left_gauge don't need to be "self"
+
+self.defender build gaurd = True in two places
+base_combat.py line 65 strike partner for defender doesn't get to play?
+
+Double wexp in simple combat for defender line 139
+
+Why is end combat for simple combat line 207, different from end combat for base_combat
+
+No extra game.state.change('exp') in simple_combat.py line 457
+self.defender does not always exist line 466 of simple_combat
+
+The exp section is just wrong with  where it is on the if statements (You have no fallback for GainExp when self.alerts is False)
+
+How does calculate paired exp work?
+Doubling + Brave in pairup mechanics
+
+Line 366 defender.guard_gauge?
+What does old defender mean?
+action.UseGauge
+
+line 109 of weapon components should be if 'blah' in playback
+ same with line 137
+gauge_inc should be a function since you could conceivably change it
+Same with max guard
+
+self.built_gaurd? What is it's purpose?
+
+Fix line 186 of combat2_components
+Why bother checking if unit == u for line 42 of PairUpBonus
+
+Line 234 of abilities (and not u.traveler)
+Replace paired partner with traveler everywhere, since they do the same thing?
+
+Separate Abilitiy do() menu then free, why? Don't we also need to wait the other unit? Plus our wait is not using the turnwheel?
+
+SwapAbility isn't implemented correctly
+Transfer is also probably not implemented correctly
+
+Also you forgot staticmethod on Transfer and Swap do()
+DB.constants.get() -> DB.constants.value()
+
+PairUp needs to clear subactions list
+And honestly should just use Leave Action as another subaction PairUp execute probably doesn't work without skilll_system.on_pairup
+
+Change UseGauge to SetGauge and IncGauge. Just makes more sense
+
+Don't think the way you have partners picked out for ai_controller works correctly when one unit is Guard Stance
+
+Same with find strike partners line 1338 of genr1eal states
+
+Instead of doing copy, instead check if battle_anim.unit exists, and if so, then create a copy
+
+Definitely refactor compute_assist_damage back into compute_damage
+
+Swap line 725 of general states is extraneous
+
+What is skill icon center doing? (gui.py)
diff --git a/diff.txt b/diff.txt
new file mode 100644
index 00000000..a903f655
--- /dev/null
+++ b/diff.txt
@@ -0,0 +1,5446 @@
+diff --git a/app/constants.py b/app/constants.py
+index 9ad7b803..ef1e86e2 100644
+--- a/app/constants.py
++++ b/app/constants.py
+@@ -1,10 +1,21 @@
+-TILEWIDTH, TILEHEIGHT = 16, 16
+-TILEX, TILEY = 15, 10
+-WINWIDTH, WINHEIGHT = TILEX * TILEWIDTH, TILEY * TILEHEIGHT
+-COLORKEY = 128, 160, 128
+-FPS = 60
+-FRAMERATE = 1000//FPS
+-
+-AUTOTILE_FRAMES = 16
+-
+-VERSION = "2021.09.15b"
++MEMENTO_MODE = True
++if MEMENTO_MODE:
++    TILEWIDTH, TILEHEIGHT = 16, 16
++    TILEX, TILEY = 17, 13.5
++    FULLTILEX = 24
++    WINWIDTH, WINHEIGHT = int(FULLTILEX * TILEWIDTH), int(TILEY * TILEHEIGHT)
++    MAPWIDTH = int(TILEX * TILEWIDTH)
++else:
++    TILEWIDTH, TILEHEIGHT = 16, 16
++    TILEX, TILEY = 15, 10
++    FULLTILEX = TILEX
++    WINWIDTH, WINHEIGHT = int(TILEX * TILEWIDTH), int(TILEY * TILEHEIGHT)
++    MAPWIDTH = WINWIDTH
++STATWIDTH = WINWIDTH - MAPWIDTH
++COLORKEY = 128, 160, 128
++FPS = 60
++FRAMERATE = 1000//FPS
++
++AUTOTILE_FRAMES = 16
++
++VERSION = "2021.07.27a"
+diff --git a/app/data/constants.py b/app/data/constants.py
+index 40656e26..7b4d5a8a 100644
+--- a/app/data/constants.py
++++ b/app/data/constants.py
+@@ -65,6 +65,8 @@ constants = ConstantCatalog([
+     Constant('boss_crit', "Final blow on boss will use critical animation", bool),
+     Constant('convoy_on_death', "Items held by dead player units are sent to convoy", bool),
+     Constant('give_and_take', "Units can give a unit after taking a unit", bool),
++    Constant('reset_mana', "Mana resets to full for units upon completion of the chapter", bool),
++    Constant('double_splash', "When doubling, splash/aoe damage is applied on the second strike as well", bool),
+     Constant('num_save_slots', "Number of save slots", int, 3, 'title'),
+     Constant('attack_zero_hit', "Enemy AI attacks even if Hit is 0", bool, True, 'ai'),
+     Constant('attack_zero_dam', "Enemy AI attacks even if Damage is 0", bool, True, 'ai'),
+diff --git a/app/editor/icons.py b/app/editor/icons.py
+index 2f742305..23a5f510 100644
+--- a/app/editor/icons.py
++++ b/app/editor/icons.py
+@@ -2,6 +2,7 @@ from PyQt5.QtWidgets import QWidget, QHBoxLayout, QPushButton
+ from PyQt5.QtGui import QPixmap, QIcon
+ from PyQt5.QtCore import Qt, pyqtSignal
+ 
++from app.constants import MEMENTO_MODE
+ from app.resources.resources import RESOURCES
+ 
+ import app.editor.utilities as editor_utilities
+@@ -100,7 +101,10 @@ class ItemIcon80(ItemIcon16):
+ 
+ class UnitPortrait(QPushButton):
+     sourceChanged = pyqtSignal(str)
+-    width, height = 96, 80
++    if MEMENTO_MODE:
++        width, height = 128, 128
++    else:
++        width, height = 96, 80
+     database = RESOURCES.portraits
+ 
+     def __init__(self, parent):
+diff --git a/app/editor/level_editor/unit_group_painter_menu.py b/app/editor/level_editor/unit_group_painter_menu.py
+index 90f631ce..b12b26f4 100644
+--- a/app/editor/level_editor/unit_group_painter_menu.py
++++ b/app/editor/level_editor/unit_group_painter_menu.py
+@@ -2,7 +2,7 @@ import functools
+ 
+ from PyQt5.QtWidgets import QPushButton, QLineEdit, \
+     QWidget, QDialog, QVBoxLayout, QMessageBox, QListWidgetItem, \
+-    QGridLayout
++    QGridLayout, QApplication
+ from PyQt5.QtCore import QSize, Qt
+ from PyQt5.QtGui import QBrush, QColor, QIcon
+ 
+@@ -311,7 +311,7 @@ class GroupUnitModel(DragDropCollectionModel):
+         elif role == Qt.ForegroundRole:
+             unit_nid = self._data[index.row()]
+             if unit_nid in self.positions:
+-                return QBrush()
++                return QBrush(QApplication.palette().text().color())
+             else:
+                 return QBrush(QColor("red"))
+         return None
+diff --git a/app/editor/portrait_editor/portrait_model.py b/app/editor/portrait_editor/portrait_model.py
+index 49cf7990..651aa9c1 100644
+--- a/app/editor/portrait_editor/portrait_model.py
++++ b/app/editor/portrait_editor/portrait_model.py
+@@ -11,6 +11,7 @@ from app.resources.resources import RESOURCES
+ 
+ from app.utilities.data import Data
+ from app.data.database import DB
++from app.constants import MEMENTO_MODE
+ 
+ from app.extensions.custom_gui import DeletionDialog
+ from app.editor.base_database_gui import ResourceCollectionModel
+@@ -88,7 +89,10 @@ class PortraitModel(ResourceCollectionModel):
+             if not portrait.pixmap:
+                 portrait.pixmap = QPixmap(portrait.full_path)
+             pixmap = portrait.pixmap
+-            chibi = pixmap.copy(96, 16, 32, 32)
++            if MEMENTO_MODE:
++                chibi = pixmap.copy(128, 0, 32, 32)
++            else:
++                chibi = pixmap.copy(96, 16, 32, 32)
+             chibi = QPixmap.fromImage(editor_utilities.convert_colorkey(chibi.toImage()))
+             return QIcon(chibi)
+         elif role == Qt.EditRole:
+@@ -114,6 +118,9 @@ class PortraitModel(ResourceCollectionModel):
+                         auto_colorkey(new_portrait)
+                         auto_frame_portrait(new_portrait)
+                         RESOURCES.portraits.append(new_portrait)
++                    elif MEMENTO_MODE:
++                        new_portrait = Portrait(nid, fn, pix)
++                        RESOURCES.portraits.append(new_portrait)
+                     else:
+                         QMessageBox.critical(self.window, "Error", "Image is not correct size (128x112 px)")
+                 else:
+diff --git a/app/editor/portrait_editor/portrait_properties.py b/app/editor/portrait_editor/portrait_properties.py
+index 30344914..f71ac9e9 100644
+--- a/app/editor/portrait_editor/portrait_properties.py
++++ b/app/editor/portrait_editor/portrait_properties.py
+@@ -7,6 +7,7 @@ from PyQt5.QtWidgets import QMessageBox, QWidget, QHBoxLayout, \
+ from PyQt5.QtCore import Qt, QSize
+ from PyQt5.QtGui import QPixmap, QPainter, QIcon
+ 
++from app.constants import MEMENTO_MODE
+ from app.extensions.spinbox_xy import SpinBoxXY
+ from app.extensions.custom_gui import PropertyBox
+ from app.editor import timer
+@@ -52,7 +53,10 @@ class PortraitProperties(QWidget):
+         left_section = QGridLayout()
+ 
+         self.portrait_view = IconView(self)
+-        self.portrait_view.setMinimumHeight(80 + 2)
++        if MEMENTO_MODE:
++            self.portrait_view.setMinimumHeight(128 + 2)
++        else:
++            self.portrait_view.setMinimumHeight(80 + 2)
+         left_section.addWidget(self.portrait_view, 0, 0, 1, 3)
+ 
+         self.smile_button = QPushButton(self)
+@@ -173,7 +177,10 @@ class PortraitProperties(QWidget):
+         self.update_talk()
+         if not self.current:
+             return
+-        main_portrait = self.current.pixmap.copy(0, 0, 96, 80)
++        if MEMENTO_MODE:
++            main_portrait = self.current.pixmap.copy(0, 0, 128, 128)
++        else:
++            main_portrait = self.current.pixmap.copy(0, 0, 96, 80)
+         main_portrait = main_portrait.toImage()
+         # For smile image
+         if self.smile_on:
+@@ -201,13 +208,14 @@ class PortraitProperties(QWidget):
+         else:
+             blink_image = None
+         # Draw image
+-        painter = QPainter()
+-        painter.begin(main_portrait)
+-        if blink_image:
+-            blink_image = blink_image.toImage()
+-            painter.drawImage(self.current.blinking_offset[0], self.current.blinking_offset[1], blink_image)
+-        painter.drawImage(self.current.smiling_offset[0], self.current.smiling_offset[1], mouth_image)
+-        painter.end()
++        if not MEMENTO_MODE:
++            painter = QPainter()
++            painter.begin(main_portrait)
++            if blink_image:
++                blink_image = blink_image.toImage()
++                painter.drawImage(self.current.blinking_offset[0], self.current.blinking_offset[1], blink_image)
++            painter.drawImage(self.current.smiling_offset[0], self.current.smiling_offset[1], mouth_image)
++            painter.end()
+ 
+         final_pix = QPixmap.fromImage(editor_utilities.convert_colorkey(main_portrait))
+         self.portrait_view.set_image(final_pix)
+diff --git a/app/editor/unit_editor/unit_model.py b/app/editor/unit_editor/unit_model.py
+index 28927128..da63d011 100644
+--- a/app/editor/unit_editor/unit_model.py
++++ b/app/editor/unit_editor/unit_model.py
+@@ -1,6 +1,7 @@
+ from PyQt5.QtGui import QPixmap, QIcon
+ from PyQt5.QtCore import Qt
+ 
++from app.constants import MEMENTO_MODE
+ from app.resources.resources import RESOURCES
+ from app.utilities.data import Data
+ from app.data.database import DB
+@@ -19,7 +20,10 @@ def get_chibi(unit):
+         return None
+     if not res.pixmap:
+         res.pixmap = QPixmap(res.full_path)
+-    pixmap = res.pixmap.copy(96, 16, 32, 32)
++    if MEMENTO_MODE:
++        pixmap = res.pixmap.copy(128, 0, 32, 32)
++    else:
++        pixmap = res.pixmap.copy(96, 16, 32, 32)
+     pixmap = QPixmap.fromImage(editor_utilities.convert_colorkey(pixmap.toImage()))
+     return pixmap
+ 
+diff --git a/app/engine/action.py b/app/engine/action.py
+index 8b410310..7097d0fa 100644
+--- a/app/engine/action.py
++++ b/app/engine/action.py
+@@ -5,8 +5,9 @@ import sys
+ 
+ from app.constants import TILEHEIGHT, TILEWIDTH
+ from app.data.database import DB
++from app.resources.resources import RESOURCES
+ from app.engine import (aura_funcs, banner, equations, item_funcs, item_system,
+-                        particles, skill_system, static_random, unit_funcs)
++                        particles, skill_system, static_random, unit_funcs, animations)
+ from app.engine.game_state import game
+ from app.engine.objects.item import ItemObject
+ from app.engine.objects.skill import SkillObject
+@@ -1968,6 +1969,39 @@ class RemoveWeather(Action):
+             new_ps = particles.create_system(self.weather_nid, game.tilemap.width, game.tilemap.height)
+             game.tilemap.weather.append(new_ps)
+ 
++class AddMapAnim(Action):
++    def __init__(self, nid, pos, speed_mult):
++        self.nid = nid
++        self.pos = pos
++        self.speed_mult = speed_mult
++
++    def do(self):
++        anim = RESOURCES.animations.get(self.nid)
++        anim = animations.MapAnimation(anim, self.pos, loop=True, speed_mult=self.speed_mult)
++        game.tilemap.animations.append(anim)
++
++    def reverse(self):
++        for anim in game.tilemap.animations[:]:
++            if anim.nid == self.nid and anim.xy_pos == self.pos:
++                game.tilemap.animations.remove(anim)
++                break
++
++class RemoveMapAnim(Action):
++    def __init__(self, nid, pos):
++        self.nid = nid
++        self.pos = pos
++        self.speed_mult = 1
++
++    def do(self):
++        for anim in game.tilemap.animations[:]:
++            if anim.nid == self.nid and anim.xy_pos == self.pos:
++                self.speed_mult = anim.speed_adj
++                game.tilemap.animations.remove(anim)
++
++    def reverse(self):
++        anim = RESOURCES.animations.get(self.nid)
++        anim = animations.MapAnimation(anim, self.pos, loop=True, speed_mult=self.speed_mult)
++        game.tilemap.animations.append(anim)
+ 
+ class ChangeObjective(Action):
+     def __init__(self, key, string):
+diff --git a/app/engine/animations.py b/app/engine/animations.py
+index 74e25a54..d8b70a63 100644
+--- a/app/engine/animations.py
++++ b/app/engine/animations.py
+@@ -1,4 +1,4 @@
+-from app.constants import TILEHEIGHT, TILEWIDTH
++from app.constants import TILEHEIGHT, TILEWIDTH, STATWIDTH
+ from app.engine import engine, image_mods
+ from app.utilities import str_utils, utils
+ 
+@@ -6,11 +6,13 @@ from app.utilities import str_utils, utils
+ # Used, for instance, for miss and no damage animations
+ 
+ class Animation():
+-    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1 ):
++    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1):
++        self.nid = anim.nid
+         if not anim.image:
+             anim.image = engine.image_load(anim.full_path)
+             anim.image = anim.image.convert_alpha()
+         self.sprite = anim.image
++        self.xy_pos = position
+         self.position = position
+         self.frame_x, self.frame_y = anim.frame_x, anim.frame_y
+         self.num_frames = anim.num_frames
+@@ -33,6 +35,14 @@ class Animation():
+         self.frames_held = 0
+         self.first_update = engine.get_time()
+ 
++    def save(self) -> tuple:
++        return {'nid': self.nid, 
++                'pos': self.xy_pos,
++                'loop': self.loop,
++                'hold': self.hold, 
++                'reverse': self.reverse, 
++                'speed_adj': self.speed_adj}
++
+     @property
+     def speed(self):
+         if str_utils.is_int(self.anim_speed):
+@@ -129,9 +139,9 @@ class Animation():
+         return surf
+ 
+ class MapAnimation(Animation):
+-    def __init__(self, anim, position, delay=0, loop=False, hold=False, speed_adj: float = 1):
+-        super().__init__(anim, position, delay, loop, hold, speed_adj=speed_adj)
+-        self.position = self.position[0] * TILEWIDTH, self.position[1] * TILEHEIGHT
++    def __init__(self, anim, position, delay=0, loop=False, hold=False, reverse=False, speed_adj: float = 1):
++        super().__init__(anim, position, delay, loop, hold, reverse, speed_adj=speed_adj)
++        self.position = STATWIDTH + self.position[0] * TILEWIDTH, self.position[1] * TILEHEIGHT
+         self.use_center()
+ 
+     def use_center(self):
+diff --git a/app/engine/battle_animation.py b/app/engine/battle_animation.py
+index 65db9153..93589eac 100644
+--- a/app/engine/battle_animation.py
++++ b/app/engine/battle_animation.py
+@@ -5,7 +5,7 @@ from app.data.database import DB
+ 
+ from app.engine.sprites import SPRITES
+ from app.engine.sound import SOUNDTHREAD
+-from app.engine import engine, image_mods, item_system, item_funcs, skill_system
++from app.engine import engine, image_mods, item_system, item_funcs
+ 
+ from app.resources.combat_anims import CombatAnimation, WeaponAnimation, EffectAnimation
+ from app.resources.combat_palettes import Palette
+@@ -779,19 +779,15 @@ def get_palette(anim_prefab: CombatAnimation, unit) -> tuple:
+     current_palette = RESOURCES.combat_palettes.get(palette_nid)
+     return palette_name, current_palette
+ 
+-def get_battle_anim(unit, item, distance=1, klass=None, default_variant=False) -> BattleAnimation:
++def get_battle_anim(unit, item, distance=1, klass=None) -> BattleAnimation:
+     # Find the right combat animation
+     if klass:
+         class_obj = DB.classes.get(klass)
+     else:
+-        class_obj = DB.classes.get(skill_system.change_animation(unit))
++        class_obj = DB.classes.get(unit.klass)
+     combat_anim_nid = class_obj.combat_anim_nid
+-    if default_variant:
+-        use_variant = unit.variant
+-    else:
+-        use_variant = skill_system.change_variant(unit)
+-    if combat_anim_nid and use_variant:
+-        combat_anim_nid += use_variant
++    if combat_anim_nid and unit.variant:
++        combat_anim_nid += unit.variant
+     res = RESOURCES.combat_anims.get(combat_anim_nid)
+     if not res:  # Try without unit variant
+         res = RESOURCES.combat_anims.get(class_obj.combat_anim_nid)
+diff --git a/app/engine/bmpfont.py b/app/engine/bmpfont.py
+index 006243ee..4ac2ee93 100644
+--- a/app/engine/bmpfont.py
++++ b/app/engine/bmpfont.py
+@@ -50,7 +50,7 @@ class BmpFont():
+         # string = string.replace('_', ' ')
+         return string
+ 
+-    def blit(self, string, surf, pos=(0, 0)):
++    def blit(self, string, surf, pos=(0, 0), reverse=False):
+         def normal_render(left, top, string):
+             for c in string:
+                 if c not in self.memory:
+@@ -72,6 +72,31 @@ class BmpFont():
+                 engine.blit(surf, subsurf, (left, top))
+                 left += char_width + self.space_offset
+ 
++        def reverse_render(left, top, string):
++            positions = []
++            for c in string:
++                if c not in self.memory:
++                    try:
++                        char_pos_x = self.chartable[c][0]
++                        char_pos_y = self.chartable[c][1]
++                        char_width = self.chartable[c][2]
++                    except KeyError as e:
++                        char_pos_x = 0
++                        char_pos_y = 0
++                        char_width = 8
++                        print(e)
++                        print("%s is not chartable" % c)
++                        print("string: ", string)
++                    subsurf = engine.subsurface(self.surface, (char_pos_x, char_pos_y, self._width, self.height))
++                    self.memory[c] = (subsurf, char_width)
++                else:
++                    subsurf, char_width = self.memory[c]
++                left += char_width + self.space_offset
++                positions.append((left, subsurf))
++            # Now reversed
++            for left, subsurf in reversed(positions):
++                engine.blit(surf, subsurf, (left, top))
++
+         def stacked_render(left, top, string):
+             orig_left = left
+             for c in string:
+@@ -107,6 +132,8 @@ class BmpFont():
+ 
+         if self.stacked:
+             stacked_render(x, y, string)
++        elif reverse:
++            reverse_render(x, y, string)
+         else:
+             normal_render(x, y, string)
+ 
+diff --git a/app/engine/combat/animation_combat.py b/app/engine/combat/animation_combat.py
+index df170a32..e9e3f701 100644
+--- a/app/engine/combat/animation_combat.py
++++ b/app/engine/combat/animation_combat.py
+@@ -764,6 +764,8 @@ class AnimationCombat(BaseCombat, MockCombat):
+         a_broke, d_broke = self.find_broken_items()
+         self.handle_broken_items(a_broke, d_broke)
+ 
++        game.stat_screen.reset_surfs()
++
+     def handle_state_stack(self):
+         """
+         Map combat has the implementation I want of this, so let's just use it
+diff --git a/app/engine/combat/simple_combat.py b/app/engine/combat/simple_combat.py
+index d0d9aa40..5312df08 100644
+--- a/app/engine/combat/simple_combat.py
++++ b/app/engine/combat/simple_combat.py
+@@ -107,14 +107,17 @@ class SimpleCombat():
+ 
+         all_units = self._all_units()
+ 
++        for unit in all_units:
++            if unit.get_hp() > 0:
++                unit.sprite.change_state('normal')
++                unit.sprite.reset()
++
+         self.cleanup_combat()
+ 
+         # Handle death
+         for unit in all_units:
+             if unit.get_hp() <= 0:
+                 game.death.should_die(unit)
+-            else:
+-                unit.sprite.change_state('normal')
+ 
+         self.turnwheel_death_messages(all_units)
+ 
+@@ -142,6 +145,8 @@ class SimpleCombat():
+         a_broke, d_broke = self.find_broken_items()
+         self.handle_broken_items(a_broke, d_broke)
+ 
++        game.stat_screen.reset_surfs()
++
+     def start_event(self, full_animation=False):
+         # region is set to True or False depending on whether we are in a battle anim
+         game.events.trigger('combat_start', self.attacker, self.defender, self.main_item, self.attacker.position, full_animation)
+diff --git a/app/engine/combat/solver.py b/app/engine/combat/solver.py
+index 5065b64e..c02390e3 100644
+--- a/app/engine/combat/solver.py
++++ b/app/engine/combat/solver.py
+@@ -78,7 +78,12 @@ class AttackerState(SolverState):
+         skill_system.start_sub_combat(actions, playback, solver.attacker, solver.main_item, solver.defender, 'attack', attack_info)
+         for idx, item in enumerate(solver.items):
+             defender = solver.defenders[idx]
+-            splash = solver.splashes[idx]
++            if DB.constants.value('double_splash'):
++                splash = solver.splashes[idx]
++            elif solver.num_attacks == 0 and solver.num_subattacks == 0:
++                splash = solver.splashes[idx]
++            else:
++                splash = []
+             target_pos = solver.target_positions[idx]
+             if defender:
+                 skill_system.start_sub_combat(actions, playback, defender, defender.get_weapon(), solver.attacker, 'defense', attack_info)
+diff --git a/app/engine/component_system_compiler/compile_skill_system.py b/app/engine/component_system_compiler/compile_skill_system.py
+index e9638cb6..7330d472 100644
+--- a/app/engine/component_system_compiler/compile_skill_system.py
++++ b/app/engine/component_system_compiler/compile_skill_system.py
+@@ -8,7 +8,7 @@ default_behaviours = (
+     'ignore_rescue_penalty', 'ignore_forced_movement', 'distant_counter',
+     'ignore_fatigue')
+ # Takes in unit, returns default value
+-exclusive_behaviours = ('can_select', 'movement_type', 'sight_range', 'empower_splash', 'num_items_offset', 'num_accessories_offset', 'change_variant', 'change_animation')
++exclusive_behaviours = ('can_select', 'movement_type', 'sight_range', 'empower_splash', 'num_items_offset', 'num_accessories_offset', 'witch_warp')
+ exclusive_behaviours += formula
+ # Takes in unit and item, returns default value
+ item_behaviours = ('modify_buy_price', 'modify_sell_price', 'limit_maximum_range', 'modify_maximum_range')
+@@ -31,7 +31,7 @@ simple_event_hooks = ('on_death',)
+ # Takes in playback, unit, item, target, mode
+ combat_event_hooks = ('start_combat', 'cleanup_combat', 'end_combat', 'pre_combat', 'post_combat', 'test_on', 'test_off')
+ # Takes in actions, playback, unit, item, target, mode, attack_info
+-subcombat_event_hooks = ('after_hit', 'after_take_hit', 'start_sub_combat', 'end_sub_combat')
++subcombat_event_hooks = ('after_hit', 'start_sub_combat', 'end_sub_combat')
+ # Takes in unit, item
+ item_event_hooks = ('on_add_item', 'on_remove_item', 'on_equip_item', 'on_unequip_item')
+ 
+diff --git a/app/engine/component_system_compiler/item_system_base.py b/app/engine/component_system_compiler/item_system_base.py
+index 1c796ebe..58702ce3 100644
+--- a/app/engine/component_system_compiler/item_system_base.py
++++ b/app/engine/component_system_compiler/item_system_base.py
+@@ -124,6 +124,19 @@ def stat_change(unit, item, stat_nid) -> int:
+             bonus += d.get(stat_nid, 0)
+     return bonus
+ 
++def stat_change_contribution(unit, item, stat_nid) -> list:
++    contribution = {}
++    for component in item.components:
++        if component.defines('stat_change'):
++            d = component.stat_change(unit)
++            val = d.get(stat_nid, 0)
++            if val != 0:
++                if item.nid in contribution:
++                    contribution[item.nid] += val
++                else:
++                    contribution[item.nid] = val
++    return contribution
++
+ def is_broken(unit, item) -> bool:
+     """
+     If any hook reports true, then it is true
+diff --git a/app/engine/component_system_compiler/skill_system_base.py b/app/engine/component_system_compiler/skill_system_base.py
+index 2212154b..9b3e81e3 100644
+--- a/app/engine/component_system_compiler/skill_system_base.py
++++ b/app/engine/component_system_compiler/skill_system_base.py
+@@ -33,6 +33,10 @@ class Defaults():
+     def num_accessories_offset(unit) -> int:
+         return 0
+ 
++    @staticmethod
++    def witch_warp(unit) -> list:
++        return []
++
+     @staticmethod
+     def exp_multiplier(unit1, unit2) -> float:
+         return 1.0
+@@ -49,14 +53,6 @@ class Defaults():
+     def enemy_wexp_multiplier(unit1, unit2) -> float:
+         return 1.0
+ 
+-    @staticmethod
+-    def change_variant(unit) -> str:
+-        return unit.variant
+-        
+-    @staticmethod
+-    def change_animation(unit) -> str:
+-        return unit.klass
+-    
+     @staticmethod
+     def steal_icon(unit1, unit2) -> bool:
+         return False
+@@ -158,6 +154,21 @@ def stat_change(unit, stat_nid) -> int:
+                     bonus += d.get(stat_nid, 0)
+     return bonus
+ 
++def stat_change_contribution(unit, stat_nid) -> dict:
++    contribution = {}
++    for skill in unit.skills:
++        for component in skill.components:
++            if component.defines('stat_change'):
++                if component.ignore_conditional or condition(skill, unit):
++                    d = component.stat_change(unit)
++                    val = d.get(stat_nid, 0)
++                    if val != 0:
++                        if skill.nid in contribution:
++                            contribution[skill.nid] += val
++                        else:
++                            contribution[skill.nid] = val
++    return contribution
++
+ def growth_change(unit, stat_nid) -> int:
+     bonus = 0
+     for skill in unit.skills:
+@@ -191,7 +202,7 @@ def before_crit(actions, playback, attacker, item, defender, mode, attack_info)
+     for skill in attacker.skills:
+         for component in skill.components:
+             if component.defines('before_crit'):
+-                component.before_crit(actions, playback, attacker, item, defender, mode, attack_info)
++                component.before_crit(actions, playback, attacker, item, defender, mode)
+ 
+ def on_upkeep(actions, playback, unit) -> tuple:  # actions, playback
+     for skill in unit.skills:
+diff --git a/app/engine/fog_particles.py b/app/engine/fog_particles.py
+new file mode 100644
+index 00000000..059560d6
+--- /dev/null
++++ b/app/engine/fog_particles.py
+@@ -0,0 +1,98 @@
++import math, random
++
++from dataclasses import dataclass
++
++from app.constants import TILEWIDTH, TILEHEIGHT
++from app.engine.sprites import SPRITES
++
++from app.engine import engine, image_mods
++from app.engine.game_state import game
++from app.utilities import utils
++
++@dataclass
++class FogParticle():
++    x: float = 0
++    y: float = 0
++    x_speed: float = 0
++    y_speed: float = 0
++    size: int = 0
++    transparency: float = 0
++    time_offset: float = 0
++
++class FogParticleSystem():
++    def __init__(self, nid, abundance, bounds, size):
++        width, height = size
++        self.nid = nid
++        self.abundance = int(abundance * width * height)
++        self.particles = []
++        self.remove_me_flag = False
++
++        self.lx, self.ux, self.ly, self.uy = bounds
++
++        # Build sprites
++        _fog_sprite = SPRITES.get('particle_fog_mote')
++        _fog_sprites = [engine.subsurface(_fog_sprite, (0, 0, 3, 3)),
++                        engine.subsurface(_fog_sprite, (3 + 1, 0, 5, 5)),
++                        engine.subsurface(_fog_sprite, (8 + 2, 0, 7, 7)),
++                        engine.subsurface(_fog_sprite, (15 + 3, 0, 9, 9)),
++                        engine.subsurface(_fog_sprite, (24 + 4, 0, 11, 11))]
++        self.transparencies = []
++        for sprite in _fog_sprites:
++            self.transparencies.append([image_mods.make_translucent(sprite, k) for k in (0.9, 0.92, 0.94, 0.96, 0.98, 1.0)])
++    
++    def save(self):
++        return self.nid
++
++    def add_particle(self, x, y):
++        transparency = .8
++        time_offset = random.randrange(0, 100) * 100
++        size = random.randrange(0, 5)
++        speed = utils.clamp(random.normalvariate(1, .5), 0.1, 5)
++        angle = random.uniform(315, 359) * math.pi / 180
++        x_speed = speed * (2.5 - size/2) * math.cos(angle)
++        y_speed = speed * (2.5 - size/2) * math.sin(angle)
++        new_particle = FogParticle(x, y, x_speed, y_speed, size, transparency, time_offset)
++        return new_particle
++        
++    def update(self):
++        current_time = engine.get_time()
++
++        for particle in self.particles:
++            particle.x += particle.x_speed
++            particle.y -= particle.y_speed
++            t_offset = math.sin((current_time + particle.time_offset) / 500)
++            particle.transparency = .95 + 0.1 * t_offset
++
++        # Remove particles that have left the map
++        self.particles = [p for p in self.particles if (p.x < game.tilemap.width * TILEWIDTH and p.y < game.tilemap.height * TILEHEIGHT)]
++
++        if len(self.particles) < self.abundance:
++            xpos = random.randint(self.lx, self.ux)
++            ypos = random.randint(self.ly, self.uy)
++            new_particle = self.add_particle(xpos, ypos)
++            self.particles.append(new_particle)
++
++        if self.abundance <= 0 and not self.particles:
++            self.remove_me_flag = True
++
++    def prefill(self):
++        for _ in range(300):
++            self.update()
++
++    def draw(self, surf, offset_x=0, offset_y=0):
++        for particle in self.particles:
++            closest_transparency = utils.clamp(particle.transparency, 0.9, 1.0)
++            if 0.9 <= closest_transparency < 0.91:
++                idx = 0
++            elif 0.91 <= closest_transparency < 0.93:
++                idx = 1
++            elif 0.93 <= closest_transparency < 0.95:
++                idx = 2
++            elif 0.95 <= closest_transparency < 0.97:
++                idx = 3
++            elif 0.97 <= closest_transparency < 0.99:
++                idx = 4
++            else:
++                idx = 5
++            sprite = self.transparencies[particle.size][idx]
++            surf.blit(sprite, (particle.x - offset_x, particle.y - offset_y))
+diff --git a/app/engine/fonts.py b/app/engine/fonts.py
+index 9c6d5c02..cc8c7a56 100644
+--- a/app/engine/fonts.py
++++ b/app/engine/fonts.py
+@@ -18,6 +18,15 @@ text.colors['grey'] = ((184, 176, 176, 255), (136, 128, 120, 255), (56, 48, 40,
+ text.colors['yellow'] = ((248, 240, 136, 255), (168, 168, 72, 255), (72, 64, 8, 255))
+ text.colors['brown'] = ((248, 248, 248, 255), (144, 112, 88, 255), (80, 40, 0, 255))
+ 
++runes = FontType('runes', 'white')
++runes.colors['white'] = ((248, 248, 248, 255), (160, 136, 216, 255), (56, 48, 40, 255))
++runes.colors['blue'] = ((192, 248, 248, 255), (80, 112, 248, 255), (24, 24, 88, 255))
++runes.colors['green'] = ((72, 232, 32, 255), (112, 160, 72, 255), (24, 88, 24, 255))
++runes.colors['red'] = ((224, 96, 80, 255), (160, 88, 72, 255), (88, 24, 24, 255))
++runes.colors['grey'] = ((184, 176, 176, 255), (136, 128, 120, 255), (56, 48, 40, 255))
++runes.colors['yellow'] = ((248, 240, 136, 255), (168, 168, 72, 255), (72, 64, 8, 255))
++runes.colors['brown'] = ((248, 248, 248, 255), (144, 112, 88, 255), (80, 40, 0, 255))
++
+ narrow = FontType('narrow', 'white')
+ narrow.colors['white'] = ((248, 248, 248, 255), (160, 136, 216, 255), (56, 48, 40, 255))
+ narrow.colors['blue'] = ((192, 248, 248, 255), (80, 112, 248, 255), (24, 24, 88, 255))
+@@ -57,7 +66,7 @@ chapter.colors['green'] = ((232, 232, 232, 255), (144, 224, 160, 255), (128, 208
+                            (104, 184, 120, 255), (112, 160, 104, 255), (56, 112, 64, 255),
+                            (16, 8, 8, 255))
+ 
+-font_types = [text, narrow, small, info, convo, chapter]
++font_types = [text, narrow, small, info, convo, chapter, runes]
+ 
+ # Load in default, uncolored fonts
+ FONT = {}
+diff --git a/app/engine/game_state.py b/app/engine/game_state.py
+index 00bc7e72..94d97b45 100644
+--- a/app/engine/game_state.py
++++ b/app/engine/game_state.py
+@@ -8,7 +8,7 @@ from typing import TYPE_CHECKING, Dict, List, Tuple
+ if TYPE_CHECKING:
+     from app.engine import (ai_controller, death,
+         game_board, highlight, map_view, movement, phase,
+-        promotion, ui_view, banner, boundary, camera, cursor,
++        promotion, ui_view, stat_screen, banner, boundary, camera, cursor,
+         initiative, records, save, supports, turnwheel, unit_sprite)
+     from app.engine.combat.simple_combat import SimpleCombat
+     from app.engine.overworld.overworld_movement_manager import \
+@@ -91,6 +91,7 @@ class GameState():
+         self.movement: movement.MovementManager | OverworldMovementManager = None
+         self.death: death.DeathManager = None
+         self.ui_view: ui_view.UIView = None
++        self.stat_screen: stat_screen.StatScreen = None
+         self.combat_instance: List[SimpleCombat] = []
+         self.exp_instance: List[Tuple[UnitObject, int, promotion.PromotionState, str]] = []
+         self.mana_instance = []
+@@ -189,7 +190,7 @@ class GameState():
+         Done on loading a level, whether from overworld, last level, save_state, etc.
+         """
+         from app.engine import (ai_controller, camera, death, highlight,
+-                                map_view, movement, phase, ui_view)
++                                map_view, movement, phase, ui_view, stat_screen)
+ 
+         # Systems
+         self.camera = camera.Camera(self)
+@@ -199,6 +200,7 @@ class GameState():
+         self.movement = movement.MovementManager()
+         self.death = death.DeathManager()
+         self.ui_view = ui_view.UIView()
++        self.stat_screen = stat_screen.StatScreen()
+         self.combat_instance = []
+         self.exp_instance = []
+         self.mana_instance = []
+@@ -434,7 +436,8 @@ class GameState():
+                 unit.traveler = None
+                 action.execute(action.RemoveSkill(unit, 'Rescue'))
+             unit.set_hp(1000)  # Set to full health
+-            unit.set_mana(1000)  # Set to full mana
++            if DB.constants.value('reset_mana'):
++                unit.set_mana(1000)  # Set to full mana
+             unit.position = None
+             unit.sprite.change_state('normal')
+             unit.reset()
+diff --git a/app/engine/general_states.py b/app/engine/general_states.py
+index d8424e36..3919e6fb 100644
+--- a/app/engine/general_states.py
++++ b/app/engine/general_states.py
+@@ -12,7 +12,7 @@ from app.engine.game_state import game
+ from app.engine import engine, action, menus, image_mods, \
+     banner, save, phase, skill_system, target_system, item_system, \
+     item_funcs, ui_view, info_menu, base_surf, gui, background, dialog, \
+-    text_funcs, equations, evaluate, supports
++    text_funcs, equations, evaluate, supports, stat_screen
+ from app.engine.combat import interaction
+ from app.engine.selection_helper import SelectionHelper
+ from app.engine.abilities import ABILITIES, PRIMARY_ABILITIES, OTHER_ABILITIES
+@@ -175,7 +175,7 @@ class FreeState(MapState):
+         game.cursor.take_input()
+ 
+         if event == 'INFO':
+-            info_menu.handle_info()
++            stat_screen.handle_info()
+ 
+         elif event == 'AUX':
+             info_menu.handle_aux()
+@@ -316,7 +316,6 @@ class OptionMenuState(MapState):
+                     game.state.change('turn_change')
+                     game.state.change('status_endstep')
+                     game.state.change('ai')
+-                    game.ui_view.remove_unit_display()
+                     return 'repeat'
+             elif selection == 'Suspend' or selection == 'Save':
+                 if cf.SETTINGS['confirm_end']:
+@@ -400,7 +399,6 @@ class OptionChildState(State):
+                     game.state.change('turn_change')
+                     game.state.change('status_endstep')
+                     game.state.change('ai')
+-                    game.ui_view.remove_unit_display()
+                     return 'repeat'
+                 elif self.menu.owner == 'Suspend':
+                     game.state.back()
+@@ -495,10 +493,14 @@ class MoveState(MapState):
+                 if game.board.in_vision(game.cursor.position) and game.board.get_unit(game.cursor.position):
+                     SOUNDTHREAD.play_sfx('Error')
+                 else:
++                    witch_warp = set(skill_system.witch_warp(cur_unit))
+                     # Sound -- ADD FOOTSTEP SOUNDS
+                     if cur_unit.has_attacked or cur_unit.has_traded:
+                         cur_unit.current_move = action.CantoMove(cur_unit, game.cursor.position)
+                         game.state.change('canto_wait')
++                    elif game.cursor.position in witch_warp:
++                        cur_unit.current_move = action.Warp(cur_unit, game.cursor.position)
++                        game.state.change('menu')
+                     else:
+                         cur_unit.current_move = action.Move(cur_unit, game.cursor.position)
+                         game.state.change('menu')
+@@ -597,6 +599,7 @@ class MenuState(MapState):
+         # Play this here because there's a gap in sound while unit is moving
+         SOUNDTHREAD.play_sfx('Select 2')
+         game.cursor.hide()
++        game.stat_screen.reset_surfs()
+         self.cur_unit = game.cursor.cur_unit
+         if not self.cur_unit or not self.cur_unit.position:
+             # Could happen if unit escaped
+@@ -710,6 +713,7 @@ class MenuState(MapState):
+                 if self.cur_unit.current_move:
+                     action.reverse(self.cur_unit.current_move)
+                     self.cur_unit.current_move = None
++                    game.stat_screen.reset_surfs()
+                 # game.cursor.set_pos(self.cur_unit.position)
+                 game.state.change('move')
+                 game.cursor.construct_arrows(game.cursor.path[::-1])
+@@ -997,6 +1001,11 @@ class WeaponChoiceState(MapState):
+             options = game.memory['valid_weapons']
+         else:
+             options = target_system.get_all_weapons(unit)
++        # Handle memento staff
++        if options and options[0].memento_staff:
++            staff = options[0]
++            spells = target_system.get_all_spells(unit)
++            options = [staff.memento_staff.get_ward(spell) for spell in spells]
+         # Skill straining
+         options = [option for option in options if target_system.get_valid_targets(unit, option)]
+         return options
+@@ -1053,6 +1062,9 @@ class WeaponChoiceState(MapState):
+             # If the item is in our inventory, bring it to the top
+             if selection in self.cur_unit.items:
+                 action.do(action.BringToTopItem(self.cur_unit, selection))
++            elif selection.memento_ward:
++                spell = selection.memento_ward.get_spell(self.cur_unit, selection)
++                action.do(action.BringToTopItem(self.cur_unit, spell))
+ 
+             game.memory['item'] = selection
+             game.state.change('combat_targeting')
+diff --git a/app/engine/help_menu.py b/app/engine/help_menu.py
+index 623ec0ca..7b41d912 100644
+--- a/app/engine/help_menu.py
++++ b/app/engine/help_menu.py
+@@ -10,7 +10,7 @@ from app.engine.game_state import game
+ 
+ class HelpDialog():
+     help_logo = SPRITES.get('help_logo')
+-    font = FONT['convo-black']
++    font = FONT['convo-white']
+ 
+     def __init__(self, desc, num_lines=2, name=False):
+         self.name = name
+@@ -124,6 +124,66 @@ class HelpDialog():
+ 
+         return surf
+ 
++class StatDialog(HelpDialog):
++    font_green = FONT['text-green']
++    font_red = FONT['text-red']
++
++    def __init__(self, desc, bonuses):
++        self.last_time = self.start_time = 0
++        self.transition_in = False
++        self.transition_out = 0
++
++        self.desc = text_funcs.translate(desc)
++        self.bonuses = bonuses
++        
++        self.lines = text_funcs.line_wrap(self.font, self.desc, 148)
++        self.size_y = self.font.height * (len(self.lines) + len(self.bonuses)) + 16
++
++        self.help_surf = base_surf.create_base_surf(160, self.size_y, 'message_bg_base')
++        self.h_surf = engine.create_surface((160, self.size_y + 3), transparent=True)
++
++    def draw(self, surf, pos, right=False):
++        time = engine.get_time()
++        if time > self.last_time + 1000:  # If it's been at least a second since last update
++            self.start_time = time - 16
++            self.transition_in = True
++            self.transition_out = 0
++        self.last_time = time
++
++        help_surf = engine.copy_surface(self.help_surf)
++        if cf.SETTINGS['text_speed'] > 0:
++            num_characters = int(2 * (time - self.start_time) / float(cf.SETTINGS['text_speed']))
++        else:
++            num_characters = 1000
++        
++        for idx, line in enumerate(self.lines):
++            if num_characters > 0:
++                self.font.blit(line[:num_characters], help_surf, (8, self.font.height * idx + 6))
++                num_characters -= len(line)
++
++        y_height = len(self.lines) * 16
++        bonuses = sorted(self.bonuses.items(), key=lambda x: x[0] != 'Base Value')
++        for idx, (bonus, val) in enumerate(bonuses):
++            if num_characters > 0:
++                top = self.font.height * idx + 6 + y_height
++                if idx == 0:
++                    self.font.blit(str(val), help_surf, (8, top))
++                elif val > 0:
++                    self.font_green.blit("+" + str(val), help_surf, (8, top))
++                elif val < 0:
++                    self.font_red.blit(str(val), help_surf, (8, top))
++                else:
++                    self.font.blit(str(val), help_surf, (8, top))
++                self.font.blit(bonus[:num_characters], help_surf, (32, top))
++                num_characters -= len(bonus)
++
++        if right:
++            surf = self.final_draw(surf, (pos[0] - help_surf.get_width(), pos[1]), time, help_surf)
++        else:
++            surf = self.final_draw(surf, pos, time, help_surf)
++        return surf
++
++
+ class ItemHelpDialog(HelpDialog):
+     font_blue = FONT['text-blue']
+     font_yellow = FONT['text-yellow']
+@@ -170,7 +230,6 @@ class ItemHelpDialog(HelpDialog):
+         self.h_surf = engine.create_surface((160, size_y + 3), transparent=True)
+ 
+     def draw(self, surf, pos, right=False):
+-        time = engine.get_time()
+         time = engine.get_time()
+         if time > self.last_time + 1000:  # If it's been at least a second since last update
+             self.start_time = time - 16
+diff --git a/app/engine/icons.py b/app/engine/icons.py
+index b0cc2ecd..d2d01b65 100644
+--- a/app/engine/icons.py
++++ b/app/engine/icons.py
+@@ -1,6 +1,6 @@
+ from app.utilities import utils
+ 
+-from app.constants import COLORKEY
++from app.constants import COLORKEY, MEMENTO_MODE
+ from app.resources.resources import RESOURCES
+ from app.data.database import DB
+ 
+@@ -95,7 +95,10 @@ def get_portrait(unit):
+     if image:
+         if not image.image:
+             image.image = engine.image_load(image.full_path)
+-        image = engine.subsurface(image.image, (0, 0, 96, 80))
++        if MEMENTO_MODE:
++            image = engine.subsurface(image.image, (0, 0, 128, 128))
++        else:
++            image = engine.subsurface(image.image, (0, 0, 96, 80))
+     else:  # Generic class portrait
+         klass = DB.classes.get(unit.klass)
+         image = RESOURCES.icons80.get(klass.icon_nid)
+@@ -164,7 +167,7 @@ def draw_stat(surf, stat_nid, unit, topright, compact=False):
+             typeface = FONT['text-yellow']
+         else:
+             typeface = FONT['text-blue']
+-        typeface.blit_right(str(value), surf, topright)
++        typeface.blit_right(str(value + bonus), surf, topright)
+     else:
+         if value >= class_obj.max_stats.get(stat_nid, 30):
+             FONT['text-yellow'].blit_right(str(value), surf, topright)
+diff --git a/app/engine/item_components/hit_components.py b/app/engine/item_components/hit_components.py
+index b9d170fe..9420a0b2 100644
+--- a/app/engine/item_components/hit_components.py
++++ b/app/engine/item_components/hit_components.py
+@@ -166,7 +166,7 @@ class ShoveOnEndCombat(Shove):
+     value = 1
+ 
+     def end_combat(self, playback, unit, item, target, mode):
+-        if not skill_system.ignore_forced_movement(target):
++        if not skill_system.ignore_forced_movement(target) and mode:
+             new_position = self._check_shove(target, unit.position, self.value)
+             if new_position:
+                 action.do(action.ForcedMovement(target, new_position))
+diff --git a/app/engine/item_components/memento_components.py b/app/engine/item_components/memento_components.py
+new file mode 100644
+index 00000000..074da0e4
+--- /dev/null
++++ b/app/engine/item_components/memento_components.py
+@@ -0,0 +1,187 @@
++from app.data.item_components import ItemComponent
++from app.data.components import Type
++
++from app.utilities import utils
++from app.engine import target_system, skill_system, action, equations
++from app.engine.game_state import game 
++
++class MementoStaff(ItemComponent):
++    nid = 'memento_staff'
++    desc = "Item contains a ward of the weapon types you want to use"
++    tag = 'memento'
++
++    expose = (Type.List, Type.Item)
++
++    def get_ward(self, spell):
++        for subitem in spell.subitems:
++            if subitem.memento_rune_type.value == spell.memento_rune_type.value:
++                return subitem
++        return None
++
++class MementoWard(ItemComponent):
++    nid = 'memento_ward'
++    desc = "Item is a ward"
++    tag = 'memento'
++
++    def get_spell(self, unit, selection):
++        spells = target_system.get_all_spells(self.cur_unit)
++        spells_that_share_memento_type = \
++            [spell for spell in spells if spell.memento_rune_type.value == selection.memento_rune_type.value]
++        return spells_that_share_memento_type[0]
++
++class MementoRuneType(ItemComponent):
++    nid = 'memento_rune_type'
++    desc = "Item has a rune type and can only be used by those with the right affinity"
++    tag = 'memento'
++
++    expose = Type.Affinity  # Nid
++
++    def available(self, unit, item) -> bool:
++        return self.value in unit.affinity
++
++class MementoSkillOnHold(ItemComponent):
++    nid = 'memento_skill_on_hold'
++    desc = "Item gives status while in unit's inventory"
++    tag = 'memento'
++
++    expose = Type.Skill  # Nid
++
++    def on_add_item(self, unit, item):
++        if not item.memento_rune_type or item.memento_rune_type.available(unit, item):
++            action.do(action.AddSkill(unit, self.value))
++
++    def on_remove_item(self, unit, item):
++        action.do(action.RemoveSkill(unit, self.value))
++
++class MementoEnemyCleaveAOE(ItemComponent):
++    nid = 'memento_enemy_cleave_aoe'
++    desc = "Gives Enemy Memento Cleave AOE"
++    tag = 'memento'
++
++    def splash(self, unit, item, position) -> tuple:
++        pos = unit.position
++        x_diff = position[0] - pos[0]
++        y_diff = position[1] - pos[1]
++        if x_diff in (1, -1):
++            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
++        elif y_diff in (1, -1):
++            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
++        else:
++            splash_positions = set()
++        
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        splash = [game.board.get_unit(pos) for pos in splash_positions]
++        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
++        main_target = position if game.board.get_unit(position) else None
++        return main_target, splash
++
++    def splash_positions(self, unit, item, position) -> set:
++        pos = unit.position
++        x_diff = position[0] - pos[0]
++        y_diff = position[1] - pos[1]
++        if x_diff in (1, -1):
++            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
++        elif y_diff in (1, -1):
++            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
++        else:
++            splash_positions = set()
++        
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        # Doesn't highlight allies positions
++        splash = {pos for pos in splash_positions if not game.board.get_unit(pos) or skill_system.check_enemy(unit, game.board.get_unit(pos))}
++        return splash
++
++class MementoEnemyPierceAOE(ItemComponent):
++    nid = 'memento_enemy_pierce_aoe'
++    desc = "Gives Enemy Memento Pierce AOE"
++    tag = 'memento'
++
++    def splash(self, unit, item, position) -> tuple:
++        pos = unit.position
++        x_diff = position[0] - pos[0]
++        y_diff = position[1] - pos[1]
++        splash_positions = {(position[0] + x_diff, position[1] + y_diff)}
++
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        splash = [game.board.get_unit(pos) for pos in splash_positions]
++        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
++        main_target = position if game.board.get_unit(position) else None
++        return main_target, splash
++
++    def splash_positions(self, unit, item, position) -> set:
++        pos = unit.position
++        x_diff = position[0] - pos[0]
++        y_diff = position[1] - pos[1]
++        splash_positions = {(position[0] + x_diff, position[1] + y_diff)}
++
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        # Doesn't highlight allies positions
++        splash = {pos for pos in splash_positions if not game.board.get_unit(pos) or skill_system.check_enemy(unit, game.board.get_unit(pos))}
++        return splash
++
++class MementoBurstAOE(ItemComponent):
++    nid = 'memento_burst_aoe'
++    desc = "Gives Memento Burst AOE"
++    tag = 'memento'
++
++    expose = Type.Int
++    value = 1
++
++    def splash(self, unit, item, position) -> tuple:
++        pos = unit.position
++        x_diff = position[0] - pos[0]
++        y_diff = position[1] - pos[1]
++        if x_diff in (1, -1):
++            splash_positions = {(position[0], position[1] - 1), (position[0], position[1] + 1)}
++        elif y_diff in (1, -1):
++            splash_positions = {(position[0] - 1, position[1]), (position[0] + 1, position[1])}
++        else:
++            splash_positions = set()
++        
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        splash = [game.board.get_unit(pos) for pos in splash_positions]
++        splash = [s.position for s in splash if s and skill_system.check_enemy(unit, s)]
++        main_target = position if game.board.get_unit(position) else None
++        return main_target, splash
++
++    def splash_positions(self, unit, item, position) -> set:
++        unit_pos = unit.position
++        splash_positions = {
++            (unit_pos[0], unit_pos[1] - 1),
++            (unit_pos[0], unit_pos[1] + 1),
++            (unit_pos[0] - 1, unit_pos[1]),
++            (unit_pos[0] + 1, unit_pos[1])
++        }
++        
++        splash_positions = {pos for pos in splash_positions if game.tilemap.check_bounds(pos)}
++        return splash_positions
++
++class MementoPull(ItemComponent):
++    nid = 'memento_pull'
++    desc = "Item moves target toward user on hit, and if it cannot, applies this status instead"
++    tag = 'memento'
++
++    expose = Type.Skill
++
++    def _pull(self, user, target, magnitude: int) -> tuple:
++        offset_x = utils.clamp(target.position[0] - user.position[0], -1, 1)
++        offset_y = utils.clamp(target.position[1] - user.position[1], -1, 1)
++        new_position_target = (target.position[0] - offset_x * magnitude,
++                               target.position[1] - offset_y * magnitude)
++
++        mcost_target = game.movement.get_mcost(target, new_position_target)
++
++        if game.tilemap.check_bounds(new_position_target) and \
++                not game.board.get_unit(new_position_target) and \
++                mcost_target <= equations.parser.movement(target):
++            return new_position_target
++        return None
++
++    def end_combat(self, playback, unit, item, target, mode):
++        if not skill_system.ignore_forced_movement(target):
++            new_position_target = self._pull(unit, target, 1)
++            if new_position_target:
++                action.do(action.ForcedMovement(target, new_position_target))
++                playback.append(('shove_hit', unit, item, target))
++            else:  # Immobilize Status
++                action.do(action.AddSkill(target, self.value, unit))
+diff --git a/app/engine/item_components/weapon_components.py b/app/engine/item_components/weapon_components.py
+index e01343bd..1d2ef9a3 100644
+--- a/app/engine/item_components/weapon_components.py
++++ b/app/engine/item_components/weapon_components.py
+@@ -19,8 +19,11 @@ class WeaponType(ItemComponent):
+ 
+     def available(self, unit, item) -> bool:
+         klass = DB.classes.get(unit.klass)
+-        klass_usable = klass.wexp_gain.get(self.value).usable
+-        return unit.wexp[self.value] > 0 and klass_usable
++        wexp_gain = klass.wexp_gain.get(self.value)
++        if wexp_gain:
++            klass_usable = wexp_gain.usable
++            return unit.wexp[self.value] > 0 and klass_usable
++        return False
+ 
+ class WeaponRank(ItemComponent):
+     nid = 'weapon_rank'
+diff --git a/app/engine/item_funcs.py b/app/engine/item_funcs.py
+index c6f6ac5d..b5b4553d 100644
+--- a/app/engine/item_funcs.py
++++ b/app/engine/item_funcs.py
+@@ -90,6 +90,10 @@ def create_item(unit, item_nid, droppable=False):
+         for subitem_nid in item.sequence_item.value:
+             create_subitem(subitem_nid)
+ 
++    elif item.memento_staff:
++        for subitem_nid in item.memento_staff.value:
++            create_subitem(subitem_nid)
++
+     return item
+ 
+ def create_items(unit, item_nid_list: list) -> list:
+diff --git a/app/engine/level_cursor.py b/app/engine/level_cursor.py
+index c7e94aac..90ec20c5 100644
+--- a/app/engine/level_cursor.py
++++ b/app/engine/level_cursor.py
+@@ -1,8 +1,9 @@
++import math
+ from typing import Tuple
+ 
+-from app.constants import TILEHEIGHT, TILEWIDTH
++from app.constants import TILEHEIGHT, TILEWIDTH, STATWIDTH
+ from app.counters import generic3counter
+-from app.engine import engine, target_system
++from app.engine import engine, target_system, image_mods, skill_system
+ from app.engine.cursor import BaseCursor
+ from app.engine.game_state import GameState
+ from app.engine.input_manager import INPUT
+@@ -68,10 +69,6 @@ class LevelCursor(BaseCursor):
+         else:
+             self._transition_speed = 1
+ 
+-    def set_pos(self, pos):
+-        super().set_pos(pos)
+-        self.game.ui_view.remove_unit_display()
+-
+     def _get_path(self) -> list:
+         if not self._last_valid_position:
+             self.path.clear()
+@@ -87,7 +84,7 @@ class LevelCursor(BaseCursor):
+                 if target_system.check_path(self.cur_unit, self.path):
+                     return self.path
+ 
+-        self.path = target_system.get_path(self.cur_unit, self._last_valid_position)
++        self.path = target_system.get_path(self.cur_unit, self._last_valid_position, use_limit=True)
+         return self.path
+ 
+     def move(self, dx, dy, mouse=False, sound=True):
+@@ -100,10 +97,6 @@ class LevelCursor(BaseCursor):
+             self.path = self._get_path()
+             self.construct_arrows(self.path[::-1])
+ 
+-        # Remove unit info display
+-        if dx != 0 or dy != 0:
+-            self.game.ui_view.remove_unit_display()
+-
+     def autocursor(self, immediate=False):
+         player_units = [unit for unit in self.game.units if unit.team == 'player' and unit.position]
+         lord_units = [unit for unit in player_units if 'Lord' in unit.tags]
+@@ -135,23 +128,23 @@ class LevelCursor(BaseCursor):
+             if idx == 0:  # Start of path
+                 direction = (path[idx + 1][0] - path[idx][0], path[idx + 1][1] - path[idx][1])
+                 if direction == (1, 0):  # Right
+-                    self.arrows.append(Arrow(0, 0, path[idx]))
++                    self.arrows.append(Arrow(0, 0, path[idx], idx))
+                 elif direction == (-1, 0):  # Left
+-                    self.arrows.append(Arrow(1, 1, path[idx]))
++                    self.arrows.append(Arrow(1, 1, path[idx], idx))
+                 elif direction == (0, -1):  # Up
+-                    self.arrows.append(Arrow(0, 1, path[idx]))
++                    self.arrows.append(Arrow(0, 1, path[idx], idx))
+                 elif direction == (0, 1):  # Down
+-                    self.arrows.append(Arrow(1, 0, path[idx]))
++                    self.arrows.append(Arrow(1, 0, path[idx], idx))
+             elif idx == len(path) - 1:  # End of path
+                 direction = (path[idx][0] - path[idx - 1][0], path[idx][1] - path[idx - 1][1])
+                 if direction == (1, 0):  # Right
+-                    self.arrows.append(Arrow(6, 0, path[idx]))
++                    self.arrows.append(Arrow(6, 0, path[idx], idx))
+                 elif direction == (-1, 0):  # Left
+-                    self.arrows.append(Arrow(7, 1, path[idx]))
++                    self.arrows.append(Arrow(7, 1, path[idx], idx))
+                 elif direction == (0, -1):  # Up
+-                    self.arrows.append(Arrow(6, 1, path[idx]))
++                    self.arrows.append(Arrow(6, 1, path[idx], idx))
+                 elif direction == (0, 1):  # Down
+-                    self.arrows.append(Arrow(7, 0, path[idx]))
++                    self.arrows.append(Arrow(7, 0, path[idx], idx))
+             else:  # Neither beginning nor end of path
+                 next_p = path[idx + 1]
+                 current_p = path[idx]
+@@ -159,19 +152,19 @@ class LevelCursor(BaseCursor):
+                 direction = (next_p[0] - prev_p[0], next_p[1] - prev_p[1])
+                 modifier = (current_p[0] - prev_p[0], current_p[1] - prev_p[1])
+                 if direction == (2, 0) or direction == (-2, 0):  # Right or Left
+-                    self.arrows.append(Arrow(3, 0, path[idx]))
++                    self.arrows.append(Arrow(3, 0, path[idx], idx))
+                 elif direction == (0, 2) or direction == (0, -2):  # Up or Down
+-                    self.arrows.append(Arrow(2, 0, path[idx]))
++                    self.arrows.append(Arrow(2, 0, path[idx], idx))
+                 elif direction == (1, -1) or direction == (-1, 1):  # Topleft or Bottomright
+                     if modifier == (0, -1) or modifier == (-1, 0):
+-                        self.arrows.append(Arrow(4, 0, path[idx]))
++                        self.arrows.append(Arrow(4, 0, path[idx], idx))
+                     elif modifier == (1, 0) or modifier == (0, 1):
+-                        self.arrows.append(Arrow(5, 1, path[idx]))
++                        self.arrows.append(Arrow(5, 1, path[idx], idx))
+                 elif direction == (1, 1) or direction == (-1, -1):  # Topright or Bottomleft
+                     if modifier == (0, -1) or modifier == (1, 0):
+-                        self.arrows.append(Arrow(5, 0, path[idx]))
++                        self.arrows.append(Arrow(5, 0, path[idx], idx))
+                     else:
+-                        self.arrows.append(Arrow(4, 1, path[idx]))
++                        self.arrows.append(Arrow(4, 1, path[idx], idx))
+ 
+     def remove_arrows(self):
+         self._last_valid_position = None
+@@ -233,7 +226,7 @@ class LevelCursor(BaseCursor):
+             mouse_pos = INPUT.get_real_mouse_position()
+             if mouse_pos:
+                 from_mouse = True
+-                new_pos = mouse_pos[0] // TILEWIDTH, mouse_pos[1] // TILEHEIGHT
++                new_pos = (mouse_pos[0] - STATWIDTH) // TILEWIDTH, mouse_pos[1] // TILEHEIGHT
+                 new_pos = int(new_pos[0] + self.game.camera.get_x()), int(new_pos[1] + self.game.camera.get_y())
+                 dpos = new_pos[0] - self.position[0], new_pos[1] - self.position[1]
+                 dx = dpos[0]
+@@ -284,17 +277,50 @@ class LevelCursor(BaseCursor):
+         if self._display_arrows:
+             for arrow in self.arrows:
+                 surf = arrow.draw(surf, cull_rect)
++
++            draw_unit_sprite = False
++            if self.cur_unit:    
++                if self.path and len(self.path) > 1 and \
++                        self.position == self.path[0]:
++                    draw_unit_sprite = True
++                    x_offset = self.path[0][0] - self.path[1][0]
++                    y_offset = self.path[0][1] - self.path[1][1]
++                elif self.position in set(skill_system.witch_warp(self.cur_unit)):
++                    draw_unit_sprite = True
++                    x_offset, y_offset = 0, 0
++
++            if draw_unit_sprite:
++                # Draw unit's sprite
++                if x_offset > 0:
++                    state = 'right'
++                elif x_offset < 0:
++                    state = 'left'
++                elif y_offset < 0:
++                    state = 'up'
++                else:
++                    state = 'down'
++                active_sprite = self.cur_unit.sprite.create_image(state)
++                active_sprite = image_mods.make_translucent(active_sprite.convert_alpha(), .5)
++                x_pos = self.position[0] * TILEWIDTH - cull_rect[0] - max(0, (active_sprite.get_width() - 16)//2)
++                y_pos = self.position[1] * TILEHEIGHT - cull_rect[1] - 24
++                surf.blit(active_sprite, (x_pos, y_pos))
+         return surf
+ 
+ class Arrow(object):
+     sprite = SPRITES.get('movement_arrows')
++    sprite = image_mods.make_translucent(sprite, 0.1)
+ 
+-    def __init__(self, x, y, position):
++    def __init__(self, x, y, position, idx):
+         self.image = engine.subsurface(self.sprite, (x * TILEWIDTH, y * TILEHEIGHT, TILEWIDTH, TILEHEIGHT))
+         self.position = position
++        self.idx = idx
+ 
+     def draw(self, surf, cull_rect):
++        t = math.sin(math.radians((engine.get_time()//5 - self.idx * 6) % 180))
++        new_color = image_mods.blend_colors((200, 40, 0), (0, 0, 0), t)
++
+         x, y = self.position
+         topleft = x * TILEWIDTH - cull_rect[0], y * TILEHEIGHT - cull_rect[1]
+-        surf.blit(self.image, topleft)
++        image = image_mods.change_color(self.image, new_color)
++        surf.blit(image, topleft)
+         return surf
+diff --git a/app/engine/level_up.py b/app/engine/level_up.py
+index 9643f0ef..918a58ce 100644
+--- a/app/engine/level_up.py
++++ b/app/engine/level_up.py
+@@ -104,7 +104,7 @@ class ExpState(State):
+             self.exp_bar = ExpBar(self.old_exp, center=not self.combat_object)
+             self.start_time = current_time
+ 
+-            if self.mana_to_gain or (self.unit.get_max_mana() > 0 and self.unit.get_mana() != self.unit.get_max_mana()):
++            if self.mana_to_gain:
+                 self.mana_bar = ManaBar(self.old_mana, center=not self.combat_object)
+                 self.mana_bar.bar_max = self.unit.get_max_mana()
+ 
+diff --git a/app/engine/map_view.py b/app/engine/map_view.py
+index 10f08199..db91f656 100644
+--- a/app/engine/map_view.py
++++ b/app/engine/map_view.py
+@@ -1,14 +1,15 @@
+-from app.constants import TILEWIDTH, TILEHEIGHT, WINWIDTH, WINHEIGHT
++from app.constants import TILEWIDTH, TILEHEIGHT, WINWIDTH, WINHEIGHT, MAPWIDTH
+ 
+ from app.engine import engine
++from app.engine.value_noise import ValueNoise
+ from app.engine.game_state import game
+ 
+ class MapView():
+     def __init__(self):
+-        self._unit_surf = engine.create_surface((WINWIDTH, WINHEIGHT), transparent=True)
++        self._unit_surf = engine.create_surface((MAPWIDTH, WINHEIGHT), transparent=True)
++        # self._value_noise = ValueNoise()
+ 
+     def draw_units(self, surf, cull_rect, subsurface_rect=None):
+-        # Surf is always 240x160 WxH
+         unit_surf = engine.copy_surface(self._unit_surf)
+ 
+         # Update all units except the cur unit
+@@ -68,6 +69,11 @@ class MapView():
+         surf = game.boundary.draw_fog_of_war(surf, full_size, cull_rect)
+         surf = game.highlight.draw(surf, cull_rect)
+ 
++        game.tilemap.animations = [anim for anim in game.tilemap.animations if not anim.update()]
++        for anim in game.tilemap.animations:
++            # anim.draw(surf, offset=(-game.camera.get_x(), -game.camera.get_y()))
++            anim.draw(surf, offset=(-cull_rect[0], -cull_rect[1]))
++
+         if subsurface_cull:  # Forced smaller cull rect from animation combat black background
+             # Make sure it has a width
+             # Make the cull rect even smaller
+@@ -79,8 +85,9 @@ class MapView():
+         else:
+             self.draw_units(surf, cull_rect)
+ 
+-        surf = game.cursor.draw(surf, cull_rect)
++        # surf = self._value_noise.draw(surf)
+ 
++        surf = game.cursor.draw(surf, cull_rect)
+ 
+         for weather in game.tilemap.weather:
+             weather.update()
+diff --git a/app/engine/memento_dialog.py b/app/engine/memento_dialog.py
+new file mode 100644
+index 00000000..1c11bb4b
+--- /dev/null
++++ b/app/engine/memento_dialog.py
+@@ -0,0 +1,323 @@
++import re
++
++from app.utilities import utils
++from app.constants import WINWIDTH, WINHEIGHT
++from app.engine.fonts import FONT
++from app.engine.sprites import SPRITES
++from app.engine import text_funcs, engine, image_mods, dialog
++from app.engine import config as cf
++
++class MementoDialogBackground():
++    background = SPRITES.get('memento_dialog_background')
++    transition_in_speed = 200  # 12 frames
++    transition_out_speed = 166  # 10 frames
++
++    def __init__(self):
++        # off, transition_in, normal, transition_out
++        self.state = 'off'
++        self.transition_progress = 0
++        self.last_update = engine.get_time()
++        self.height = self.background.get_height()
++        self.position = (0, WINHEIGHT - self.height)
++
++    def update(self) -> bool:
++        # Returns true if in normal state
++        current_time = engine.get_time()
++
++        if self.state == 'transition_in':
++            perc = (current_time - self.last_update) / self.transition_in_speed
++            self.transition_progress = utils.clamp(perc, 0, 1)
++            if self.transition_progress == 1:
++                self.state = 'normal'
++
++        elif self.state == 'transition_out':
++            perc = (current_time - self.last_update) / self.transition_out_speed
++            self.transition_progress = utils.clamp(perc, 0, 1)
++            if self.transition_progress == 1:
++                self.state = 'off'
++
++        return self.state == 'normal'
++
++    def start(self):
++        self.state = 'transition_in'
++        self.transition_progress = 0
++        self.last_update = engine.get_time()
++
++    def end(self):
++        self.state = 'transition_out'
++        self.transition_progress = 0
++        self.last_update = engine.get_time()
++
++    def ready(self):
++        return self.state == 'normal'
++
++    def draw(self, surf):
++        if self.state == 'transition_in':
++            new_width = int(max(1, self.background.get_width() * self.transition_progress))
++            new_height = max(1, self.background.get_height() - 10 + int(10*self.transition_progress))
++            bg = engine.transform_scale(self.background, (new_width, new_height))
++            bg = image_mods.make_translucent(bg, (1 - self.transition_progress))
++            surf.blit(bg, (self.position[0] + self.background.get_width()//2 - new_width//2, self.position[1] + self.height//2 - bg.get_height()//2))
++        elif self.state == 'transition_out':
++            new_width = max(1, self.background.get_width() - 10 - int(10*self.transition_progress))
++            new_height = max(1, self.background.get_height() - 10 - int(10*self.transition_progress))
++            bg = engine.transform_scale(self.background, (new_width, new_height))
++            bg = image_mods.make_translucent(bg, self.transition_progress)
++            surf.blit(bg, (self.position[0], self.position[1] + self.height//2 - bg.get_height()//2))
++        elif self.state == 'normal':
++            surf.blit(self.background, self.position)
++
++class MementoDialog(dialog.Dialog):
++    solo_flag = True
++    cursor = SPRITES.get('waiting_cursor')
++    name_tag = SPRITES.get('memento_nametag')
++    draw_cursor_flag = False
++    pause_before_wait_time = 150  # 9 frames
++    pause_time = 150  # 9 frames
++    text_width = WINWIDTH - 40
++    text_height = 64
++
++    def __init__(self, text, background, portrait=None):
++        self.plain_text = text
++        self.background = background
++        self.portrait = portrait
++        self.speaker = self.portrait.name
++        self.font_type = 'convo'
++        self.font_color = 'black'
++        self.font = FONT[self.font_type + '-' + self.font_color]
++
++        # States: 
++        # transition_in -- waiting for the dialog box to appear
++        # write -- actually adding text to the screen, one character at a time
++        # pause -- occasionally pauses for a period
++        # pause_before_wait -- will pause for some time between write and wait states (to account for player mashing A)
++        # wait -- Done writing, now waiting for the player to press A
++        # done -- No more dialog to show, waiting for the event to clean me up
++        # transition_out -- waiting for the dialog box to disappear
++        self.state = 'transition_in'
++
++        self.no_wait: bool = False  # Whether to wait for the player to press
++        self.text_commands = self.format_text(text)
++        self.text_blocks = self.get_text_blocks()
++        self.current_block = 0
++
++        # Size & Position
++        self.num_lines = self.determine_num_lines(self.current_block)
++
++        # For drawing
++        self.text_index = 0
++        self.text_lines = []
++        self.total_num_updates = 0
++
++        # For state transitions
++        self.last_update = engine.get_time()
++
++        # For sound
++        self.last_sound_update = 0
++
++    def get_text_blocks(self) -> list:
++        blocks = []
++        current_block = []
++        for command in self.text_commands:
++            if command in ('{w}', '{wait}', '{clear}'):
++                blocks.append(current_block)
++                current_block = []
++            else:
++                current_block.append(command)
++        return blocks
++
++    def line_wrap(self, line: str) -> list:
++        max_line_width = self.text_width
++        return text_funcs.line_wrap(self.font, line, max_line_width)
++
++    def determine_num_lines(self, current_block: int) -> int:
++        # Figure out how many lines we need to display this
++        block: list = self.text_blocks[current_block]
++        lines = []
++        current_line = ''
++        for command in block:
++            if command in ('{br}', '{break}'):
++                new_lines = self.line_wrap(current_line)
++                lines += new_lines
++                current_line = ''
++            elif command.startswith('{'):
++                pass
++            else:
++                current_line += command
++        new_lines = self.line_wrap(current_line)
++        lines += new_lines
++        num_lines = len(lines)
++        return num_lines
++
++    def _next_line(self):
++        self.text_lines.append([])
++
++    def _add_letter(self, letter):
++        self.text_lines[-1].append(letter)
++
++    def _next_char(self, sound=True):  # Add the next character to the text_lines list
++        if self.text_index >= len(self.text_commands):
++            self.pause_before_wait()
++            return
++        command = self.text_commands[self.text_index]
++        if command == '{br}' or command == '{break}':
++            self._next_line()
++        elif command == '{w}' or command == '{wait}':
++            self.pause_before_wait()
++        elif command == '{clear}':
++            self._next_block()
++        elif command == ' ':  # Check to see if we should move to next line
++            current_line = ''.join(self.text_lines[-1])
++            # Remove any commands from line
++            current_line = re.sub(r'\{[^}]*\}', '', current_line)
++            next_word = self._get_next_word(self.text_index)
++            if self.font.width(current_line + ' ' + next_word) > self.text_width:
++                self._next_line()
++            else:
++                self._add_letter(' ')
++        elif command in self.aesthetic_commands:
++            self._add_letter(command)
++        elif command in ('.', ',', ';', '!', '?'):
++            self._add_letter(command)
++            self.pause()
++        else:
++            self._add_letter(command)
++        self.text_index += 1
++
++    def _get_next_word(self, text_index):
++        word = ''
++        for letter in self.text_commands[self.text_index + 1:]:
++            if letter == ' ':
++                break
++            elif len(letter) > 1:  # Command
++                if letter in self.aesthetic_commands:
++                    continue
++                else:
++                    break
++            else:
++                word += letter
++        return word
++
++    def _next_block(self):
++        self.text_lines.clear()
++        self._next_line()
++        self.current_block += 1
++        self.num_lines = self.determine_num_lines(self.current_block)
++
++    def is_complete(self):
++        """
++        Should no longer be drawn
++        """
++        return self.state == 'transition_out'
++
++    def is_done(self):
++        """
++        Can move onto processing other commands
++        """
++        return self.state == 'done'
++
++    def is_done_or_wait(self):
++        return self.state in ('done', 'wait')
++
++    def pause(self):
++        self.state = 'pause'
++        self.last_update = engine.get_time()
++
++    def pause_before_wait(self):
++        self.state = 'pause_before_wait'
++        self.last_update = engine.get_time()
++
++    def hurry_up(self):
++        if self.state == 'write':
++            while self.state == 'write':
++                self._next_char()
++                # Skip regular pauses
++                if self.state == 'pause':
++                    self.state = 'write'
++        elif self.state == 'wait':
++            if self.text_index >= len(self.text_commands):
++                self.state = 'done'
++            else:
++                self._next_block()
++                self.state = 'write'
++
++    def update(self):
++        current_time = engine.get_time()
++
++        if self.state == 'transition_in':
++            if self.background.ready():
++                self._next_line()
++                self.state = 'write'
++        elif self.state == 'transition_out':
++            self.background.update()
++        elif self.state == 'write':
++            if cf.SETTINGS['text_speed'] > 0:
++                num_updates = engine.get_delta() / float(cf.SETTINGS['text_speed'])
++                self.total_num_updates += num_updates
++                while self.total_num_updates >= 1 and self.state == 'write':
++                    self.total_num_updates -= 1
++                    self._next_char()
++                    if self.state != 'write':
++                        self.total_num_updates = 0
++            else:
++                while self.state == 'write':
++                    self._next_char()
++                    # Skip regular pauses
++                    if self.state == 'pause':
++                        self.state = 'write'
++        elif self.state == 'pause_before_wait':
++            if current_time - self.last_update > self.pause_before_wait_time:
++                if self.no_wait:
++                    self.state = 'done'
++                else:
++                    self.state = 'wait'
++        elif self.state == 'pause':  # Regular pause for periods
++            if current_time - self.last_update > self.pause_time:
++                self.state = 'write'
++
++    def draw_text(self, surf):
++        text_surf = engine.create_surface((self.text_width, self.text_height), transparent=True)
++
++        current_color = self.font_color
++
++        for idx, line in enumerate(self.text_lines):
++            x_pos = 0
++            y_pos = 16 * idx + (8 * (4 - self.num_lines))
++
++            line_chunks, current_color = self.chunkify(line, current_color)
++            for chunk in line_chunks:
++                text, color = chunk
++                font = FONT[self.font_type + '-' + color]
++                width = font.width(text)
++                font.blit(text, text_surf, (x_pos, y_pos))
++                x_pos += width
++
++        surf.blit(text_surf, (20, WINHEIGHT - 64 - 12))
++
++    def draw_nametag(self, surf, name):
++        if self.portrait:
++            position = self.portrait.position
++            x_pos = position[0] - 4
++            y_pos = position[1] + 118
++            if x_pos < 0:
++                x_pos = position[0] + 16
++        else:
++            x_pos, y_pos = (8, 8)
++        name_tag_surf = self.name_tag.copy()
++        FONT['text-white'].blit_center(name, name_tag_surf, (name_tag_surf.get_width()//2, name_tag_surf.get_height()//2 - self.font.height//2))
++        surf.blit(name_tag_surf, (x_pos, y_pos))
++        return surf
++
++    def draw(self, surf):
++        if self.state not in ('transition_in', 'transition_out'):
++            # Draw nametag
++            if self.portrait:
++                self.draw_nametag(surf, self.speaker)
++            # Draw text
++            self.draw_text(surf)
++
++            if self.state == 'wait' and self.draw_cursor_flag:
++                cursor_pos = WINWIDTH//2 - self.cursor.get_width()//2, WINHEIGHT - 24
++                surf.blit(self.cursor, cursor_pos)
++
++        return surf
+diff --git a/app/engine/menu_options.py b/app/engine/menu_options.py
+index e59e5685..7ce6c009 100644
+--- a/app/engine/menu_options.py
++++ b/app/engine/menu_options.py
+@@ -4,7 +4,7 @@ from app.data.database import DB
+ 
+ from app.engine.sprites import SPRITES
+ from app.engine.fonts import FONT
+-from app.engine import engine, image_mods, icons, help_menu, text_funcs, item_system, item_funcs
++from app.engine import engine, image_mods, icons, help_menu, text_funcs, item_system, item_funcs, skill_system
+ from app.engine.game_state import game
+ 
+ class EmptyOption():
+@@ -249,6 +249,82 @@ class ItemOption(BasicOption):
+         left = x + 99
+         FONT[uses_font].blit_right(uses_string, surf, (left, y))
+ 
++class MementoAccessoryItemOption(ItemOption):
++    def get_color(self):
++        owner = game.get_unit(self.item.owner_nid)
++        main_font = 'runes-grey'
++        uses_font = 'runes-grey'
++        if self.ignore:
++            pass
++        elif self.color:
++            main_font = self.color
++            if owner and not item_funcs.available(owner, self.item):
++                pass
++            else:
++                uses_font = 'runes-blue'
++        elif self.item.droppable:
++            main_font = 'runes-green'
++            uses_font = 'runes-green'
++        elif not owner or (not self.item.memento_rune_type or self.item.memento_rune_type.available(owner, self.item)):
++            main_font = 'runes-white'
++            uses_font = 'runes-blue'
++        return main_font, uses_font
++
++class SkillOption(ItemOption):
++    """
++    Skill Objects, not Skill Prefabs
++    """
++    def _is_skill_form(self, owner) -> bool:
++        return not item_funcs.available(owner, self.item) and self.item.memento_skill_on_hold
++
++    def __init__(self, idx, skill):
++        self.idx = idx
++        self.skill = skill
++        self.help_box = None
++        self.ignore = False
++
++    def get(self):
++        return self.skill
++
++    def set_text(self, text):
++        pass
++
++    def set_skill(self, skill):
++        self.skill = skill
++
++    def width(self):
++        return 104
++
++    def height(self):
++        return 16
++
++    def get_color(self):
++        owner = game.get_unit(self.skill.owner_nid)
++        main_font = 'runes-grey'
++        uses_font = 'runes-grey'
++        if self.ignore:
++            pass
++        elif not owner or (not self.skill.memento_rune_type or self.skill.memento_rune_type.available(owner, self.skill)):
++            main_font = 'runes-white'
++            uses_font = 'runes-blue'
++        return main_font, uses_font
++
++    def get_help_box(self):
++        return help_menu.HelpDialog(self.skill.desc)
++
++    def draw(self, surf, x, y):
++        icon = icons.get_icon(self.skill)
++        if icon:
++            surf.blit(icon, (x + 2, y))
++        main_font, uses_font = self.get_color()
++        FONT[main_font].blit(self.skill.name, surf, (x + 20, y))
++        uses_string = '--'
++        text = skill_system.get_text(self.skill)
++        if text:
++            uses_string = text
++        left = x + 99
++        FONT[uses_font].blit_right(uses_string, surf, (left, y))
++
+ class ConvoyItemOption(ItemOption):
+     def __init__(self, idx, item, owner):
+         super().__init__(idx, item)
+@@ -272,7 +348,7 @@ class ConvoyItemOption(ItemOption):
+ 
+ class FullItemOption(ItemOption):
+     def width(self):
+-        return 120
++        return 108
+ 
+     def draw(self, surf, x, y):
+         icon = icons.get_icon(self.item)
+@@ -295,9 +371,9 @@ class FullItemOption(ItemOption):
+         elif self.item.data.get('cooldown') is not None:
+             uses_string_a = str(self.item.data['cooldown'])
+             uses_string_b = str(self.item.data['starting_cooldown'])
+-        FONT[uses_font].blit_right(uses_string_a, surf, (x + 96, y))
+-        FONT['text-white'].blit("/", surf, (x + 98, y))
+-        FONT[uses_font].blit_right(uses_string_b, surf, (x + 120, y))
++        FONT[uses_font].blit_right(uses_string_a, surf, (x + 84, y))
++        FONT['text-white'].blit("/", surf, (x + 86, y))
++        FONT[uses_font].blit_right(uses_string_b, surf, (x + 108, y))
+ 
+ class ValueItemOption(ItemOption):
+     def __init__(self, idx, item, disp_value):
+diff --git a/app/engine/menus.py b/app/engine/menus.py
+index 17dbb458..3036165b 100644
+--- a/app/engine/menus.py
++++ b/app/engine/menus.py
+@@ -1,6 +1,6 @@
+ import math
+ 
+-from app.constants import TILEX, WINWIDTH, WINHEIGHT
++from app.constants import TILEX, WINWIDTH, WINHEIGHT, STATWIDTH
+ from app.data.database import DB
+ from app.utilities import utils
+ 
+@@ -299,7 +299,7 @@ class Simple():
+     def get_topleft(self):
+         if not self.topleft:
+             if game.cursor.position[0] > TILEX//2 + game.camera.get_x():
+-                return (14, 8)
++                return (STATWIDTH + 14, 8)
+             else:
+                 return (WINWIDTH - self.get_menu_width() - 14, 8)
+         elif self.topleft == 'center':
+diff --git a/app/engine/objects/tilemap.py b/app/engine/objects/tilemap.py
+index 12b4cc3b..5a8f3c5e 100644
+--- a/app/engine/objects/tilemap.py
++++ b/app/engine/objects/tilemap.py
+@@ -5,7 +5,7 @@ from app.utilities.data import Data, Prefab
+ 
+ from app.resources.resources import RESOURCES
+ 
+-from app.engine import engine, image_mods, particles
++from app.engine import engine, image_mods, particles, animations
+ 
+ class LayerObject():
+     transition_speed = 333
+@@ -116,6 +116,7 @@ class TileMapObject(Prefab):
+     def __init__(self):
+         super().__init__()
+         self.weather: List[particles.ParticleSystem] = []
++        self.animations: List[animations.MapAnimation] = []
+         self.width: int = 0
+         self.height: int = 0
+         self.nid: NID = None
+@@ -188,6 +189,7 @@ class TileMapObject(Prefab):
+         self.layers.get('base').visible = True
+ 
+         self.weather = []
++        self.animations = []
+ 
+         return self
+ 
+@@ -236,6 +238,7 @@ class TileMapObject(Prefab):
+         s_dict['nid'] = self.nid
+         s_dict['layers'] = [layer.save() for layer in self.layers]
+         s_dict['weather'] = [weather.save() for weather in self.weather]
++        s_dict['animations'] = [anim.save() for anim in self.animations]
+         return s_dict
+ 
+     @classmethod
+@@ -245,6 +248,19 @@ class TileMapObject(Prefab):
+         self.restore_layers(s_dict['layers'])
+         weather = s_dict.get('weather', [])
+         self.weather = [particles.create_system(nid, self.width, self.height) for nid in weather]
++        # Handle tile animations
++        anims = s_dict.get('animations', [])
++        self.animations = []
++        for anim in anims:
++            new_anim = animations.MapAnimation(
++                RESOURCES.animations.get(anim['nid']), 
++                anim['pos'], 
++                loop=anim['loop'], 
++                hold=anim['hold'], 
++                reverse=anim['reverse'], 
++                speed_adj=anim['speed_adj'])
++            self.animations.append(new_anim)
++
+         return self
+ 
+     def restore_layers(self, layer_list):
+diff --git a/app/engine/objects/unit.py b/app/engine/objects/unit.py
+index fc547149..c4f768d8 100644
+--- a/app/engine/objects/unit.py
++++ b/app/engine/objects/unit.py
+@@ -243,6 +243,13 @@ class UnitObject(Prefab):
+             bonus += item_system.stat_change(self, weapon, stat_nid)
+         return bonus
+ 
++    def stat_contribution(self, stat_nid: str) -> list:
++        contribution = skill_system.stat_change_contribution(self, stat_nid)
++        weapon = self.equipped_weapon
++        if weapon:
++            contribution.update(item_system.stat_change_contribution(self, weapon, stat_nid))
++        return contribution
++
+     def get_stat(self, stat_nid):
+         return self.stats.get(stat_nid, 0) + self.stat_bonus(stat_nid)
+ 
+@@ -334,6 +341,9 @@ class UnitObject(Prefab):
+                     self.equip(item)
+                     _weapon = item
+                     break
++        # Handle memento_staff mechanic
++        if _weapon and _weapon.memento_staff:
++            _weapon = _weapon.memento_staff.get_ward(_weapon)
+         return _weapon
+ 
+     def get_spell(self):
+@@ -496,6 +506,7 @@ class UnitObject(Prefab):
+     def wait(self):
+         game.events.trigger('unit_wait', self, position=self.position)
+         action.do(action.Wait(self))
++        game.stat_screen.reset_surfs()
+         if game.cursor and game.cursor.cur_unit == self:
+             game.cursor.cur_unit = None
+ 
+diff --git a/app/engine/particles.py b/app/engine/particles.py
+index 84f8413d..9c88eeda 100644
+--- a/app/engine/particles.py
++++ b/app/engine/particles.py
+@@ -5,6 +5,7 @@ from app.engine.sprites import SPRITES
+ 
+ from app.engine import engine, image_mods
+ from app.engine.game_state import game
++from app.engine.fog_particles import FogParticleSystem
+ 
+ class ParticleSystem():
+     def __init__(self, nid, particle, abundance, bounds, size, blend=None):
+@@ -64,7 +65,7 @@ class Particle():
+ 
+ class Raindrop(Particle):
+     sprite = SPRITES.get('particle_raindrop')
+-    speed = 2
++    speed = 3
+ 
+     def update(self):
+         self.x += self.speed
+@@ -244,6 +245,9 @@ def create_system(nid, width, height):
+     elif nid == 'dark':
+         creation_bounds = 0, twidth, 0, theight
+         ps = ParticleSystem(nid, DarkMote, .02, creation_bounds, (width, height))
++    elif nid == 'fog':
++        creation_bounds = -16, 0, -twidth//2, theight
++        ps = FogParticleSystem(nid, .2, creation_bounds, (width, height))
+     elif nid == 'fire':
+         creation_bounds = 0, WINWIDTH + 64, WINHEIGHT, WINHEIGHT + 16
+         blend = SPRITES.get('particle_bg_fire')
+diff --git a/app/engine/promotion.py b/app/engine/promotion.py
+index 5154af96..d651e06b 100644
+--- a/app/engine/promotion.py
++++ b/app/engine/promotion.py
+@@ -50,7 +50,7 @@ class PromotionChoiceState(State):
+         self.animations = []
+         self.weapon_icons = []
+         for option in self.class_options:
+-            anim = battle_animation.get_battle_anim(self.unit, None, klass=option, default_variant=True)
++            anim = battle_animation.get_battle_anim(self.unit, None, klass=option)
+             if anim:
+                 anim.pair(self, None, True, 0)
+             self.animations.append(anim)
+@@ -239,7 +239,7 @@ class PromotionState(State, MockCombat):
+         self.right_battle_anim = battle_animation.get_battle_anim(self.unit, None)
+         # New Left Animation
+         next_class = game.memory['next_class']
+-        self.left_battle_anim = battle_animation.get_battle_anim(self.unit, None, klass=next_class, default_variant=True)
++        self.left_battle_anim = battle_animation.get_battle_anim(self.unit, None, klass=next_class)
+         self.current_battle_anim = self.right_battle_anim
+ 
+         platform_type = 'Floor'
+diff --git a/app/engine/skill_components/aesthetic_components.py b/app/engine/skill_components/aesthetic_components.py
+index 4093f90d..85896362 100644
+--- a/app/engine/skill_components/aesthetic_components.py
++++ b/app/engine/skill_components/aesthetic_components.py
+@@ -104,25 +104,3 @@ class AlternateBattleAnim(SkillComponent):
+         marks = [mark[0] for mark in playback]
+         if 'mark_hit' in marks or 'mark_crit' in marks:
+             playback.append(('alternate_battle_pose', self.value))
+-
+-class ChangeVariant(SkillComponent):
+-    nid = 'change_variant'
+-    desc = "Change the unit's variant"
+-    tag = "aesthetic"
+-
+-    expose = Type.String
+-    value = ''
+-
+-    def change_variant(self, unit):
+-        return self.value
+-        
+-class ChangeAnimation(SkillComponent):
+-    nid = 'change_animation'
+-    desc = "Change the unit's animation"
+-    tag = "aesthetic"
+-
+-    expose = Type.String
+-    value = ''
+-
+-    def change_animation(self, unit):
+-        return self.value
+\ No newline at end of file
+diff --git a/app/engine/skill_components/combat2_components.py b/app/engine/skill_components/combat2_components.py
+index 799756a3..8a6043cc 100644
+--- a/app/engine/skill_components/combat2_components.py
++++ b/app/engine/skill_components/combat2_components.py
+@@ -53,6 +53,26 @@ class LiveToServe(SkillComponent):
+             actions.append(action.ChangeHP(unit, amount))
+             actions.append(action.TriggerCharge(unit, self.skill))
+ 
++class Lifetaker(SkillComponent):
++    nid = 'lifetaker'
++    desc = r"Heal % of total HP after a kill"
++    tag = 'combat2'
++
++    expose = Type.Float
++    value = 0.5
++
++    def end_combat(self, playback, unit, item, target, mode):
++        playbacks = [p for p in playback if p[0] in ('mark_hit', 'mark_crit') and p[1] is unit and p[2] and p[2] is not unit and p[2].is_dying]
++        unique_units = {p[2] for p in playbacks}
++        num_playbacks = len(unique_units)
++        if num_playbacks > 0:
++            amount = max(2, int(unit.get_max_hp() * self.value * num_playbacks))
++            if amount > 0:
++                true_heal = min(amount, unit.get_max_hp() - unit.get_hp())
++                playback.append(('heal_hit', unit, item, unit, true_heal, true_heal))
++                action.do(action.ChangeHP(unit, amount))
++                action.do(action.TriggerCharge(unit, self.skill))
++
+ class Lifelink(SkillComponent):
+     nid = 'lifelink'
+     desc = "Heals user %% of damage dealt"
+@@ -270,7 +290,7 @@ class Recoil(SkillComponent):
+ 
+ class PostCombatDamage(SkillComponent):
+     nid = 'post_combat_damage'
+-    desc = "Target takes non-lethal flat damage after combat"
++    desc = "Target takes non-lethal damage after combat"
+     tag = 'combat2'
+ 
+     expose = Type.Int
+@@ -283,39 +303,14 @@ class PostCombatDamage(SkillComponent):
+             action.do(action.SetHP(target, max(1, end_health)))
+             action.do(action.TriggerCharge(unit, self.skill))
+ 
+-class PostCombatDamagePercent(SkillComponent):
+-    nid = 'post_combat_damage_percent'
+-    desc = "Target takes non-lethal MaxHP percent damage after combat"
+-    tag = 'combat2'
+-
+-    expose = Type.Float
+-    value = 0.2
+-    author = 'Lord_Tweed'
+-    
+-    def end_combat(self, playback, unit, item, target, mode):
+-        if target and skill_system.check_enemy(unit, target):
+-            end_health = int(target.get_hp() - (target.get_max_hp() * self.value))
+-            action.do(action.SetHP(target, max(1, end_health)))
+-            action.do(action.TriggerCharge(unit, self.skill))
+-
+-class PostCombatSplash(SkillComponent):
+-    nid = 'post_combat_splash'
+-    desc = "Deals flat damage to enemies in a range defined by the PostCombatSplashAOE component"
+-    tag = 'combat2'
+-    paired_with = ('post_combat_splash_aoe', )
+-
+-    expose = Type.Int
+-    value = 0
+-    author = 'Lord_Tweed'
+-
+     def post_combat_damage(self) -> int:
+         return self.value
+ 
+-class PostCombatSplashAOE(SkillComponent):
+-    nid = 'post_combat_splash_aoe'
+-    desc = 'Defines the range for PostCombatSplash damage to hit.'
++class PostCombatDamageAOE(SkillComponent):
++    nid = 'post_combat_damage_aoe'
++    desc = 'Post-Combat damage will also hit other enemies within this AOE range.'
+     tag = 'combat2'
+-    paired_with = ('post_combat_splash', )
++    paired_with = ('post_combat_damage', )
+ 
+     expose = Type.Int
+     value = 0
+@@ -323,7 +318,7 @@ class PostCombatSplashAOE(SkillComponent):
+ 
+     def end_combat(self, playback, unit, item, target, mode):
+         if target and skill_system.check_enemy(unit, target):
+-            r = set(range(self.value+1))
++            r = set(range(self.value))
+             locations = target_system.get_shell({target.position}, r, game.tilemap.width, game.tilemap.height)
+             damage = get_pc_damage(unit, self.skill)
+             if damage > 0:
+diff --git a/app/engine/skill_components/combat_components.py b/app/engine/skill_components/combat_components.py
+index e487b11d..4e38300f 100644
+--- a/app/engine/skill_components/combat_components.py
++++ b/app/engine/skill_components/combat_components.py
+@@ -11,7 +11,7 @@ class StatChange(SkillComponent):
+     expose = (Type.Dict, Type.Stat)
+     value = []
+ 
+-    def stat_change(self, unit):
++    def stat_change(self, unit=None):
+         return {stat[0]: stat[1] for stat in self.value}
+ 
+     def tile_def(self):
+@@ -171,6 +171,21 @@ class DamageMultiplier(SkillComponent):
+     def damage_multiplier(self, unit, item, target, mode, attack_info, base_value):
+         return self.value
+ 
++class DynamicDamageMultiplier(SkillComponent):
++    nid = 'dynamic_damage_multiplier'
++    desc = "Multiplies damage given by a fraction"
++    tag = 'combat'
++
++    expose = Type.String
++
++    def damage_multiplier(self, unit, item, target, mode, attack_info, base_value):
++        from app.engine import evaluate
++        try:
++            return float(evaluate.evaluate(self.value, unit, target, item, mode=mode, skill=self.skill, attack_info=attack_info, base_value=base_value))
++        except Exception:
++            print("Couldn't evaluate %s conditional" % self.value)
++            return 1
++
+ class ResistMultiplier(SkillComponent):
+     nid = 'resist_multiplier'
+     desc = "Multiplies damage taken by a fraction"
+diff --git a/app/engine/skill_components/memento_components.py b/app/engine/skill_components/memento_components.py
+new file mode 100644
+index 00000000..a246fc00
+--- /dev/null
++++ b/app/engine/skill_components/memento_components.py
+@@ -0,0 +1,117 @@
++from app.data.skill_components import SkillComponent
++from app.data.components import Type
++
++from app.utilities import utils
++from app.engine import equations, action, item_funcs, static_random, skill_system, combat_calcs, target_system
++from app.engine.game_state import game
++
++class MementoHitBonus(SkillComponent):
++    nid = 'memento_hit_bonus'
++    desc = "Gives out bonus to hit when another character can attack the same unit"
++    tag = 'memento'
++
++    expose = Type.Int
++    value = 10
++
++    def dynamic_accuracy(self, unit, item, target, mode):
++        if mode == 'attack' and target and target.position:
++            for other_unit in game.get_all_units():
++                if other_unit is unit:
++                    continue
++                if skill_system.check_ally(unit, other_unit):
++                    # Unit and other unit can both attack target
++                    if target.position in target_system.get_attacks(other_unit, force=True):
++                        return self.value
++        return 0
++
++class MementoShove(SkillComponent):
++    nid = 'memento_shove'
++    desc = "All attacks shove target after combat"
++    tag = 'memento'
++
++    def _check_shove(self, unit_to_move, anchor_pos, magnitude):
++        offset_x = utils.clamp(unit_to_move.position[0] - anchor_pos[0], -1, 1)
++        offset_y = utils.clamp(unit_to_move.position[1] - anchor_pos[1], -1, 1)
++        new_position = (unit_to_move.position[0] + offset_x,
++                        unit_to_move.position[1] + offset_y)
++
++        mcost = game.movement.get_mcost(unit_to_move, new_position)
++        if game.tilemap.check_bounds(new_position) and \
++                not game.board.get_unit(new_position) and \
++                mcost < 99:
++            return new_position
++        return False
++
++    def cleanup_combat(self, playback, unit, item, target, mode):
++        marks = [mark[0] for mark in playback if mark[0] in ('mark_hit', 'mark_crit') and mark[1] is unit and mark[2] is target]
++        did_hit = len(marks) > 0
++        if did_hit and not skill_system.ignore_forced_movement(target) and mode != 'splash':
++            new_position = self._check_shove(target, unit.position, 1)
++            if new_position:
++                action.do(action.ForcedMovement(target, new_position))
++                playback.append(('shove_hit', unit, item, target))
++            else:
++                # Do half damage again when you shove into a wall
++                damage = combat_calcs.compute_damage(unit, target, item, target.get_weapon(), mode)
++                damage = damage // 2
++                action.do(action.ChangeHP(target, -damage))
++
++class MementoTempo(SkillComponent):
++    nid = 'memento_tempo'
++    desc = "Gives +4 DEF if attacked last player phase, +4 POW otherwise"
++    tag = 'memento'
++
++    def init(self, skill):
++        self.skill.data['_has_attacked'] = False
++        self.skill.data['_last_turn'] = -1
++
++    def end_combat(self, playback, attacker, main_item, defender, mode):
++        if mode == 'attack' and defender and skill_system.check_enemy(attacker, defender):
++            action.do(action.SetObjData(self.skill, '_has_attacked', True))
++
++    def on_endstep(self, actions, playback, unit):
++        if self.skill.data['_has_attacked']:
++            action.do(action.SetObjData(self.skill, '_last_turn', game.turncount))
++            action.do(action.SetObjData(self.skill, '_has_attacked', False))
++        else:
++            action.do(action.SetObjData(self.skill, '_last_turn', -1))
++            
++    def on_end_chapter(self, unit, skill):
++        action.do(action.SetObjData(self.skill, '_last_turn', -1))
++
++    def stat_change(self, unit) -> dict:
++        if game.turncount > 0:
++            if game.turncount > self.skill.data['_last_turn'] + 1:
++                return {'POW': 4}
++            else:
++                return {'DEF': 4}
++        return {}
++
++class WitchWarp(SkillComponent):
++    nid = 'witch_warp'
++    desc = "Allows unit to witch warp to the given units"
++    tag = 'memento'
++
++    expose = (Type.List, Type.Unit)
++
++    def witch_warp(self, unit) -> list:
++        positions = []
++        for val in self.value:
++            u = game.get_unit(val)
++            if u and u.position:
++                partner_pos = u.position
++            else:
++                continue
++            if partner_pos:
++                positions += target_system.get_adjacent_positions(partner_pos)
++        return positions
++
++class MementoRuneType(SkillComponent):
++    nid = 'memento_rune_type'
++    desc = "Skill has a rune type and can only be used by those with the right affinity"
++    tag = 'memento'
++
++    expose = Type.Affinity  # Nid
++
++    def available(self, unit, skill) -> bool:
++        return self.value in unit.affinity
+diff --git a/app/engine/skill_components/status_components.py b/app/engine/skill_components/status_components.py
+index 06c4524b..d0882816 100644
+--- a/app/engine/skill_components/status_components.py
++++ b/app/engine/skill_components/status_components.py
+@@ -64,6 +64,20 @@ class UpkeepDamage(SkillComponent):
+     def on_upkeep(self, actions, playback, unit):
+         hp_change = -self.value
+         actions.append(action.ChangeHP(unit, hp_change))
++        actions.append(action.TriggerCharge(unit, self.skill))
++
++class EndstepDamage(SkillComponent):
++    nid = 'endstep_damage'
++    desc = "Unit takes damage at endstep"
++    tag = "status"
++
++    expose = Type.Int
++    value = 5
++
++    def on_endstep(self, actions, playback, unit):
++        hp_change = -self.value
++        actions.append(action.ChangeHP(unit, hp_change))
++        actions.append(action.TriggerCharge(unit, self.skill))
+ 
+ class GBAPoison(SkillComponent):
+     nid = 'gba_poison'
+diff --git a/app/engine/stat_screen.py b/app/engine/stat_screen.py
+new file mode 100644
+index 00000000..64b61685
+--- /dev/null
++++ b/app/engine/stat_screen.py
+@@ -0,0 +1,314 @@
++from app.constants import STATWIDTH, WINHEIGHT
++
++from app.data.database import DB
++from app.utilities import utils
++
++from app.engine.fonts import FONT
++from app.engine.sound import SOUNDTHREAD
++from app.engine.sprites import SPRITES
++from app.engine.input_manager import INPUT
++from app.engine.state import MapState
++from app.engine import engine, info_menu, text_funcs, \
++    icons, image_mods, item_funcs, menu_options, help_menu
++from app.engine.game_state import game
++from app.engine.fluid_scroll import FluidScroll
++
++def handle_info():
++    if game.cursor.get_hover():
++        SOUNDTHREAD.play_sfx('Select 1')
++        game.state.change('stat_screen')
++    else:
++        SOUNDTHREAD.play_sfx('Select 3')
++        game.boundary.toggle_all_enemy_attacks()
++
++def build_groove(surf, topleft, width, fill):
++    bg = SPRITES.get('groove_back')
++    start = engine.subsurface(bg, (0, 0, 2, 5))
++    mid = engine.subsurface(bg, (2, 0, 1, 5))
++    end = engine.subsurface(bg, (3, 0, 2, 5))
++    fg = SPRITES.get('groove_fill')
++
++    # Build back groove
++    surf.blit(start, topleft)
++    for idx in range(width - 2):
++        mid_pos = (topleft[0] + 2 + idx, topleft[1])
++        surf.blit(mid, mid_pos)
++    surf.blit(end, (topleft[0] + width, topleft[1]))
++
++    # Build fill groove
++    number_needed = int(fill * (width - 1))  # Width of groove minus section for start and end
++    for groove in range(number_needed):
++        surf.blit(fg, (topleft[0] + 1 + groove, topleft[1] + 1))
++
++class StatScreenState(MapState):
++    name = 'stat_screen'
++
++    def start(self):
++        self.fluid = FluidScroll(200, 1)
++
++        SOUNDTHREAD.play_sfx('Info In')
++        game.stat_screen.toggle_info(True)
++        game.stat_screen.info_graph.set_transition_in()
++
++    def take_input(self, event):
++        first_push = self.fluid.update()
++        directions = self.fluid.get_directions()
++
++        self.handle_mouse()
++        if game.stat_screen.info_flag:
++            if event == 'INFO' or event == 'BACK':
++                SOUNDTHREAD.play_sfx('Info Out')
++                game.stat_screen.info_graph.set_transition_out()
++                game.state.back()
++
++            if 'RIGHT' in directions:
++                SOUNDTHREAD.play_sfx('Select 6')
++                game.stat_screen.info_graph.move_right()
++            elif 'LEFT' in directions:
++                SOUNDTHREAD.play_sfx('Select 6')
++                game.stat_screen.info_graph.move_left()
++            elif 'UP' in directions:
++                SOUNDTHREAD.play_sfx('Select 6')
++                game.stat_screen.info_graph.move_up()
++            elif 'DOWN' in directions:
++                SOUNDTHREAD.play_sfx('Select 6')
++                game.stat_screen.info_graph.move_down()
++
++    def handle_mouse(self):
++        mouse_position = INPUT.get_mouse_position()
++        if not mouse_position:
++            return
++        if game.stat_screen.info_flag:
++            game.stat_screen.info_graph.handle_mouse(mouse_position)
++
++    def finish(self):
++        game.stat_screen.toggle_info(False)
++
++class StatScreen():
++    def __init__(self):
++        self.bg = SPRITES.get('stat_screen_background')
++        self.unit = None
++        self._next_unit = None
++
++        self.info_graph = info_menu.InfoGraph()
++        self.info_flag = False
++        self.info_graph.set_current_state('personal_data')
++        self.reset_surfs()
++
++        self.transition = None
++        self.transition_counter = 0
++
++    def reset_surfs(self):
++        self.info_graph.clear()
++        self.portrait_surf = None
++        self.personal_data_surf = None
++
++    def toggle_info(self, val=False):
++        self.info_flag = val
++
++    def update(self):
++        hover = game.cursor.get_hover()
++        if hover and game.state.current() == 'free':
++            if hover != self.unit:
++                self._next_unit = hover
++                self.transition = 'out'
++
++        if self.transition == 'out':
++            self.transition_counter += 1
++            self.transparency = self.transition_counter / 5
++            if self.transparency >= 1:
++                self.transition = 'in'
++                self.transparency = 1
++                self.unit = self._next_unit
++                self._next_unit = None
++                self.reset_surfs()
++
++        elif self.transition == 'in':
++            self.transition_counter -= 1
++            self.transparency = self.transition_counter / 5
++            if self.transparency <= 0:
++                self.transition = None
++                self.transparency = 0
++
++    def draw(self, surf):
++        self.update()
++        if self.bg:
++            surf.blit(self.bg, (0, 0))
++        if self.unit:
++            self.draw_portrait(surf)
++            self.draw_slide(surf)
++        if self.info_graph.current_bb:
++            self.info_graph.draw(surf)
++        return surf
++
++    def draw_portrait(self, surf):
++        if not self.portrait_surf:
++            self.portrait_surf = self.create_portrait()
++
++        # Stick it on the surface
++        if self.transparency:
++            im = image_mods.make_translucent(self.portrait_surf, self.transparency)
++            surf.blit(im, (0, 0))
++        else:
++            surf.blit(self.portrait_surf, (0, 0))
++
++    def create_portrait(self):
++        surf = engine.create_surface((STATWIDTH, WINHEIGHT), transparent=True)
++        surf.blit(SPRITES.get('info_unit'), (54, 82))
++
++        im = icons.get_portrait(self.unit)
++        if im:
++            width = im.get_width()
++            if width < 112:
++                x_pos = (width - 80)//2
++                portrait_surf = engine.subsurface(im, (x_pos, 0, 80, 72))
++                portrait_surf = engine.flip_horiz(portrait_surf)
++                surf.blit(portrait_surf, (16, 2))
++            else:
++                x_pos = (width - 112)//2
++                portrait_surf = engine.subsurface(im, (x_pos, 0, 112, 72))
++                portrait_surf = engine.flip_horiz(portrait_surf)
++                surf.blit(portrait_surf, (0, 2))
++
++        class_obj = DB.classes.get(self.unit.klass)
++        if self.unit.generic:
++            FONT['text-white'].blit(class_obj.name, surf, (8, 80))
++            self.info_graph.register((8, 80, 72, 16), class_obj.desc, 'all', first=True)
++        else:
++            FONT['text-white'].blit(self.unit.name, surf, (8, 80))
++            self.info_graph.register((8, 80, 72, 16), self.unit.desc, 'all', first=True)
++        FONT['text-blue'].blit_right(str(self.unit.level), surf, (86, 80))
++        self.info_graph.register((50, 80, 30, 16), 'Level_desc', 'all')
++        FONT['text-blue'].blit_right(str(self.unit.exp), surf, (110, 80))
++        self.info_graph.register((86, 80, 30, 16), 'Exp_desc', 'all')
++        # FONT['text-blue'].blit_right(str(self.unit.get_hp()), surf, (86, 96))
++        self.info_graph.register((50, 96, 72, 16), 'HP_desc', 'all')
++        max_hp = self.unit.get_max_hp()
++        FONT['text-blue'].blit_right(str(max_hp), surf, (110, 96))
++        affinity = DB.affinities.get(self.unit.affinity)
++        # Affinity needs icons!
++        if affinity:
++            icons.draw_item(surf, affinity, (4, 16))
++            self.info_graph.register((4, 24, 16, 16), affinity.desc, 'all')
++
++        # Skills
++        skills = [skill for skill in self.unit.skills if skill.class_skill and not skill.hidden]
++        for idx, skill in enumerate(skills):
++            left_pos = idx * 24
++            icons.draw_skill(surf, skill, (left_pos + 8, 96), compact=True)
++            help_box = help_menu.HelpDialog(skill.desc, name=skill.name)
++            self.info_graph.register((left_pos + 8, 96, 16, 16), help_box, 'all')
++
++        return surf
++
++    def draw_slide(self, surf):
++        if not self.personal_data_surf:
++            self.personal_data_surf = self.create_slide()
++        
++        buffer_surf = self.personal_data_surf.copy()
++        FONT['text-blue'].blit_right(str(self.unit.get_hp()), buffer_surf, (86, 96))
++
++        # Stick it on the surface
++        if self.transparency:
++            im = image_mods.make_translucent(buffer_surf, self.transparency)
++            surf.blit(im, (0, 0))
++        else:
++            surf.blit(buffer_surf, (0, 0))
++
++    def create_slide(self):
++        menu_size = STATWIDTH, WINHEIGHT
++        surf = engine.create_surface(menu_size, transparent=True)
++
++        self.draw_stats(surf, 116)
++        self.draw_equipment(surf, 152)
++
++        return surf
++
++    def draw_stats(self, surf, top):
++        class_obj = DB.classes.get(self.unit.klass)
++        max_stats = class_obj.max_stats
++
++        stats = [stat.nid for stat in DB.stats if stat.position == 'left']
++        # Make sure we only display up to 6 on each
++
++        for idx, stat_nid in enumerate(stats):
++            left = 37 * (idx // 2)
++            y_pos = top + 16 * (idx % 2)
++            icons.draw_stat(surf, stat_nid, self.unit, (36 + left, y_pos), compact=True)
++            # Name
++            name = DB.stats.get(stat_nid).name
++            FONT['text-yellow'].blit(name, surf, (1 + left, y_pos))
++            base_value = self.unit.stats.get(stat_nid, 0)
++            contribution = self.unit.stat_contribution(stat_nid)
++            contribution['Base Value'] = base_value
++            help_box = help_menu.StatDialog('%s_desc' % stat_nid, contribution)
++            self.info_graph.register((1 + left, y_pos, 40, 16), help_box, 'all')
++
++        # Mana / MEM
++        mana = str(self.unit.get_mana())
++        left, y_pos = (37*2, top + 16 * 1)
++        FONT['text-blue'].blit_right(mana, surf, (36 + left, y_pos))
++        FONT['text-yellow'].blit(text_funcs.translate('MANA'), surf, (1 + left, y_pos))
++        self.info_graph.register((1 + left, y_pos, 40, 16), 'MANA_desc', 'all')
++
++        return surf
++
++    def draw_equipment(self, surf, top):
++        # Equipment
++        weapon = self.unit.get_weapon()
++        accessory = self.unit.get_accessory()
++
++        # Blit items
++        for idx, item in enumerate(self.unit.nonaccessories):
++            y_pos = idx * 16 + top
++            if item.multi_item and any(subitem is weapon for subitem in item.subitems):
++                surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
++                for subitem in item.subitems:
++                    if subitem is weapon:
++                        item_option = menu_options.ItemOption(idx, subitem)
++                        break
++                else:  # Shouldn't happen
++                    item_option = menu_options.ItemOption(idx, item)
++            else:
++                if item is weapon:
++                    surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
++                item_option = menu_options.ItemOption(idx, item)
++            item_option.draw(surf, 2, y_pos)
++            self.info_graph.register((2, y_pos, 108, 16), item_option.get_help_box(), 'all')
++
++        # Blit accessories
++        for idx, item in enumerate(self.unit.accessories):
++            aidx = item_funcs.get_num_items(self.unit) + idx
++            y_pos = aidx * 16 + top
++            if item.multi_item and any(subitem is accessory for subitem in item.subitems):
++                surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
++                for subitem in item.subitems:
++                    if subitem is accessory:
++                        if not item_funcs.available(self.unit, subitem) and subitem.memento_skill_on_hold:
++                            skill = [s for s in self.unit.skills if s.nid == subitem.memento_skill_on_hold.value][0]
++                            item_option = menu_options.SkillOption(aidx, skill)
++                        else:
++                            item_option = menu_options.MementoAccessoryItemOption(aidx, subitem)
++                        break
++                else:  # Shouldn't happen
++                    if not item_funcs.available(self.unit, subitem) and subitem.memento_skill_on_hold:
++                        skill = [s for s in self.unit.skills if s.nid == subitem.memento_skill_on_hold.value][0]
++                        item_option = menu_options.SkillOption(aidx, skill)
++                    else:
++                        item_option = menu_options.MementoAccessoryItemOption(aidx, subitem)
++            else:
++                if item is accessory:
++                    surf.blit(SPRITES.get('equipment_highlight'), (2, y_pos + 8))
++                if not item_funcs.available(self.unit, item) and item.memento_skill_on_hold:
++                    skills = [s for s in self.unit.skills if s.nid == item.memento_skill_on_hold.value]
++                    if skills:
++                        item_option = menu_options.SkillOption(aidx, skills[0])
++                    else:
++                        item_option = menu_options.MementoAccessoryItemOption(aidx, item)
++                else:
++                    item_option = menu_options.MementoAccessoryItemOption(aidx, item)
++            item_option.draw(surf, 2, y_pos)
++            first = (idx == 0 and not self.unit.nonaccessories)
++            self.info_graph.register((2, y_pos, 108, 16), item_option.get_help_box(), 'all', first=first)
++
++        return surf
+diff --git a/app/engine/state.py b/app/engine/state.py
+index acbb662a..6b89741f 100644
+--- a/app/engine/state.py
++++ b/app/engine/state.py
+@@ -1,6 +1,7 @@
+-from app.constants import TILEHEIGHT, TILEWIDTH, WINHEIGHT, WINWIDTH
++from app.constants import TILEHEIGHT, TILEWIDTH, WINHEIGHT, WINWIDTH, MAPWIDTH, STATWIDTH
+ from app.engine.fluid_scroll import FluidScroll
+ from app.engine.game_state import game
++from app.engine import engine
+ 
+ class State():
+     name = None
+@@ -51,8 +52,18 @@ class MapState(State):
+         pass
+ 
+     def draw(self, surf, culled_rect=None):
++        if game.game_vars.get('stat_screen', True):
++            stat_width = STATWIDTH
++            map_width = MAPWIDTH
++        else:
++            stat_width = 0
++            map_width = WINWIDTH
+         game.camera.update()
+         game.highlight.update()
+-        camera_cull = int(game.camera.get_x() * TILEWIDTH), int(game.camera.get_y() * TILEHEIGHT), WINWIDTH, WINHEIGHT
++        full_surf = engine.create_surface((WINWIDTH, WINHEIGHT))
++        camera_cull = int(game.camera.get_x() * TILEWIDTH), int(game.camera.get_y() * TILEHEIGHT), map_width, WINHEIGHT
+         surf = game.map_view.draw(camera_cull, culled_rect)
+-        return surf
++        full_surf.blit(surf, (stat_width, 0))
++        if stat_width > 0:
++            game.stat_screen.draw(full_surf)
++        return full_surf
+diff --git a/app/engine/state_machine.py b/app/engine/state_machine.py
+index 0a003904..0ea23e43 100644
+--- a/app/engine/state_machine.py
++++ b/app/engine/state_machine.py
+@@ -29,7 +29,8 @@ class StateMachine():
+         from app.engine import title_screen, transitions, general_states, level_up, \
+             turnwheel, game_over, settings, info_menu, prep, base, trade, promotion, \
+             status_upkeep, debug_mode, chapter_title, player_choice, feat_choice, \
+-            victory_screen, objective_menu, minimap, roam_state, game_menus, dialog_log
++            victory_screen, objective_menu, minimap, roam_state, game_menus, dialog_log, \
++            stat_screen
+         from app.engine.overworld import overworld_states
+         from app.events import event_state
+         self.all_states = \
+@@ -59,6 +60,7 @@ class StateMachine():
+              'objective_menu': objective_menu.ObjectiveMenuState,
+              'unit_menu': game_menus.UnitMenuState,
+              'info_menu': info_menu.InfoMenuState,
++             'stat_screen': stat_screen.StatScreenState,
+              'phase_change': general_states.PhaseChangeState,
+              'move': general_states.MoveState,
+              'movement': general_states.MovementState,
+diff --git a/app/engine/target_system.py b/app/engine/target_system.py
+index 2980c8c9..979be82f 100644
+--- a/app/engine/target_system.py
++++ b/app/engine/target_system.py
+@@ -147,9 +147,11 @@ def get_valid_moves(unit, force=False) -> set:
+ 
+     valid_moves = pathfinder.process(game.board, movement_left)
+     valid_moves.add(unit.position)
++    witch_warp = set(skill_system.witch_warp(unit))
++    valid_moves |= witch_warp
+     return valid_moves
+ 
+-def get_path(unit, position, ally_block=False) -> list:
++def get_path(unit, position, ally_block=False, use_limit=False) -> list:
+     from app.engine.movement import MovementManager
+     mtype = MovementManager.get_movement_group(unit)
+     grid = game.board.get_grid(mtype)
+@@ -159,7 +161,8 @@ def get_path(unit, position, ally_block=False) -> list:
+     ai_fog_of_war = DB.constants.value('ai_fog_of_war')
+     pathfinder = pathfinding.AStar(unit.position, position, grid, width, height, unit.team, pass_through, ai_fog_of_war)
+ 
+-    path = pathfinder.process(game.board, ally_block=ally_block)
++    limit = unit.movement_left if use_limit else None
++    path = pathfinder.process(game.board, ally_block=ally_block, limit=limit)
+     if path is None:
+         return []
+     return path
+diff --git a/app/engine/ui_view.py b/app/engine/ui_view.py
+index b820a0d4..90d02a1a 100644
+--- a/app/engine/ui_view.py
++++ b/app/engine/ui_view.py
+@@ -1,5 +1,5 @@
+ import app.engine.config as cf
+-from app.constants import TILEX, TILEY, WINHEIGHT, WINWIDTH
++from app.constants import TILEX, TILEY, WINHEIGHT, WINWIDTH, STATWIDTH, MAPWIDTH
+ from app.data.database import DB
+ from app.data.difficulty_modes import RNGOption
+ from app.engine import (base_surf, combat_calcs, engine, equations, evaluate,
+@@ -19,7 +19,7 @@ class UIView():
+     y_positions = (0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0)
+ 
+     def __init__(self):
+-        self.unit_info_disp = None
++        # self.unit_info_disp = None
+         self.tile_info_disp = None
+         self.obj_info_disp = None
+         self.attack_info_disp = None
+@@ -28,7 +28,7 @@ class UIView():
+ 
+         self.cursor_right: bool = False
+ 
+-        self.unit_info_offset = 0
++        # self.unit_info_offset = 0
+         self.obj_info_offset = 0
+         self.attack_info_offset = 0
+         self.initiative_info_offset = 0
+@@ -39,11 +39,11 @@ class UIView():
+         self.tile_last_update: int = 0
+         self.current_tile_pos = None
+ 
+-        self.remove_unit_info = True
++        # self.remove_unit_info = True
+         self.obj_top = False
+ 
+-    def remove_unit_display(self):
+-        self.remove_unit_info = True
++    # def remove_unit_display(self):
++    #     self.remove_unit_info = True
+ 
+     def get_cursor_right(self):
+         return game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1
+@@ -78,19 +78,19 @@ class UIView():
+     def draw(self, surf):
+         self.update()
+         # Unit info handling
+-        if self.remove_unit_info:
+-            hover = game.cursor.get_hover()
+-            if game.state.current() in self.legal_states and hover:
+-                self.remove_unit_info = False
+-                self.unit_info_disp = self.create_unit_info(hover)
+-                self.unit_info_offset = min(self.unit_info_disp.get_width(), self.unit_info_offset)
+-            elif self.unit_info_disp:
+-                self.unit_info_offset += 20
+-                if self.unit_info_offset >= 200:
+-                    self.unit_info_disp = None
+-        else:
+-            self.unit_info_offset -= 20
+-            self.unit_info_offset = max(0, self.unit_info_offset)
++        # if self.remove_unit_info:
++        #     hover = game.cursor.get_hover()
++        #     if game.state.current() in self.legal_states and hover:
++        #         self.remove_unit_info = False
++        #         self.unit_info_disp = self.create_unit_info(hover)
++        #         self.unit_info_offset = min(self.unit_info_disp.get_width(), self.unit_info_offset)
++        #     elif self.unit_info_disp:
++        #         self.unit_info_offset += 20
++        #         if self.unit_info_offset >= 200:
++        #             self.unit_info_disp = None
++        # else:
++        #     self.unit_info_offset -= 20
++        #     self.unit_info_offset = max(0, self.unit_info_offset)
+ 
+         # Objective info handling
+         if game.state.current() in self.legal_states and cf.SETTINGS['show_objective']:
+@@ -116,16 +116,16 @@ class UIView():
+ 
+         # === Final drawing
+         # Should be in topleft, unless cursor is in topleft, in which case it should be in bottomleft
+-        if self.unit_info_disp:
+-            # If in top and not in right
+-            if not DB.constants.value('initiative') or not game.initiative.draw_me:
+-                if game.cursor.position[1] < TILEY // 2 + game.camera.get_y() and \
+-                        not (game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1):
+-                    surf.blit(self.unit_info_disp, (-self.unit_info_offset, WINHEIGHT - self.unit_info_disp.get_height()))
+-                else:
+-                    surf.blit(self.unit_info_disp, (-self.unit_info_offset, 0))
+-            else:
+-                pass
++        # if self.unit_info_disp:
++        #     # If in top and not in right
++        #     if not DB.constants.value('initiative') or not game.initiative.draw_me:
++        #         if game.cursor.position[1] < TILEY // 2 + game.camera.get_y() and \
++        #                 not (game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1):
++        #             surf.blit(self.unit_info_disp, (-self.unit_info_offset, WINHEIGHT - self.unit_info_disp.get_height()))
++        #         else:
++        #             surf.blit(self.unit_info_disp, (-self.unit_info_offset, 0))
++        #     else:
++        #         pass
+ 
+         if game.state.current() in self.legal_states and cf.SETTINGS['show_terrain'] and \
+                 (game.level_vars['_fog_of_war'] != 2 or game.board.in_vision(game.cursor.position)):
+@@ -146,7 +146,7 @@ class UIView():
+                 if right:
+                     surf.blit(self.tile_info_disp, (5 - offset, WINHEIGHT - self.tile_info_disp.get_height() - 3)) # Bottomleft
+                 else:
+-                    xpos = WINWIDTH - self.tile_info_disp.get_width() - 5 + offset
++                    xpos = MAPWIDTH - self.tile_info_disp.get_width() - 5 + offset
+                     ypos = WINHEIGHT - self.tile_info_disp.get_height() - 3
+                     surf.blit(self.tile_info_disp, (xpos, ypos)) # Bottomright
+ 
+@@ -263,16 +263,18 @@ class UIView():
+         else:
+             bg_surf = SPRITES.get('tile_info_quick_opaque').copy()
+             bg_surf = image_mods.make_translucent(bg_surf, .1)
+-            tile_def, tile_avoid = 0, 0
++            stat_changes = {}
+             if terrain.status:
+                 status_prefab = DB.skills.get(terrain.status)
+                 for component in status_prefab.components:
+-                    if component.defines('tile_def'):
+-                        tile_def += component.tile_def()
+-                    if component.defines('tile_avoid'):
+-                        tile_avoid += component.tile_avoid()
+-            FONT['small-white'].blit_right(str(tile_def), bg_surf, (bg_surf.get_width() - 4, 17))
+-            FONT['small-white'].blit_right(str(tile_avoid), bg_surf, (bg_surf.get_width() - 4, 25))
++                    if component.defines('stat_change'):
++                        stat_changes.update(component.stat_change())
++            for idx, (stat_nid, stat_change) in enumerate(list(stat_changes.items())[:2]):
++                text = str(stat_change)
++                if stat_change > 0:
++                    text = "+" + text
++                FONT['small-white'].blit(stat_nid, bg_surf, (1, 17 + idx * 8))
++                FONT['small-white'].blit_right(text, bg_surf, (bg_surf.get_width() - 4, 17 + idx * 8))
+ 
+         name = terrain.name
+         width, height = FONT['text-white'].size(name)
+@@ -432,7 +434,7 @@ class UIView():
+         crit = DB.constants.get('crit').value
+ 
+         if game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1:
+-            topleft = (8 - self.attack_info_offset, 4)
++            topleft = (STATWIDTH + 8 - self.attack_info_offset, 4)
+         else:
+             topleft = (WINWIDTH - 77 + self.attack_info_offset, 4)
+         if self.attack_info_offset > 0:
+@@ -581,7 +583,7 @@ class UIView():
+             mt = combat_calcs.damage(attacker, spell)
+             if mt is not None:
+                 height += 16
+-            real_surf = base_surf.create_base_surf((80, height), 'menu_bg_base_opaque')
++            real_surf = base_surf.create_base_surf((80, height), 'menu_bg_base')
+             bg_surf = engine.create_surface((real_surf.get_width() + 2, real_surf.get_height() + 4), transparent=True)
+             bg_surf.blit(real_surf, (2, 4))
+             bg_surf.blit(SPRITES.get('menu_gem_small'), (0, 0))
+@@ -623,9 +625,9 @@ class UIView():
+             unit_surf = defender.sprite.create_image('passive')
+ 
+         if game.cursor.position[0] > TILEX // 2 + game.camera.get_x() - 1:
+-            topleft = (4, 4)
++            topleft = (STATWIDTH + 4, 4)
+             if defender:
+-                u_topleft = (16 - max(0, (unit_surf.get_width() - 16)//2), 12 - max(0, (unit_surf.get_width() - 16)//2))
++                u_topleft = (STATWIDTH + 16 - max(0, (unit_surf.get_width() - 16)//2), 12 - max(0, (unit_surf.get_width() - 16)//2))
+         else:
+             topleft = (WINWIDTH - 4 - width, 4)
+             if defender:
+@@ -702,7 +704,7 @@ class ItemDescriptionPanel():
+ 
+     def create_surf(self):
+         width, height = 96, 56
+-        sub_bg_surf = base_surf.create_base_surf(width, height, 'menu_bg_base_opaque')
++        sub_bg_surf = base_surf.create_base_surf(width, height, 'menu_bg_base')
+         bg_surf = engine.create_surface((width + 2, height + 4), transparent=True)
+         bg_surf.blit(sub_bg_surf, (2, 4))
+         bg_surf.blit(SPRITES.get('menu_gem_small'), (0, 0))
+diff --git a/app/engine/unit_funcs.py b/app/engine/unit_funcs.py
+index cb17b91d..1a492f81 100644
+--- a/app/engine/unit_funcs.py
++++ b/app/engine/unit_funcs.py
+@@ -276,3 +276,5 @@ def check_flanked(unit) -> bool:
+         if left and right and skill_system.check_enemy(unit, left) and skill_system.check_enemy(unit, right):
+             return True
+     return False
++
++check_flanking = check_flanked
+diff --git a/app/engine/value_noise.py b/app/engine/value_noise.py
+new file mode 100644
+index 00000000..ad4f92d4
+--- /dev/null
++++ b/app/engine/value_noise.py
+@@ -0,0 +1,21 @@
++import glob
++
++from app.engine import engine
++
++class ValueNoise():
++    transparency = 16  # 0 - 255 (opaque)
++    speed = 50  # ms
++
++    def __init__(self):
++        self.ims = [engine.image_load(im) for im in glob.glob('fog/im*.png')]
++        self.reset_transparency()
++
++    def reset_transparency(self):
++        for im in self.ims:
++            im.set_alpha(self.transparency)
++
++    def draw(self, surf):
++        pz = int(engine.get_time() // self.speed) % len(self.ims)
++        im = self.ims[pz]
++        surf.blit(im, (0, 0))
++        return surf
+diff --git a/app/events/event.py b/app/events/event.py
+index 1ef90b22..b28d636a 100644
+--- a/app/events/event.py
++++ b/app/events/event.py
+@@ -6,11 +6,11 @@ from typing import Callable, Dict, List, Tuple
+ 
+ import app.engine.config as cf
+ import app.engine.graphics.ui_framework as uif
+-from app.constants import WINHEIGHT, WINWIDTH
++from app.constants import WINHEIGHT, WINWIDTH, MEMENTO_MODE
+ from app.data.database import DB
+ from app.data.level_units import GenericUnit, UniqueUnit
+ from app.engine import (action, background, banner, dialog, engine, evaluate,
+-                        icons, image_mods, item_funcs, item_system,
++                        icons, image_mods, item_funcs, item_system, memento_dialog,
+                         skill_system, static_random, target_system, unit_funcs)
+ from app.engine.animations import MapAnimation
+ from app.engine.combat import interaction
+@@ -21,33 +21,45 @@ from app.engine.objects.overworld import OverworldNodeObject
+ from app.engine.objects.tilemap import TileMapObject
+ from app.engine.objects.unit import UnitObject
+ from app.engine.overworld.overworld_actions import OverworldMove
+-from app.engine.overworld.overworld_map_view import OverworldMapView
+ from app.engine.overworld.overworld_movement_manager import \
+     OverworldMovementManager
+ from app.engine.sound import SOUNDTHREAD
+-from app.engine.game_state import game
+ from app.events import event_commands, regions
+-from app.events.event_portrait import EventPortrait
++from app.events.event_portrait import EventPortrait, MementoEventPortrait
+ from app.resources.resources import RESOURCES
+ from app.utilities import str_utils, utils
+-from app.utilities.algorithms.interpolation import cubic_easing, tcubic_easing
+ from app.utilities.typing import NID, Point
+ 
+-screen_positions = {'OffscreenLeft': -96,
+-                    'FarLeft': -24,
+-                    'Left': 0,
+-                    'MidLeft': 24,
+-                    'CenterLeft': 24,
+-                    'CenterRight': 120,
+-                    'MidRight': 120,
+-                    'LevelUpRight': 140,
+-                    'Right': 144,
+-                    'FarRight': 168,
+-                    'OffscreenRight': 240}
++if MEMENTO_MODE:
++    screen_positions = {'OffscreenLeft': -128,
++                        'FarLeft': 0,
++                        'Left': 36,
++                        'MidLeft': 72,
++                        'CenterLeft': 72,
++                        'CenterRight': 184,
++                        'MidRight': 184,
++                        'LevelUpRight': 216,
++                        'Right': 220,
++                        'FarRight': 256,
++                        'OffscreenRight': 384}
++else:
++    screen_positions = {'OffscreenLeft': -96,
++                        'FarLeft': -24,
++                        'Left': 0,
++                        'MidLeft': 24,
++                        'CenterLeft': 24,
++                        'CenterRight': 120,
++                        'MidRight': 120,
++                        'LevelUpRight': 140,
++                        'Right': 144,
++                        'FarRight': 168,
++                        'OffscreenRight': 240}
+ 
+ vertical_screen_positions = {'Top': 0,
+                              'Middle': 40,
+                              'Bottom': 80}
++if MEMENTO_MODE:
++    vertical_screen_positions['Top'] = 2
+ 
+ class Event():
+     _transition_speed = 250
+@@ -71,6 +83,10 @@ class Event():
+         self.position = position
+         self.region = region
+ 
++        if MEMENTO_MODE:
++            self.dialog_background = memento_dialog.MementoDialogBackground()
++        else:
++            self.dialog_background = None
+         self.portraits: Dict[str, EventPortrait] = {}
+         self.text_boxes = []
+         self.other_boxes = []
+@@ -254,6 +270,9 @@ class Event():
+ 
+         # Draw text/dialog boxes
+         # if self.state == 'dialog':
++        if self.dialog_background:
++            self.dialog_background.update()
++            self.dialog_background.draw(surf)
+         if not self.do_skip:
+             to_draw = []
+             for dialog_box in reversed(self.text_boxes):
+@@ -367,6 +386,11 @@ class Event():
+         if self.text_boxes:
+             self.text_boxes[-1].hurry_up()
+ 
++    def saturate_portrait(self, portrait):
++        for port in self.portraits.values():
++            port.desaturate()
++        portrait.saturate()
++
+     def run_command(self, command: event_commands.EventCommand):
+         logging.info('%s: %s', command.nid, command.values)
+         current_time = engine.get_time()
+@@ -383,7 +407,6 @@ class Event():
+                 self.do_skip = False
+ 
+         elif command.nid == 'music':
+-            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             music = command.values[0]
+             fade = 400
+             if len(command.values) > 1 and command.values[1]:
+@@ -396,7 +419,6 @@ class Event():
+                 SOUNDTHREAD.fade_in(music, fade_in=fade)
+ 
+         elif command.nid == 'music_clear':
+-            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             fade = 0
+             if len(command.values) > 0 and command.values[0]:
+                 fade = int(command.values[0])
+@@ -408,7 +430,6 @@ class Event():
+                 SOUNDTHREAD.clear()
+ 
+         elif command.nid == 'sound':
+-            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             sound = command.values[0]
+             volume = 1
+             if len(command.values) > 1 and command.values[1]:
+@@ -416,7 +437,6 @@ class Event():
+             SOUNDTHREAD.play_sfx(sound, volume=volume)
+ 
+         elif command.nid == 'change_music':
+-            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             phase = command.values[0]
+             music = command.values[1]
+             if music == 'None':
+@@ -459,6 +479,12 @@ class Event():
+             self.wait_time = current_time + int(self.transition_speed * 1.33)
+             self.state = 'waiting'
+ 
++        elif command.nid == 'dialog_start':
++            self.dialog_background.start()
++
++        elif command.nid == 'dialog_end':
++            self.dialog_background.end()
++
+         elif command.nid == 'speak':
+             self.speak(command)
+ 
+@@ -526,7 +552,6 @@ class Event():
+             portrait.set_expression(expression_list)
+ 
+         elif command.nid == 'disp_cursor':
+-            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             b = command.values[0]
+             if b.lower() in self.true_vals:
+                 game.cursor.show()
+@@ -1074,16 +1099,19 @@ class Event():
+             values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
+             nid = values[0]
+             if nid not in RESOURCES.animations.keys():
+-                logging.error("Could not find map animtion %s" % nid)
++                logging.error("Could not find map animation %s" % nid)
+                 return
+             pos = self.parse_pos(values[1])
+             if len(values) > 2:
+                 speed_mult = int(values[2])
+             else:
+                 speed_mult = 1
+-            anim = RESOURCES.animations.get(nid)
+-            anim = MapAnimation(anim, pos, speed_adj=speed_mult)
+-            self.animations.append(anim)
++            if 'permanent' in flags:
++                action.do(action.AddMapAnim(nid, pos, speed_mult))
++            else:
++                anim = RESOURCES.animations.get(nid)
++                anim = MapAnimation(anim, pos, speed_adj=speed_mult)
++                self.animations.append(anim)
+ 
+             if 'no_block' in flags or self.do_skip:
+                 pass
+@@ -1091,6 +1119,12 @@ class Event():
+                 self.wait_time = engine.get_time() + anim.get_wait()
+                 self.state = 'waiting'
+ 
++        elif command.nid == 'remove_map_anim':
++            values, flags = event_commands.parse(command, self._evaluate_evals, self._evaluate_vars)
++            nid = values[0]
++            pos = self.parse_pos(values[1])
++            action.do(action.RemoveMapAnim(nid, pos))
++
+         elif command.nid == 'merge_parties':
+             self.merge_parties(command)
+ 
+@@ -1358,7 +1392,9 @@ class Event():
+             return False
+ 
+         pos = values[1]
+-        if len(values) > 4 and values[4]: # there's a vertical position as well
++        if MEMENTO_MODE:
++            vert_pos = 'Top'
++        elif len(values) > 4 and values[4]: # there's a vertical position as well
+             vert_pos = values[4]
+         else:
+             vert_pos = 'Bottom'
+@@ -1385,7 +1421,13 @@ class Event():
+         if len(values) > 2 and values[2]:
+             slide = values[2]
+ 
+-        new_portrait = EventPortrait(portrait, position, priority, transition, slide, mirror)
++        if MEMENTO_MODE:
++            new_portrait = MementoEventPortrait(portrait, position, priority, transition, 'right', mirror, name)
++        else:
++            new_portrait = EventPortrait(portrait, position, priority, transition, slide, mirror, name)
++        
++        if 'desaturate' in flags:
++            new_portrait.saturation = 0
+         self.portraits[name] = new_portrait
+ 
+         if len(values) > 3 and values[3]:
+@@ -1520,7 +1562,11 @@ class Event():
+             if not width:
+                 width = WINWIDTH - 8
+ 
+-        new_dialog = dialog.Dialog(text, portrait, bg, position, width, speaker=speaker, variant=variant)
++        if MEMENTO_MODE:
++            new_dialog = memento_dialog.MementoDialog(text, self.dialog_background, portrait)
++            self.saturate_portrait(portrait)
++        else:
++            new_dialog = dialog.Dialog(text, portrait, bg, position, width, speaker=speaker, variant=variant)
+         self.text_boxes.append(new_dialog)
+         self.state = 'dialog'
+         # Bring portrait to forefront
+diff --git a/app/events/event_commands.py b/app/events/event_commands.py
+index 8f18f45f..62443da4 100644
+--- a/app/events/event_commands.py
++++ b/app/events/event_commands.py
+@@ -252,7 +252,7 @@ Extra flags:
+ 
+     keywords = ['Portrait', 'ScreenPosition']
+     optional_keywords = ['Slide', 'ExpressionList', 'VerticalScreenPosition']
+-    flags = ["mirror", "low_priority", "immediate", "no_block"]
++    flags = ["mirror", "low_priority", "immediate", "no_block", "desaturate"]
+ 
+ class MultiAddPortrait(EventCommand):
+     nid = "multi_add_portrait"
+@@ -372,6 +372,14 @@ Extra flags:
+     optional_keywords = ['ScreenPosition', 'Width', 'DialogVariant']
+     flags = ['low_priority']
+ 
++class DialogStart(EventCommand):
++    nid = 'dialog_start'
++    tag = Tags.DIALOGUE_TEXT
++
++class DialogEnd(EventCommand):
++    nid = 'dialog_end'
++    tag = Tags.DIALOGUE_TEXT
++
+ class Narrate(EventCommand):
+     nid = "narrate"
+     tag = Tags.DIALOGUE_TEXT
+@@ -1469,10 +1477,18 @@ Stores a given position (*Condition*) as the event's home position. It can later
+ class MapAnim(EventCommand):
+     nid = 'map_anim'
+     tag = Tags.TILEMAP
+-    desc = ( 'Plays a map animation denoted by the nid *MapAnim* at *Position*. Optional args: a speed multiplier'
+-             ' *Float*, which increases the length of time it takes to play the animation (larger is slower)')
++    desc = ('Plays a map animation denoted by the nid *MapAnim* at *Position*. Optional args: a speed multiplier'
++            ' *Float*, which increases the length of time it takes to play the animation (larger is slower)')
+     keywords = ["MapAnim", "Position"]
+     optional_keywords = ["Float"]
++    flags = ["no_block", "permanent"]
++
++class RemoveMapAnim(EventCommand):
++    nid = 'remove_map_anim'
++    tag = Tags.TILEMAP
++    desc = ('Removes a map animation denoted by the nid *MapAnim* at *Position*. Only removes MapAnims that were created using'
++            ' the "permanent" flag')
++    keywords = ["MapAnim", "Position"]
+ 
+ class MergeParties(EventCommand):
+     nid = 'merge_parties'
+diff --git a/app/events/event_portrait.py b/app/events/event_portrait.py
+index 63812684..2574be93 100644
+--- a/app/events/event_portrait.py
++++ b/app/events/event_portrait.py
+@@ -10,6 +10,8 @@ from app.engine import engine, image_mods
+ 
+ class EventPortrait():
+     width, height = 128, 112
++    main_portrait_coords = (0, 0, 96, 80)
++    chibi_coords = (96, 16, 32, 32)
+ 
+     halfblink = (96, 48, 32, 16)
+     fullblink = (96, 64, 32, 16)
+@@ -25,11 +27,14 @@ class EventPortrait():
+     transition_speed = utils.frames2ms(14)
+     travel_time = utils.frames2ms(15)
+     bop_time = utils.frames2ms(8)
++    saturation_time = utils.frames2ms(60)
+ 
+-    def __init__(self, portrait: Portrait, position: Point, priority, transition=False, slide=None, mirror=False, expressions=None):
++    def __init__(self, portrait: Portrait, position: Point, priority, transition=False, slide=None, mirror=False, name='', expressions=None):
+         self.portrait = portrait
+         if not self.portrait.image:
+             self.portrait.image = engine.image_load(self.portrait.full_path)
++        self.width = self.portrait.image.get_width()
++        self.height = self.portrait.image.get_height()
+         self.portrait.image = self.portrait.image.convert()
+         engine.set_colorkey(self.portrait.image, COLORKEY, rleaccel=True)
+         self.position = position
+@@ -38,10 +43,11 @@ class EventPortrait():
+         self.transition_update = engine.get_time()
+         self.slide = slide
+         self.mirror = mirror
++        self.name = name
+         self.expressions = expressions or set()
+ 
+-        self.main_portrait = engine.subsurface(self.portrait.image, (0, 0, 96, 80))
+-        self.chibi = engine.subsurface(self.portrait.image, (96, 16, 32, 32))
++        self.main_portrait = engine.subsurface(self.portrait.image, self.main_portrait_coords)
++        self.chibi = engine.subsurface(self.portrait.image, self.chibi_coords)
+ 
+         self.talk_on = False
+         self.remove = False
+@@ -68,6 +74,10 @@ class EventPortrait():
+         self.bop_height = 2
+         self.last_bop = None
+ 
++        # For saturation
++        self.saturation = 1.
++        self.saturation_state = 0
++
+     def get_width(self):
+         return 96
+ 
+@@ -189,9 +199,17 @@ class EventPortrait():
+ 
+     def update(self) -> bool:
+         current_time = engine.get_time()
++        delta_time = engine.get_delta()
+         self.update_talk(current_time)
+         self.blink_counter.update(current_time)
+ 
++        if self.saturation_state != 0:
++            self.saturation += self.saturation_state * delta_time / self.saturation_time
++            self.saturation = utils.clamp(self.saturation, 0, 1)
++            # If reached one of the two extremes
++            if self.saturation == 0 or self.saturation == 1:
++                self.saturation_state = 0
++
+         if self.transition:
+             # 14 frames for unit face to appear
+             perc = (current_time - self.transition_update) / self.transition_speed
+@@ -243,6 +261,10 @@ class EventPortrait():
+         if self.mirror:
+             image = engine.flip_horiz(image)
+ 
++        if self.saturation < 1:
++            blackness = 0.5 * (1 - self.saturation)
++            image = image_mods.make_black_colorkey(image, blackness)
++
+         if self.transition:
+             if self.slide:
+                 image = image_mods.make_translucent(image.convert_alpha(), 1 - self.transition_progress)
+@@ -251,10 +273,11 @@ class EventPortrait():
+ 
+         position = self.position
+ 
++        slide_length = 24
+         if self.slide == 'right':
+-            position = position[0] - int(24 * self.transition_progress), self.position[1]
++            position = position[0] + slide_length - int(slide_length * self.transition_progress), self.position[1]
+         elif self.slide == 'left':
+-            position = position[0] + int(24 * self.transition_progress), self.position[1]
++            position = position[0] - slide_length + int(slide_length * self.transition_progress), self.position[1]
+ 
+         if self.bop_state:
+             position = position[0], position[1] + self.bop_height
+@@ -265,3 +288,23 @@ class EventPortrait():
+         self.transition = True
+         self.remove = True
+         self.transition_update = engine.get_time()
++
++class MementoEventPortrait(EventPortrait):
++    width, height = 128 + 32, 128
++    main_portrait_coords = 0, 0, 128, 128
++
++    def get_width(self):
++        return 128
++
++    def get_height(self):
++        return 128
++
++    def create_image(self):
++        main_image = self.main_portrait.copy()
++        return main_image
++
++    def saturate(self):
++        self.saturation_state = 1
++
++    def desaturate(self):
++        self.saturation_state = -1
+diff --git a/app/events/event_validators.py b/app/events/event_validators.py
+index 0f890913..d25c7375 100644
+--- a/app/events/event_validators.py
++++ b/app/events/event_validators.py
+@@ -578,7 +578,7 @@ class RegionType(OptionValidator):
+     valid = ['normal', 'event', 'status', 'formation']
+ 
+ class Weather(OptionValidator):
+-    valid = ["rain", "sand", "snow", "fire", "light", "dark", "smoke"]
++    valid = ["rain", "sand", "snow", "fire", "light", "dark", "smoke", "fog"]
+ 
+ class CombatScript(Validator):
+     valid_commands = ['hit1', 'hit2', 'crit1', 'crit2', 'miss1', 'miss2', '--', 'end']
+diff --git a/app/resources/combat_palettes.py b/app/resources/combat_palettes.py
+index cc3845f1..4490632a 100644
+--- a/app/resources/combat_palettes.py
++++ b/app/resources/combat_palettes.py
+@@ -18,7 +18,7 @@ class Palette(Prefab):
+             if color in my_colors:
+                 counter += 1
+         # Similar if more than 75% of colors match
+-        return counter / len(colors) > .75
++        return (counter / len(colors)) > .75
+ 
+     def assign_colors(self, colors: list):
+         self.colors = {
+diff --git a/app/resources/tiles.py b/app/resources/tiles.py
+index 532f389b..41de3a4b 100644
+--- a/app/resources/tiles.py
++++ b/app/resources/tiles.py
+@@ -9,7 +9,7 @@ from app.utilities import str_utils
+ class TileMapPrefab(Prefab):
+     def __init__(self, nid):
+         self.nid = nid
+-        self.width, self.height = TILEX, TILEY
++        self.width, self.height = TILEX, int(TILEY)
+         self.autotile_fps = 29
+         self.layers = Data()
+         self.layers.append(LayerGrid('base', self))
+diff --git a/app/utilities/pair_up_notes.txt b/app/utilities/pair_up_notes.txt
+new file mode 100644
+index 00000000..2890709c
+--- /dev/null
++++ b/app/utilities/pair_up_notes.txt
+@@ -0,0 +1,65 @@
++pair up notes
++What is difference between strike partner and paired partner
++strike_partner IS unit, paired partner is unit NID
++target_ally item nid component? line 102 of animation combat
++battle_anim copy?
++
++Consider rewriting draw_under, draw, draw_over section in animation combat
++self.right_gauge and self.left_gauge don't need to be "self"
++
++self.defender build gaurd = True in two places
++base_combat.py line 65 strike partner for defender doesn't get to play?
++
++Double wexp in simple combat for defender line 139
++
++Why is end combat for simple combat line 207, different from end combat for base_combat
++
++No extra game.state.change('exp') in simple_combat.py line 457
++self.defender does not always exist line 466 of simple_combat
++
++The exp section is just wrong with  where it is on the if statements (You have no fallback for GainExp when self.alerts is False)
++
++How does calculate paired exp work?
++Doubling + Brave in pairup mechanics
++
++Line 366 defender.guard_gauge?
++What does old defender mean?
++action.UseGauge
++
++line 109 of weapon components should be if 'blah' in playback
++ same with line 137
++gauge_inc should be a function since you could conceivably change it
++Same with max guard
++
++self.built_gaurd? What is it's purpose?
++
++Fix line 186 of combat2_components
++Why bother checking if unit == u for line 42 of PairUpBonus
++
++Line 234 of abilities (and not u.traveler)
++Replace paired partner with traveler everywhere, since they do the same thing?
++
++Separate Abilitiy do() menu then free, why? Don't we also need to wait the other unit? Plus our wait is not using the turnwheel?
++
++SwapAbility isn't implemented correctly
++Transfer is also probably not implemented correctly
++
++Also you forgot staticmethod on Transfer and Swap do()
++DB.constants.get() -> DB.constants.value()
++
++PairUp needs to clear subactions list
++And honestly should just use Leave Action as another subaction PairUp execute probably doesn't work without skilll_system.on_pairup
++
++Change UseGauge to SetGauge and IncGauge. Just makes more sense
++
++Don't think the way you have partners picked out for ai_controller works correctly when one unit is Guard Stance
++
++Same with find strike partners line 1338 of genr1eal states
++
++Instead of doing copy, instead check if battle_anim.unit exists, and if so, then create a copy
++
++Definitely refactor compute_assist_damage back into compute_damage
++
++Swap line 725 of general states is extraneous
++
++What is skill icon center doing? (gui.py)
+diff --git a/fog/im000.png b/fog/im000.png
+new file mode 100644
+index 00000000..1641772b
+Binary files /dev/null and b/fog/im000.png differ
+diff --git a/fog/im001.png b/fog/im001.png
+new file mode 100644
+index 00000000..25c6fa68
+Binary files /dev/null and b/fog/im001.png differ
+diff --git a/fog/im002.png b/fog/im002.png
+new file mode 100644
+index 00000000..06a4cfa7
+Binary files /dev/null and b/fog/im002.png differ
+diff --git a/fog/im003.png b/fog/im003.png
+new file mode 100644
+index 00000000..beb4977f
+Binary files /dev/null and b/fog/im003.png differ
+diff --git a/fog/im004.png b/fog/im004.png
+new file mode 100644
+index 00000000..db9d6dd4
+Binary files /dev/null and b/fog/im004.png differ
+diff --git a/fog/im005.png b/fog/im005.png
+new file mode 100644
+index 00000000..aab40938
+Binary files /dev/null and b/fog/im005.png differ
+diff --git a/fog/im006.png b/fog/im006.png
+new file mode 100644
+index 00000000..f1c2d8ce
+Binary files /dev/null and b/fog/im006.png differ
+diff --git a/fog/im007.png b/fog/im007.png
+new file mode 100644
+index 00000000..040b2cf6
+Binary files /dev/null and b/fog/im007.png differ
+diff --git a/fog/im008.png b/fog/im008.png
+new file mode 100644
+index 00000000..555ca94c
+Binary files /dev/null and b/fog/im008.png differ
+diff --git a/fog/im009.png b/fog/im009.png
+new file mode 100644
+index 00000000..5d2c07fa
+Binary files /dev/null and b/fog/im009.png differ
+diff --git a/fog/im010.png b/fog/im010.png
+new file mode 100644
+index 00000000..76d81328
+Binary files /dev/null and b/fog/im010.png differ
+diff --git a/fog/im011.png b/fog/im011.png
+new file mode 100644
+index 00000000..7f3196b5
+Binary files /dev/null and b/fog/im011.png differ
+diff --git a/fog/im012.png b/fog/im012.png
+new file mode 100644
+index 00000000..bc2a1fa5
+Binary files /dev/null and b/fog/im012.png differ
+diff --git a/fog/im013.png b/fog/im013.png
+new file mode 100644
+index 00000000..5b648052
+Binary files /dev/null and b/fog/im013.png differ
+diff --git a/fog/im014.png b/fog/im014.png
+new file mode 100644
+index 00000000..3eed8f3a
+Binary files /dev/null and b/fog/im014.png differ
+diff --git a/fog/im015.png b/fog/im015.png
+new file mode 100644
+index 00000000..b086780c
+Binary files /dev/null and b/fog/im015.png differ
+diff --git a/fog/im016.png b/fog/im016.png
+new file mode 100644
+index 00000000..ccdc0aa2
+Binary files /dev/null and b/fog/im016.png differ
+diff --git a/fog/im017.png b/fog/im017.png
+new file mode 100644
+index 00000000..ce3b5158
+Binary files /dev/null and b/fog/im017.png differ
+diff --git a/fog/im018.png b/fog/im018.png
+new file mode 100644
+index 00000000..4419a31c
+Binary files /dev/null and b/fog/im018.png differ
+diff --git a/fog/im019.png b/fog/im019.png
+new file mode 100644
+index 00000000..99a9cd6e
+Binary files /dev/null and b/fog/im019.png differ
+diff --git a/fog/im020.png b/fog/im020.png
+new file mode 100644
+index 00000000..a358a833
+Binary files /dev/null and b/fog/im020.png differ
+diff --git a/fog/im021.png b/fog/im021.png
+new file mode 100644
+index 00000000..e6d907e6
+Binary files /dev/null and b/fog/im021.png differ
+diff --git a/fog/im022.png b/fog/im022.png
+new file mode 100644
+index 00000000..bc49e733
+Binary files /dev/null and b/fog/im022.png differ
+diff --git a/fog/im023.png b/fog/im023.png
+new file mode 100644
+index 00000000..0a7b84e7
+Binary files /dev/null and b/fog/im023.png differ
+diff --git a/fog/im024.png b/fog/im024.png
+new file mode 100644
+index 00000000..40d7212e
+Binary files /dev/null and b/fog/im024.png differ
+diff --git a/fog/im025.png b/fog/im025.png
+new file mode 100644
+index 00000000..1738ea29
+Binary files /dev/null and b/fog/im025.png differ
+diff --git a/fog/im026.png b/fog/im026.png
+new file mode 100644
+index 00000000..6d4e5860
+Binary files /dev/null and b/fog/im026.png differ
+diff --git a/fog/im027.png b/fog/im027.png
+new file mode 100644
+index 00000000..c1e193ca
+Binary files /dev/null and b/fog/im027.png differ
+diff --git a/fog/im028.png b/fog/im028.png
+new file mode 100644
+index 00000000..ebe50e50
+Binary files /dev/null and b/fog/im028.png differ
+diff --git a/fog/im029.png b/fog/im029.png
+new file mode 100644
+index 00000000..639b8fe3
+Binary files /dev/null and b/fog/im029.png differ
+diff --git a/fog/im030.png b/fog/im030.png
+new file mode 100644
+index 00000000..9a276cfa
+Binary files /dev/null and b/fog/im030.png differ
+diff --git a/fog/im031.png b/fog/im031.png
+new file mode 100644
+index 00000000..1ff46897
+Binary files /dev/null and b/fog/im031.png differ
+diff --git a/fog/im032.png b/fog/im032.png
+new file mode 100644
+index 00000000..d990f7ef
+Binary files /dev/null and b/fog/im032.png differ
+diff --git a/fog/im033.png b/fog/im033.png
+new file mode 100644
+index 00000000..e1067a52
+Binary files /dev/null and b/fog/im033.png differ
+diff --git a/fog/im034.png b/fog/im034.png
+new file mode 100644
+index 00000000..ed1ec2a8
+Binary files /dev/null and b/fog/im034.png differ
+diff --git a/fog/im035.png b/fog/im035.png
+new file mode 100644
+index 00000000..ae6c2abd
+Binary files /dev/null and b/fog/im035.png differ
+diff --git a/fog/im036.png b/fog/im036.png
+new file mode 100644
+index 00000000..6250c91e
+Binary files /dev/null and b/fog/im036.png differ
+diff --git a/fog/im037.png b/fog/im037.png
+new file mode 100644
+index 00000000..c7173c86
+Binary files /dev/null and b/fog/im037.png differ
+diff --git a/fog/im038.png b/fog/im038.png
+new file mode 100644
+index 00000000..a8a73b28
+Binary files /dev/null and b/fog/im038.png differ
+diff --git a/fog/im039.png b/fog/im039.png
+new file mode 100644
+index 00000000..55adcc34
+Binary files /dev/null and b/fog/im039.png differ
+diff --git a/fog/im040.png b/fog/im040.png
+new file mode 100644
+index 00000000..7af32cc3
+Binary files /dev/null and b/fog/im040.png differ
+diff --git a/fog/im041.png b/fog/im041.png
+new file mode 100644
+index 00000000..a42f03c3
+Binary files /dev/null and b/fog/im041.png differ
+diff --git a/fog/im042.png b/fog/im042.png
+new file mode 100644
+index 00000000..f97bb9b3
+Binary files /dev/null and b/fog/im042.png differ
+diff --git a/fog/im043.png b/fog/im043.png
+new file mode 100644
+index 00000000..a1395c31
+Binary files /dev/null and b/fog/im043.png differ
+diff --git a/fog/im044.png b/fog/im044.png
+new file mode 100644
+index 00000000..94bf298c
+Binary files /dev/null and b/fog/im044.png differ
+diff --git a/fog/im045.png b/fog/im045.png
+new file mode 100644
+index 00000000..3a8b7107
+Binary files /dev/null and b/fog/im045.png differ
+diff --git a/fog/im046.png b/fog/im046.png
+new file mode 100644
+index 00000000..014fe5c1
+Binary files /dev/null and b/fog/im046.png differ
+diff --git a/fog/im047.png b/fog/im047.png
+new file mode 100644
+index 00000000..fffeac95
+Binary files /dev/null and b/fog/im047.png differ
+diff --git a/fog/im048.png b/fog/im048.png
+new file mode 100644
+index 00000000..5c735a94
+Binary files /dev/null and b/fog/im048.png differ
+diff --git a/fog/im049.png b/fog/im049.png
+new file mode 100644
+index 00000000..a541ac0a
+Binary files /dev/null and b/fog/im049.png differ
+diff --git a/fog/im050.png b/fog/im050.png
+new file mode 100644
+index 00000000..b7d5385d
+Binary files /dev/null and b/fog/im050.png differ
+diff --git a/fog/im051.png b/fog/im051.png
+new file mode 100644
+index 00000000..228e426c
+Binary files /dev/null and b/fog/im051.png differ
+diff --git a/fog/im052.png b/fog/im052.png
+new file mode 100644
+index 00000000..a2789946
+Binary files /dev/null and b/fog/im052.png differ
+diff --git a/fog/im053.png b/fog/im053.png
+new file mode 100644
+index 00000000..b44abd3a
+Binary files /dev/null and b/fog/im053.png differ
+diff --git a/fog/im054.png b/fog/im054.png
+new file mode 100644
+index 00000000..309cad33
+Binary files /dev/null and b/fog/im054.png differ
+diff --git a/fog/im055.png b/fog/im055.png
+new file mode 100644
+index 00000000..2ea33550
+Binary files /dev/null and b/fog/im055.png differ
+diff --git a/fog/im056.png b/fog/im056.png
+new file mode 100644
+index 00000000..823739f3
+Binary files /dev/null and b/fog/im056.png differ
+diff --git a/fog/im057.png b/fog/im057.png
+new file mode 100644
+index 00000000..767f7547
+Binary files /dev/null and b/fog/im057.png differ
+diff --git a/fog/im058.png b/fog/im058.png
+new file mode 100644
+index 00000000..b20b906f
+Binary files /dev/null and b/fog/im058.png differ
+diff --git a/fog/im059.png b/fog/im059.png
+new file mode 100644
+index 00000000..269db7cb
+Binary files /dev/null and b/fog/im059.png differ
+diff --git a/fog/im060.png b/fog/im060.png
+new file mode 100644
+index 00000000..cb769ccd
+Binary files /dev/null and b/fog/im060.png differ
+diff --git a/fog/im061.png b/fog/im061.png
+new file mode 100644
+index 00000000..ab2d2255
+Binary files /dev/null and b/fog/im061.png differ
+diff --git a/fog/im062.png b/fog/im062.png
+new file mode 100644
+index 00000000..a1be3e57
+Binary files /dev/null and b/fog/im062.png differ
+diff --git a/fog/im063.png b/fog/im063.png
+new file mode 100644
+index 00000000..9f53a10a
+Binary files /dev/null and b/fog/im063.png differ
+diff --git a/fog/im064.png b/fog/im064.png
+new file mode 100644
+index 00000000..665207bc
+Binary files /dev/null and b/fog/im064.png differ
+diff --git a/fog/im065.png b/fog/im065.png
+new file mode 100644
+index 00000000..e9be1283
+Binary files /dev/null and b/fog/im065.png differ
+diff --git a/fog/im066.png b/fog/im066.png
+new file mode 100644
+index 00000000..36dca2ac
+Binary files /dev/null and b/fog/im066.png differ
+diff --git a/fog/im067.png b/fog/im067.png
+new file mode 100644
+index 00000000..b65c6341
+Binary files /dev/null and b/fog/im067.png differ
+diff --git a/fog/im068.png b/fog/im068.png
+new file mode 100644
+index 00000000..269f25de
+Binary files /dev/null and b/fog/im068.png differ
+diff --git a/fog/im069.png b/fog/im069.png
+new file mode 100644
+index 00000000..f0caab0e
+Binary files /dev/null and b/fog/im069.png differ
+diff --git a/fog/im070.png b/fog/im070.png
+new file mode 100644
+index 00000000..d73dab69
+Binary files /dev/null and b/fog/im070.png differ
+diff --git a/fog/im071.png b/fog/im071.png
+new file mode 100644
+index 00000000..a54f8305
+Binary files /dev/null and b/fog/im071.png differ
+diff --git a/fog/im072.png b/fog/im072.png
+new file mode 100644
+index 00000000..2afcf811
+Binary files /dev/null and b/fog/im072.png differ
+diff --git a/fog/im073.png b/fog/im073.png
+new file mode 100644
+index 00000000..6c38c9a8
+Binary files /dev/null and b/fog/im073.png differ
+diff --git a/fog/im074.png b/fog/im074.png
+new file mode 100644
+index 00000000..62071305
+Binary files /dev/null and b/fog/im074.png differ
+diff --git a/fog/im075.png b/fog/im075.png
+new file mode 100644
+index 00000000..2a1027b5
+Binary files /dev/null and b/fog/im075.png differ
+diff --git a/fog/im076.png b/fog/im076.png
+new file mode 100644
+index 00000000..7d4c1133
+Binary files /dev/null and b/fog/im076.png differ
+diff --git a/fog/im077.png b/fog/im077.png
+new file mode 100644
+index 00000000..44872557
+Binary files /dev/null and b/fog/im077.png differ
+diff --git a/fog/im078.png b/fog/im078.png
+new file mode 100644
+index 00000000..12bed522
+Binary files /dev/null and b/fog/im078.png differ
+diff --git a/fog/im079.png b/fog/im079.png
+new file mode 100644
+index 00000000..a3322f62
+Binary files /dev/null and b/fog/im079.png differ
+diff --git a/fog/im080.png b/fog/im080.png
+new file mode 100644
+index 00000000..80337067
+Binary files /dev/null and b/fog/im080.png differ
+diff --git a/fog/im081.png b/fog/im081.png
+new file mode 100644
+index 00000000..5f08f959
+Binary files /dev/null and b/fog/im081.png differ
+diff --git a/fog/im082.png b/fog/im082.png
+new file mode 100644
+index 00000000..a15c0767
+Binary files /dev/null and b/fog/im082.png differ
+diff --git a/fog/im083.png b/fog/im083.png
+new file mode 100644
+index 00000000..4886e766
+Binary files /dev/null and b/fog/im083.png differ
+diff --git a/fog/im084.png b/fog/im084.png
+new file mode 100644
+index 00000000..dd990a1a
+Binary files /dev/null and b/fog/im084.png differ
+diff --git a/fog/im085.png b/fog/im085.png
+new file mode 100644
+index 00000000..f184d515
+Binary files /dev/null and b/fog/im085.png differ
+diff --git a/fog/im086.png b/fog/im086.png
+new file mode 100644
+index 00000000..91a32689
+Binary files /dev/null and b/fog/im086.png differ
+diff --git a/fog/im087.png b/fog/im087.png
+new file mode 100644
+index 00000000..9b402b87
+Binary files /dev/null and b/fog/im087.png differ
+diff --git a/fog/im088.png b/fog/im088.png
+new file mode 100644
+index 00000000..21e7f303
+Binary files /dev/null and b/fog/im088.png differ
+diff --git a/fog/im089.png b/fog/im089.png
+new file mode 100644
+index 00000000..cb76b06a
+Binary files /dev/null and b/fog/im089.png differ
+diff --git a/fog/im090.png b/fog/im090.png
+new file mode 100644
+index 00000000..781fd24b
+Binary files /dev/null and b/fog/im090.png differ
+diff --git a/fog/im091.png b/fog/im091.png
+new file mode 100644
+index 00000000..94242d2e
+Binary files /dev/null and b/fog/im091.png differ
+diff --git a/fog/im092.png b/fog/im092.png
+new file mode 100644
+index 00000000..18d95442
+Binary files /dev/null and b/fog/im092.png differ
+diff --git a/fog/im093.png b/fog/im093.png
+new file mode 100644
+index 00000000..8d61120a
+Binary files /dev/null and b/fog/im093.png differ
+diff --git a/fog/im094.png b/fog/im094.png
+new file mode 100644
+index 00000000..ae386b22
+Binary files /dev/null and b/fog/im094.png differ
+diff --git a/fog/im095.png b/fog/im095.png
+new file mode 100644
+index 00000000..3a0fefaf
+Binary files /dev/null and b/fog/im095.png differ
+diff --git a/fog/im096.png b/fog/im096.png
+new file mode 100644
+index 00000000..1a9bffb8
+Binary files /dev/null and b/fog/im096.png differ
+diff --git a/fog/im097.png b/fog/im097.png
+new file mode 100644
+index 00000000..3a0fefaf
+Binary files /dev/null and b/fog/im097.png differ
+diff --git a/fog/im098.png b/fog/im098.png
+new file mode 100644
+index 00000000..ae386b22
+Binary files /dev/null and b/fog/im098.png differ
+diff --git a/fog/im099.png b/fog/im099.png
+new file mode 100644
+index 00000000..8d61120a
+Binary files /dev/null and b/fog/im099.png differ
+diff --git a/fog/im100.png b/fog/im100.png
+new file mode 100644
+index 00000000..18d95442
+Binary files /dev/null and b/fog/im100.png differ
+diff --git a/fog/im101.png b/fog/im101.png
+new file mode 100644
+index 00000000..94242d2e
+Binary files /dev/null and b/fog/im101.png differ
+diff --git a/fog/im102.png b/fog/im102.png
+new file mode 100644
+index 00000000..781fd24b
+Binary files /dev/null and b/fog/im102.png differ
+diff --git a/fog/im103.png b/fog/im103.png
+new file mode 100644
+index 00000000..cb76b06a
+Binary files /dev/null and b/fog/im103.png differ
+diff --git a/fog/im104.png b/fog/im104.png
+new file mode 100644
+index 00000000..21e7f303
+Binary files /dev/null and b/fog/im104.png differ
+diff --git a/fog/im105.png b/fog/im105.png
+new file mode 100644
+index 00000000..9b402b87
+Binary files /dev/null and b/fog/im105.png differ
+diff --git a/fog/im106.png b/fog/im106.png
+new file mode 100644
+index 00000000..91a32689
+Binary files /dev/null and b/fog/im106.png differ
+diff --git a/fog/im107.png b/fog/im107.png
+new file mode 100644
+index 00000000..f184d515
+Binary files /dev/null and b/fog/im107.png differ
+diff --git a/fog/im108.png b/fog/im108.png
+new file mode 100644
+index 00000000..dd990a1a
+Binary files /dev/null and b/fog/im108.png differ
+diff --git a/fog/im109.png b/fog/im109.png
+new file mode 100644
+index 00000000..4886e766
+Binary files /dev/null and b/fog/im109.png differ
+diff --git a/fog/im110.png b/fog/im110.png
+new file mode 100644
+index 00000000..a15c0767
+Binary files /dev/null and b/fog/im110.png differ
+diff --git a/fog/im111.png b/fog/im111.png
+new file mode 100644
+index 00000000..5f08f959
+Binary files /dev/null and b/fog/im111.png differ
+diff --git a/fog/im112.png b/fog/im112.png
+new file mode 100644
+index 00000000..80337067
+Binary files /dev/null and b/fog/im112.png differ
+diff --git a/fog/im113.png b/fog/im113.png
+new file mode 100644
+index 00000000..a3322f62
+Binary files /dev/null and b/fog/im113.png differ
+diff --git a/fog/im114.png b/fog/im114.png
+new file mode 100644
+index 00000000..12bed522
+Binary files /dev/null and b/fog/im114.png differ
+diff --git a/fog/im115.png b/fog/im115.png
+new file mode 100644
+index 00000000..44872557
+Binary files /dev/null and b/fog/im115.png differ
+diff --git a/fog/im116.png b/fog/im116.png
+new file mode 100644
+index 00000000..7d4c1133
+Binary files /dev/null and b/fog/im116.png differ
+diff --git a/fog/im117.png b/fog/im117.png
+new file mode 100644
+index 00000000..2a1027b5
+Binary files /dev/null and b/fog/im117.png differ
+diff --git a/fog/im118.png b/fog/im118.png
+new file mode 100644
+index 00000000..62071305
+Binary files /dev/null and b/fog/im118.png differ
+diff --git a/fog/im119.png b/fog/im119.png
+new file mode 100644
+index 00000000..6c38c9a8
+Binary files /dev/null and b/fog/im119.png differ
+diff --git a/fog/im120.png b/fog/im120.png
+new file mode 100644
+index 00000000..2afcf811
+Binary files /dev/null and b/fog/im120.png differ
+diff --git a/fog/im121.png b/fog/im121.png
+new file mode 100644
+index 00000000..a54f8305
+Binary files /dev/null and b/fog/im121.png differ
+diff --git a/fog/im122.png b/fog/im122.png
+new file mode 100644
+index 00000000..d73dab69
+Binary files /dev/null and b/fog/im122.png differ
+diff --git a/fog/im123.png b/fog/im123.png
+new file mode 100644
+index 00000000..f0caab0e
+Binary files /dev/null and b/fog/im123.png differ
+diff --git a/fog/im124.png b/fog/im124.png
+new file mode 100644
+index 00000000..269f25de
+Binary files /dev/null and b/fog/im124.png differ
+diff --git a/fog/im125.png b/fog/im125.png
+new file mode 100644
+index 00000000..b65c6341
+Binary files /dev/null and b/fog/im125.png differ
+diff --git a/fog/im126.png b/fog/im126.png
+new file mode 100644
+index 00000000..36dca2ac
+Binary files /dev/null and b/fog/im126.png differ
+diff --git a/fog/im127.png b/fog/im127.png
+new file mode 100644
+index 00000000..e9be1283
+Binary files /dev/null and b/fog/im127.png differ
+diff --git a/fog/im128.png b/fog/im128.png
+new file mode 100644
+index 00000000..665207bc
+Binary files /dev/null and b/fog/im128.png differ
+diff --git a/fog/im129.png b/fog/im129.png
+new file mode 100644
+index 00000000..9f53a10a
+Binary files /dev/null and b/fog/im129.png differ
+diff --git a/fog/im130.png b/fog/im130.png
+new file mode 100644
+index 00000000..a1be3e57
+Binary files /dev/null and b/fog/im130.png differ
+diff --git a/fog/im131.png b/fog/im131.png
+new file mode 100644
+index 00000000..ab2d2255
+Binary files /dev/null and b/fog/im131.png differ
+diff --git a/fog/im132.png b/fog/im132.png
+new file mode 100644
+index 00000000..cb769ccd
+Binary files /dev/null and b/fog/im132.png differ
+diff --git a/fog/im133.png b/fog/im133.png
+new file mode 100644
+index 00000000..269db7cb
+Binary files /dev/null and b/fog/im133.png differ
+diff --git a/fog/im134.png b/fog/im134.png
+new file mode 100644
+index 00000000..b20b906f
+Binary files /dev/null and b/fog/im134.png differ
+diff --git a/fog/im135.png b/fog/im135.png
+new file mode 100644
+index 00000000..767f7547
+Binary files /dev/null and b/fog/im135.png differ
+diff --git a/fog/im136.png b/fog/im136.png
+new file mode 100644
+index 00000000..823739f3
+Binary files /dev/null and b/fog/im136.png differ
+diff --git a/fog/im137.png b/fog/im137.png
+new file mode 100644
+index 00000000..2ea33550
+Binary files /dev/null and b/fog/im137.png differ
+diff --git a/fog/im138.png b/fog/im138.png
+new file mode 100644
+index 00000000..309cad33
+Binary files /dev/null and b/fog/im138.png differ
+diff --git a/fog/im139.png b/fog/im139.png
+new file mode 100644
+index 00000000..b44abd3a
+Binary files /dev/null and b/fog/im139.png differ
+diff --git a/fog/im140.png b/fog/im140.png
+new file mode 100644
+index 00000000..a2789946
+Binary files /dev/null and b/fog/im140.png differ
+diff --git a/fog/im141.png b/fog/im141.png
+new file mode 100644
+index 00000000..228e426c
+Binary files /dev/null and b/fog/im141.png differ
+diff --git a/fog/im142.png b/fog/im142.png
+new file mode 100644
+index 00000000..b7d5385d
+Binary files /dev/null and b/fog/im142.png differ
+diff --git a/fog/im143.png b/fog/im143.png
+new file mode 100644
+index 00000000..a541ac0a
+Binary files /dev/null and b/fog/im143.png differ
+diff --git a/fog/im144.png b/fog/im144.png
+new file mode 100644
+index 00000000..5c735a94
+Binary files /dev/null and b/fog/im144.png differ
+diff --git a/fog/im145.png b/fog/im145.png
+new file mode 100644
+index 00000000..fffeac95
+Binary files /dev/null and b/fog/im145.png differ
+diff --git a/fog/im146.png b/fog/im146.png
+new file mode 100644
+index 00000000..014fe5c1
+Binary files /dev/null and b/fog/im146.png differ
+diff --git a/fog/im147.png b/fog/im147.png
+new file mode 100644
+index 00000000..3a8b7107
+Binary files /dev/null and b/fog/im147.png differ
+diff --git a/fog/im148.png b/fog/im148.png
+new file mode 100644
+index 00000000..94bf298c
+Binary files /dev/null and b/fog/im148.png differ
+diff --git a/fog/im149.png b/fog/im149.png
+new file mode 100644
+index 00000000..a1395c31
+Binary files /dev/null and b/fog/im149.png differ
+diff --git a/fog/im150.png b/fog/im150.png
+new file mode 100644
+index 00000000..f97bb9b3
+Binary files /dev/null and b/fog/im150.png differ
+diff --git a/fog/im151.png b/fog/im151.png
+new file mode 100644
+index 00000000..a42f03c3
+Binary files /dev/null and b/fog/im151.png differ
+diff --git a/fog/im152.png b/fog/im152.png
+new file mode 100644
+index 00000000..7af32cc3
+Binary files /dev/null and b/fog/im152.png differ
+diff --git a/fog/im153.png b/fog/im153.png
+new file mode 100644
+index 00000000..55adcc34
+Binary files /dev/null and b/fog/im153.png differ
+diff --git a/fog/im154.png b/fog/im154.png
+new file mode 100644
+index 00000000..a8a73b28
+Binary files /dev/null and b/fog/im154.png differ
+diff --git a/fog/im155.png b/fog/im155.png
+new file mode 100644
+index 00000000..c7173c86
+Binary files /dev/null and b/fog/im155.png differ
+diff --git a/fog/im156.png b/fog/im156.png
+new file mode 100644
+index 00000000..6250c91e
+Binary files /dev/null and b/fog/im156.png differ
+diff --git a/fog/im157.png b/fog/im157.png
+new file mode 100644
+index 00000000..ae6c2abd
+Binary files /dev/null and b/fog/im157.png differ
+diff --git a/fog/im158.png b/fog/im158.png
+new file mode 100644
+index 00000000..ed1ec2a8
+Binary files /dev/null and b/fog/im158.png differ
+diff --git a/fog/im159.png b/fog/im159.png
+new file mode 100644
+index 00000000..e1067a52
+Binary files /dev/null and b/fog/im159.png differ
+diff --git a/fog/im160.png b/fog/im160.png
+new file mode 100644
+index 00000000..d990f7ef
+Binary files /dev/null and b/fog/im160.png differ
+diff --git a/fog/im161.png b/fog/im161.png
+new file mode 100644
+index 00000000..1ff46897
+Binary files /dev/null and b/fog/im161.png differ
+diff --git a/fog/im162.png b/fog/im162.png
+new file mode 100644
+index 00000000..9a276cfa
+Binary files /dev/null and b/fog/im162.png differ
+diff --git a/fog/im163.png b/fog/im163.png
+new file mode 100644
+index 00000000..639b8fe3
+Binary files /dev/null and b/fog/im163.png differ
+diff --git a/fog/im164.png b/fog/im164.png
+new file mode 100644
+index 00000000..ebe50e50
+Binary files /dev/null and b/fog/im164.png differ
+diff --git a/fog/im165.png b/fog/im165.png
+new file mode 100644
+index 00000000..c1e193ca
+Binary files /dev/null and b/fog/im165.png differ
+diff --git a/fog/im166.png b/fog/im166.png
+new file mode 100644
+index 00000000..6d4e5860
+Binary files /dev/null and b/fog/im166.png differ
+diff --git a/fog/im167.png b/fog/im167.png
+new file mode 100644
+index 00000000..1738ea29
+Binary files /dev/null and b/fog/im167.png differ
+diff --git a/fog/im168.png b/fog/im168.png
+new file mode 100644
+index 00000000..40d7212e
+Binary files /dev/null and b/fog/im168.png differ
+diff --git a/fog/im169.png b/fog/im169.png
+new file mode 100644
+index 00000000..0a7b84e7
+Binary files /dev/null and b/fog/im169.png differ
+diff --git a/fog/im170.png b/fog/im170.png
+new file mode 100644
+index 00000000..bc49e733
+Binary files /dev/null and b/fog/im170.png differ
+diff --git a/fog/im171.png b/fog/im171.png
+new file mode 100644
+index 00000000..e6d907e6
+Binary files /dev/null and b/fog/im171.png differ
+diff --git a/fog/im172.png b/fog/im172.png
+new file mode 100644
+index 00000000..a358a833
+Binary files /dev/null and b/fog/im172.png differ
+diff --git a/fog/im173.png b/fog/im173.png
+new file mode 100644
+index 00000000..99a9cd6e
+Binary files /dev/null and b/fog/im173.png differ
+diff --git a/fog/im174.png b/fog/im174.png
+new file mode 100644
+index 00000000..4419a31c
+Binary files /dev/null and b/fog/im174.png differ
+diff --git a/fog/im175.png b/fog/im175.png
+new file mode 100644
+index 00000000..ce3b5158
+Binary files /dev/null and b/fog/im175.png differ
+diff --git a/fog/im176.png b/fog/im176.png
+new file mode 100644
+index 00000000..ccdc0aa2
+Binary files /dev/null and b/fog/im176.png differ
+diff --git a/fog/im177.png b/fog/im177.png
+new file mode 100644
+index 00000000..b086780c
+Binary files /dev/null and b/fog/im177.png differ
+diff --git a/fog/im178.png b/fog/im178.png
+new file mode 100644
+index 00000000..3eed8f3a
+Binary files /dev/null and b/fog/im178.png differ
+diff --git a/fog/im179.png b/fog/im179.png
+new file mode 100644
+index 00000000..5b648052
+Binary files /dev/null and b/fog/im179.png differ
+diff --git a/fog/im180.png b/fog/im180.png
+new file mode 100644
+index 00000000..bc2a1fa5
+Binary files /dev/null and b/fog/im180.png differ
+diff --git a/fog/im181.png b/fog/im181.png
+new file mode 100644
+index 00000000..7f3196b5
+Binary files /dev/null and b/fog/im181.png differ
+diff --git a/fog/im182.png b/fog/im182.png
+new file mode 100644
+index 00000000..76d81328
+Binary files /dev/null and b/fog/im182.png differ
+diff --git a/fog/im183.png b/fog/im183.png
+new file mode 100644
+index 00000000..5d2c07fa
+Binary files /dev/null and b/fog/im183.png differ
+diff --git a/fog/im184.png b/fog/im184.png
+new file mode 100644
+index 00000000..555ca94c
+Binary files /dev/null and b/fog/im184.png differ
+diff --git a/fog/im185.png b/fog/im185.png
+new file mode 100644
+index 00000000..040b2cf6
+Binary files /dev/null and b/fog/im185.png differ
+diff --git a/fog/im186.png b/fog/im186.png
+new file mode 100644
+index 00000000..f1c2d8ce
+Binary files /dev/null and b/fog/im186.png differ
+diff --git a/fog/im187.png b/fog/im187.png
+new file mode 100644
+index 00000000..aab40938
+Binary files /dev/null and b/fog/im187.png differ
+diff --git a/fog/im188.png b/fog/im188.png
+new file mode 100644
+index 00000000..db9d6dd4
+Binary files /dev/null and b/fog/im188.png differ
+diff --git a/fog/im189.png b/fog/im189.png
+new file mode 100644
+index 00000000..beb4977f
+Binary files /dev/null and b/fog/im189.png differ
+diff --git a/fog/im190.png b/fog/im190.png
+new file mode 100644
+index 00000000..06a4cfa7
+Binary files /dev/null and b/fog/im190.png differ
+diff --git a/fog/im191.png b/fog/im191.png
+new file mode 100644
+index 00000000..25c6fa68
+Binary files /dev/null and b/fog/im191.png differ
+diff --git a/resources/fonts/Small.idx b/resources/fonts/Small.idx
+deleted file mode 100644
+index 7c80fe60..00000000
+--- a/resources/fonts/Small.idx
++++ /dev/null
+@@ -1,159 +0,0 @@
+-width       8
+-height      16
+-0   0   6   7
+-1   1   6   7
+-2   2   6   7
+-3   3   6   7
+-4   4   6   7
+-5   5   6   7
+-6   6   6   7
+-7   7   6   7
+-8   8   6   7
+-9   9   6   7
+-A   0   1   5
+-B   1   1   5
+-C   2   1   5
+-D   3   1   5
+-E   4   1   5
+-F   5   1   5
+-G   6   1   6
+-H   7   1   5
+-I   8   1   4
+-J   9   1   6
+-K   10   1   6
+-L   11   1   4
+-M   12   1   6
+-N   13   1   6
+-O   14   1   6
+-P   15   1   5
+-Q   16   1   7
+-R   17   1   5
+-S   18   1   5
+-T   19   1   6
+-U   20   1   6
+-V   21   1   6
+-W   22   1   7
+-X   23   1   8
+-Y   24   1   6
+-Z   25   1   6
+-a   0   0   6
+-b   1   0   5
+-c   2   0   5
+-d   3   0   5
+-e   4   0   5
+-f   5   0   4
+-g   6   0   6
+-h   7   0   5
+-i   8   0   2
+-j   9   0   4
+-k   10   0   5
+-l   11   0   2
+-m   12   0   6
+-n   13   0   5
+-o   14   0   5
+-p   15   0   5
+-q   16   0   5
+-r   17   0   4
+-s   18   0   5
+-t   19   0   4
+-u   20   0   5
+-v   21   0   6
+-w   22   0   6
+-x   23   0   6
+-y   24   0   5
+-z   25   0   5
+-á   0   2   6      
+-à   1   2   6
+-â   2   2   6
+-å   3   2   6
+-ä   4   2   6
+-é   5   2   5
+-è   6   2   5
+-ê   7   2   5
+-ë   8   2   5
+-í   9    2   3
+-ì   10   2   3
+-î   11   2   3
+-ï   12   2   3
+-ó   14   2   5
+-ò   15   2   5
+-ô   16   2   5
+-ö   17   2   5
+-ø   18   2   6
+-ú   20   2   5
+-ù   21   2   5
+-û   22   2   5
+-ü   23   2   5
+-ý   24   2   5
+-ÿ   25   2   5
+-æ   26   2   8   
+-Á   0   3   5
+-À   1   3   5
+-Â   2   3   6
+-Ä   4   3   6
+-Å   3   3   6
+-É   5   3   5
+-È   6   3   5
+-Ê   7   3   5
+-Ë   8   3   5
+-Í   9   3   4
+-Ì   10   3   4
+-Î   11   3   4
+-Ï   12   3   4
+-Ó   14   3   6
+-Ò   15   3   6
+-Ô   16   3   7
+-Ö   17   3   7
+-Ø   18   3   7   
+-Ú   20   3   6
+-Ù   21   3   6
+-Û   22   3   7
+-Ü   23   3   7
+-Ý   24   3   6
+-Ÿ   25   3   6
+-Æ   26   3   8
+-ç   2   4   5
+-ð   3   4   6
+-ñ   12   4   5
+-ŋ   13   4   5
+-þ   15   4   5
+-ß   18   4   6
+-ƿ   22   4   5
+-œ   26   4   8
+-Ç   2   5   5
+-Ð   3   5   6
+-Ñ   12   5   6
+-Þ   15   5   5
+-⁊   18   5   5
+-Ƿ   22   5   5
+-Œ   26   5   8
+-!   13   6   3
+-¡   26   1   3
+-#   22   6   7
+-&   23   6   7
+-(   14   6   4
+-)   15   6   4
+--   16   6   7
+-+   26   6   7
+-\   18   6   6
+-;   20   6   2
+-:   21   6   2
+-'   25   6   3
+-,   11   6   2
+-.   10   6   2
+-/   17   6   6
+-?   19   6   7
+-¿   26   0   7
+-space 27 1   4
+-"   24   6   4
+-<   11   7   8
+->   21   7   8
+-$   12   6   8
+-{   7   7   8
+-}   15   7   8
+-~   0   7   8
+-`   1   7   8
+-@   2   7   8
+-^   3   7   8
+-*   4   7   8
+-%   18  7   8
+\ No newline at end of file
+diff --git a/resources/fonts/runes-white.png b/resources/fonts/runes-white.png
+new file mode 100644
+index 00000000..a34361a1
+Binary files /dev/null and b/resources/fonts/runes-white.png differ
+diff --git a/resources/fonts/runes.idx b/resources/fonts/runes.idx
+new file mode 100644
+index 00000000..39ac0c7d
+--- /dev/null
++++ b/resources/fonts/runes.idx
+@@ -0,0 +1,71 @@
++width       8
++height      16
++0   0   2   7
++1   1   2   7
++2   2   2   7
++3   3   2   7
++4   4   2   7
++5   5   2   7
++6   6   2   7
++7   7   2   7
++8   8   2   7
++9   9   2   7
++A   0   0   6
++Á   1   0   6
++E   2   0   6
++É   3   0   6
++I   4   0   3
++Í   5   0   6
++O   6   0   6
++Ó   7   0   6
++U   8   0   6
++Ú   9   0   6
++Ö   10   0   6
++Ï   11   0   6
++Ü   12   0   6
++Ä   13   0   6
++B   0   1   5
++D   1   1   6
++F   2   1   5
++G   3   1   5
++H   4   1   5
++J   5   1   6
++K   6   1   5
++L   7   1   5
++M   8   1   6
++N   9   1   6
++P   10   1   5
++R   11   1   6
++S   12   1   6
++T   13   1   5
++V   14   1   5
++W   15   1   6
++Y   16   1   5
++Z   17   1   6
++C   18   1   6
++Ç   19   1   5
++Þ   20   1   5
++X   21   1   6
++Ë   22   1   5
++!   13   2   3
++¡   26   1   3
++#   22   2   7
++&   16   0   7
++<   27   1   6
++>   27   0   6   
++(   14   2   4
++)   15   2   4
++-   16   2   6
+++   26   2   7
++\   18   2   6
++;   20   2   2
++:   21   2   2
++'   25   2   3
++,   11   2   2
++.   10   2   2
++/   17   2   6
++?   19   2   7
++¿   26   2   7
++space 25 0   4
++"   24   2   4
++_   27   2   7
+\ No newline at end of file
+diff --git a/resources/fonts/small-white.png b/resources/fonts/small-white.png
+index 99e84d3f..49a7e7b2 100644
+Binary files a/resources/fonts/small-white.png and b/resources/fonts/small-white.png differ
+diff --git a/resources/fonts/small.idx b/resources/fonts/small.idx
+index 7c80fe60..b6edfa7b 100644
+--- a/resources/fonts/small.idx
++++ b/resources/fonts/small.idx
+@@ -14,21 +14,21 @@ A   0   1   5
+ B   1   1   5
+ C   2   1   5
+ D   3   1   5
+-E   4   1   5
++E   4   1   4
+ F   5   1   5
+ G   6   1   6
+ H   7   1   5
+ I   8   1   4
+ J   9   1   6
+-K   10   1   6
++K   10   1   5
+ L   11   1   4
+ M   12   1   6
+ N   13   1   6
+-O   14   1   6
++O   14   1   5
+ P   15   1   5
+ Q   16   1   7
+ R   17   1   5
+-S   18   1   5
++S   18   1   4
+ T   19   1   6
+ U   20   1   6
+ V   21   1   6
+diff --git a/run_engine.py b/run_engine.py
+index 30f917b7..1839b03d 100644
+--- a/run_engine.py
++++ b/run_engine.py
+@@ -53,10 +53,10 @@ if __name__ == '__main__':
+         source_generator.generate_component_system_source()
+ 
+     try:
+-        find_and_run_project()
++        # find_and_run_project()
+         # main('lion_throne')
+         # test_play('lion_throne')
+-        # test_play('sacred_stones')
++        test_play('sacred_stones')
+     except Exception as e:
+         logging.exception(e)
+         inform_error()
+diff --git a/sacred_stones.ltproj/game_data/skills.json b/sacred_stones.ltproj/game_data/skills.json
+index 4b7372d1..b31522e0 100644
+--- a/sacred_stones.ltproj/game_data/skills.json
++++ b/sacred_stones.ltproj/game_data/skills.json
+@@ -1078,6 +1078,26 @@
+             ]
+         ]
+     },
++    {
++        "nid": "Mana Eater",
++        "name": "Mana Eater",
++        "desc": "",
++        "icon_nid": "Skills",
++        "icon_index": [
++            10,
++            8
++        ],
++        "components": [
++            [
++                "global",
++                null
++            ],
++            [
++                "mana_on_kill",
++                5
++            ]
++        ]
++    },
+     {
+         "nid": "Live to Serve",
+         "name": "Live to Serve",
+diff --git a/sacred_stones.ltproj/metadata.json b/sacred_stones.ltproj/metadata.json
+index 7ac76966..7726ccce 100644
+--- a/sacred_stones.ltproj/metadata.json
++++ b/sacred_stones.ltproj/metadata.json
+@@ -1,5 +1,5 @@
+ {
+-    "date": "2021-10-04 19:29:28.945600",
++    "date": "2021-09-28 19:29:47.017515",
+     "version": "2021.09.15b",
+     "project": "SS"
+ }
+\ No newline at end of file
+diff --git a/sacred_stones.ltproj/resources/tilemaps/tilemap.json b/sacred_stones.ltproj/resources/tilemaps/tilemap.json
+index e0599842..71936fde 100644
+--- a/sacred_stones.ltproj/resources/tilemaps/tilemap.json
++++ b/sacred_stones.ltproj/resources/tilemaps/tilemap.json
+@@ -2444,7 +2444,7 @@
+     {
+         "nid": "Chapter 2",
+         "size": [
+-            15,
++            17,
+             15
+         ],
+         "autotile_fps": 29,
+@@ -4254,6 +4254,216 @@
+                             14,
+                             8
+                         ]
++                    ],
++                    "15,0": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,1": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,2": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,3": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,4": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,5": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,6": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,7": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,8": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,9": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,10": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,11": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,12": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,13": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "15,14": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,0": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,1": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,2": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,3": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,4": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,5": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,6": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,7": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,8": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,9": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,10": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,11": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,12": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,13": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
++                    ],
++                    "16,14": [
++                        "Chpt2",
++                        [
++                            0,
++                            5
++                        ]
+                     ]
+                 }
+             },
+diff --git a/sprites/info_menu/info_menu_background.png b/sprites/info_menu/info_menu_background.png
+new file mode 100644
+index 00000000..6c1f5df8
+Binary files /dev/null and b/sprites/info_menu/info_menu_background.png differ
+diff --git a/sprites/info_menu/stat_screen_background.png b/sprites/info_menu/stat_screen_background.png
+new file mode 100644
+index 00000000..4da73a5c
+Binary files /dev/null and b/sprites/info_menu/stat_screen_background.png differ
+diff --git a/sprites/info_menu/stat_screen_background_old.png b/sprites/info_menu/stat_screen_background_old.png
+new file mode 100644
+index 00000000..a4f7d0ac
+Binary files /dev/null and b/sprites/info_menu/stat_screen_background_old.png differ
+diff --git a/sprites/info_menu/stat_screen_background_v1.png b/sprites/info_menu/stat_screen_background_v1.png
+new file mode 100644
+index 00000000..4c4e72c8
+Binary files /dev/null and b/sprites/info_menu/stat_screen_background_v1.png differ
+diff --git a/sprites/particles/particle_fog_mote.png b/sprites/particles/particle_fog_mote.png
+new file mode 100644
+index 00000000..b1a02bbd
+Binary files /dev/null and b/sprites/particles/particle_fog_mote.png differ
+diff --git a/utilities/class_data.txt b/utilities/class_data.txt
+new file mode 100644
+index 00000000..f9e849c7
+--- /dev/null
++++ b/utilities/class_data.txt
+@@ -0,0 +1,73 @@
++POW: Low: 3 35% High: 7 70%
++Dagger users get +2 base
++Sword users get +3 base
++Bow users get +4 base
++Lance users get +5 base
++Greatsword users get +6 base
++1. Peg Knight, Thief (3, 35%)
++2. Skirmisher, Hunter (4, 40%)
++3. Myrmidon, Nomad (4, 45%)
++4. Cavalier, Errant, Soldier (5, 50%)
++5. Archer, Mercenary (5, 55%)
++6. Raider, Armor (6, 60%)
++7. Knight, Wyvern (6, 65%)
++8. Fighter, Brigand (7, 70%)
++
++DEF: Low: 0 15% High: 6 55%
++1. Thief (1, 15%)
++2. Peg Knight, Hunter, Nomad, Myrmidon, Brigand (1, 20%)
++3. Raider, Skirmisher (2, 25%)
++4. Cavalier, Mercenary, Archer, Soldier (3, 30%)
++5. Fighter (2, 35%)
++5. Errant (4, 35%)
++6. Wyvern, Knight (5, 45%)
++7. Armor (6, 55%)
++
++HP: Low: 16 65% High: 24 120%
++1. Thief (16, 65%)
++2. Peg Knight (16, 80%)
++3. Hunter, Skirmisher (17, 85%)
++4. Archer, Myrmidon, Soldier (18, 95%)
++5. Cavalier, Nomad, Armor (20, 100%)
++6. Wyvern, Mercenary, Errant (22, 105%)
++7. Fighter, Knight (24, 110%)
++8. Raider, Brigand (24, 120%)
++
++SKL: Low 3 35% High: 7 60%
++Dagger users get +5 base
++Sword users get +5 base
++Bow users get +4 base
++Lance users get +2 base
++Greatsword users get +0 base
++1. Brigand (2, 30%)
++1. Fighter (3, 35%)
++2. Errant, Raider (4, 40%)
++3. Wyvern Rider, Knight, Nomad (4, 45%)
++4. Cavalier, Thief (5, 45%)
++5. Peg Knight, Skirmisher, Hunter (6, 50%)
++6. Archer, Soldier (6, 55%)
++6. Armor (7, 55%)
++7. Myrmidon, Mercenary (7, 60%)
++
++SPD: Low 1 25% High: 8 70%
++1. Armor (1, 20%)
++1. Knight (2, 25%)
++2. Wyvern Rider, Fighter, Soldier, Brigand (3, 35%)
++3. Archer (3, 40%)
++4. Cavalier, Mercenary (4, 45%)
++5. Raider, Nomad, Errant (5, 50%)
++6. Myrmidon, Hunter (7, 60%)
++7. Skirmisher (7, 65%)
++8. Thief (8, 65%)
++8. Peg Knight (8, 70%)
++
++BRV: Low 3 35% High: 7 60%
++1. Armor (1, 20%)
++2. Thief, Soldier, Brigand (2, 30%)
++2. Archer (3, 35%)
++3. Cavalier, Wyvern Rider (4, 40%)
++4. Fighter, Knight (5, 45%)
++5. Mercenary, Hunter, Raider, Nomad, Errant (6, 50%)
++6. Myrmidon (8, 55%)
++7. Skirmisher (9, 65%)
++8. Peg Knight (10, 70%)
+\ No newline at end of file
+diff --git a/utilities/memento_mori_todo.txt b/utilities/memento_mori_todo.txt
+new file mode 100644
+index 00000000..dc716770
+--- /dev/null
++++ b/utilities/memento_mori_todo.txt
+@@ -0,0 +1,74 @@
++Enemies:
++Thieves
++Skirmishers
++Brigands
++Mercenaries
++Hunter
++Mage?
++
++Goals:
++
++Open treasure chests
++Save Civilians
++Recruit Skirmisher/Thief Girl (Piper?)
++Recruit Millie
++
++For vertical slice
++Chapter 3 and 4
++Alternate forms of Chapter 3 and 4
++Overworld
++Implement Skills
++Write Script
++How does pair up work?
++    - Adjacent units can lend an attack, dealing half their normal damage
++    - Higher support bonuses grant stat buffs (or maybe by default and class or stat based?)
++    - Higher support bonuses grant chance to block or limit an attack (crit -> hit, hit -> glance, glance -> miss?)??
++Combat UI
++ - Unit who is talking gets nametag
++Implement Wyllt
++No Free Roam Base:
++    - Instead, after every 3rd chapter, forced free roam "dream" sequence where you can talk to each character in the party, and perhaps even dead characters.
++    - You can also get items and even find items.
++    - Certain choices you make in the free roam section can change things up
++    - Then you wake up back in the overworld map
++Dream conversations
++Title Screen
++Portraits
++Personal Skills / Grave Weapons
++ - Tile bonuses
++    - Forest (+3 SKL, +3 SPD)
++    - Hill (+1 POW, +2 BRV)
++    - Mountain (+2 POW, +3 BRV)
++    - River (-3 SPD, -1 DEF)
++    - Pillar (+3 SPD)
++    - Fort (+3 DEF))
++    - Plain (no bonus)
++    - Sand (no bonus)
++    - Snow (no bonus)
++    - Stairs (-2 SPD)
++Playtest playtest playtest
++
++Portraits:
++Ash (M) Pale skin, dark colors
++Pale (F) Dark skin, white hair, nature wild girl mystical waif aesthetic
++Cedric (M) Blond hair
++Aelfred (M) Red hair
++Ceabbi (F) Blond hair
++Ceathrun (F) Blond hair
++Magnus (M) Blue hair
++Istrid (F) Witch, Purple hair
++Tristan (M) Ophie 
++Isolde (F) Green hair
++---
++Aelfwynn (F) Red hair
++Eadan (M) Green hair
++Bjorn (M) Blond hair
++Millie (F) Blue hair
++Anna (F) Orange hair
++Willow (F) Black hair
++Wound (Dog)
++Sorrel (M) Dark skin, brown hair
++Clover (F) Dark skin, brown hair
++Rhun (M) Amber hair
++*Piper (F) Dark skin, purple hair?
++*Rhodri (M) Amber hair, strong lad
+diff --git a/utilities/testing_stats_v2.py b/utilities/testing_stats_v2.py
+index 5ad4948c..7dec1c70 100644
+--- a/utilities/testing_stats_v2.py
++++ b/utilities/testing_stats_v2.py
+@@ -12,31 +12,98 @@ class Character():
+     BRV: int = 0
+     DEF: int = 0
+ 
+-myrm = Character('Myrmidon', 5, 19, 11, 17, 13, 12, 2)
+-fighter = Character('Fighter', 5, 29, 19, 9, 7, 6, 2)
+-knight = Character('Knight', 5, 24, 15, 16, 4, 3, 8)
+-merc = Character('Mercenary', 5, 26, 14, 18, 9, 9, 3)
+-cavalier = Character('Cavalier', 5, 23, 14, 13, 8, 7, 3)
+-peg_knight = Character('Peg Knight', 5, 17, 10, 15, 14, 11, 1)
+-wyvern_knight = Character('Wyvern', 5, 27, 18, 12, 6, 8, 6)
+-thief = Character('Thief', 5, 17, 9, 14, 15, 8, 1)
+-soldier = Character('Soldier', 5, 20, 14, 15, 5, 1, 3)
+-brigand = Character('Brigand', 5, 30, 18, 8, 6, 9, 0)
+-lord = Character('Lord', 5, 25, 13, 15, 10, 10, 3)
++@dataclass
++class Growths():
++    name: str = ''
++    HP: float = 0
++    POW: float = 0
++    SKL: float = 0
++    SPD: float = 0
++    BRV: float = 0
++    DEF: float = 0
++
++def sum_stats(char):
++    return char.HP // 2 + char.POW + char.SKL + char.SPD + char.BRV + char.DEF
++
++def create_char(char: Character, growths: Growths, lvl: int):
++    new_char = Character(char.name, lvl)
++    increase = lvl - char.LVL
++    offset = 50 if increase > 0 else -50
++    new_char.HP = char.HP + int((growths.HP * increase + offset) / 100)
++    new_char.POW = char.POW + int((growths.POW * increase + offset) / 100)
++    new_char.SKL = char.SKL + int((growths.SKL * increase + offset) / 100)
++    new_char.SPD = char.SPD + int((growths.SPD * increase + offset) / 100)
++    new_char.BRV = char.BRV + int((growths.BRV * increase + offset) / 100)
++    new_char.DEF = char.DEF + int((growths.DEF * increase + offset) / 100)
++    return new_char
++
++myrm = Character('Myrmidon', 1, 19, 10, 15, 11, 11, 2)
++fighter = Character('Fighter', 1, 29, 15, 6, 5, 7, 3)
++armor = Character('Armor', 1, 24, 13, 14, 2, 2, 8)
++merc = Character('Mercenary', 1, 26, 12, 16, 7, 8, 3)
++cavalier = Character('Cavalier', 1, 23, 12, 11, 6, 5, 5)
++peg_knight = Character('Peg Knight', 1, 17, 9, 13, 11, 10, 1)
++wyvern_knight = Character('Wyvern', 1, 27, 14, 10, 4, 6, 7)
++nomad = Character('Nomad', 1, 23, 12, 11, 6, 5, 5)
++thief = Character('Thief', 1, 17, 8, 12, 12, 7, 1)
++skirm = Character('Skirmisher', 1, 17, 8, 12, 12, 7, 1)
++errant = Character('Errant', 1, 25, 11, 13, 9, 9, 3)
++knight = Character('Knight', 1, 25, 11, 13, 9, 9, 3)
++archer = Character('Archer', 1, 20, 11, 15, 4, 2, 2)
++hunter = Character('Hunter', 1, 18, 10, 12, 10, 9, 1)
++raider = Character('Raider', 1, 30, 15, 6, 4, 9, 1)
++soldier = Character('Soldier', 1, 20, 12, 15, 3, 1, 4)
++brigand = Character('Brigand', 1, 30, 15, 6, 4, 9, 1)
++
++mage = Character('Mage', 5, 18, 12, 10, 9, 6, 1)
+ 
+-myrm20 = Character('Myrmidon', 20, 32, 20, 26, 25, 20, 6)
+-fighter20 = Character('Fighter', 20, 46, 29, 15, 12, 14, 9)
+-knight20 = Character('Knight', 20, 36, 24, 27, 7, 8, 16)
++myrm_growths = Growths('Myrmidon', 95, 45, 65, 65, 55, 25)
++fighter_growths = Growths('Fighter', 145, 70, 45, 40, 45, 35)
++armor_growths = Growths('Armor', 115, 55, 70, 25, 25, 55)
++merc_growths = Growths('Mercenary', 130, 55, 60, 55, 60, 30)
++cav_growths = Growths('Cavalier', 110, 55, 65, 45, 40, 40)
++peg_growths = Growths('Peg Knight', 85, 35, 50, 75, 70, 20)
++wyvern_growths = Growths('Wyvern', 135, 60, 45, 40, 50, 45)
++nomad_growths = Growths('Nomad', 110, 55, 65, 45, 40, 40)
++thief_growths = Growths('Thief', 90, 30, 45, 80, 35, 20)
++skirm_growths = Growths('Skirmisher', 90, 30, 45, 80, 35, 20)
++errant_growths = Growths('Errant', 120, 50, 60, 55, 65, 45)
++knight_growths = Growths('Knight', 120, 50, 60, 55, 65, 45)
++archer_growths = Growths('Archer', 100, 55, 70, 40, 35, 30)
++hunter_growths = Growths('Hunter', 90, 45, 50, 70, 45, 25)
++raider_growths = Growths('Raider', 155, 60, 25, 40, 55, 25)
++soldier_growths = Growths('Soldier', 105, 55, 60, 35, 25, 45)
++brigand_growths = Growths('Brigand', 155, 60, 25, 40, 55, 25)
+ 
+-swordmaster30 = Character('Swordmaster', 30, 47, 29, 36, 34, 29, 11)
+-warrior30 = Character('Warrior', 30, 68, 39, 23, 20, 24, 16)
+-general30 = Character('General', 30, 56, 34, 36, 12, 14, 24)
++mage_growths = Growths('Mage', 105, 55, 40, 55, 40, 20)
++
++for stat, growth in [(myrm, myrm_growths), (fighter, fighter_growths), (knight, knight_growths),
++                     (merc, merc_growths), (cavalier, cav_growths), (peg_knight, peg_growths),
++                     (wyvern_knight, wyvern_growths), (thief, thief_growths), (soldier, soldier_growths),
++                     (brigand, brigand_growths), (errant, errant_growths), (archer, archer_growths), 
++                     (hunter, hunter_growths), (mage, mage_growths)]:
++    c1 = create_char(stat, growth, 1)
++    c5 = create_char(stat, growth, 5)
++    c10 = create_char(stat, growth, 10)
++    c20 = create_char(stat, growth, 20)
++    c30 = create_char(stat, growth, 30)
++    print(c1)
++    print(c5)
++    print(c10)
++    print(c20)
++    print(c30)
++    print(sum_stats(c30))
++
++myrm20 = create_char(myrm, myrm_growths, 20)
++fighter20 = create_char(fighter, fighter_growths, 20)
++knight20 = create_char(knight, knight_growths, 20)
++errant20 = create_char(errant, errant_growths, 20)
+ 
+ def arena(u1, u2):
+-    mt1 = u1.POW - u2.DEF
+-    mt2 = u2.POW - u1.DEF
+-    hit1 = u1.SKL*5 + 50 - u2.SPD*5
+-    hit2 = u2.SKL*5 + 50 - u1.SPD*5
++    mt1 = max(1, u1.POW - u2.DEF)
++    mt2 = max(1, u2.POW - u1.DEF)
++    hit1 = u1.SKL*4 + 50 - u2.SPD*4 - 10
++    hit2 = u2.SKL*4 + 50 - u1.SPD*4 - 10
+     as1 = u1.BRV > u2.SPD
+     as2 = u2.BRV > u1.SPD
+ 
+@@ -77,6 +144,15 @@ print("")
+ arena(knight, knight)
+ """
+ import itertools
+-for pair in itertools.combinations([myrm, knight, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, lord], 2):
++comb = [myrm, armor, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, errant]
++comb = [myrm, armor, fighter]
++# comb = []
++for pair in itertools.combinations(comb, 2):
++    print("")
++    arena(*pair)
++
++comb = [myrm20, knight20, fighter20]
++# comb = []
++for pair in itertools.combinations(comb, 2):
+     print("")
+     arena(*pair)
+diff --git a/utilities/testing_stats_v3.py b/utilities/testing_stats_v3.py
+new file mode 100644
+index 00000000..f38cde8c
+--- /dev/null
++++ b/utilities/testing_stats_v3.py
+@@ -0,0 +1,172 @@
++import math
++from dataclasses import dataclass
++
++@dataclass
++class Character():
++    name: str = ''
++    LVL: int = 1
++    HP: int = 1
++    POW: int = 0
++    SKL: int = 0
++    SPD: int = 0
++    BRV: int = 0
++    DEF: int = 0
++
++@dataclass
++class Growths():
++    name: str = ''
++    HP: float = 0
++    POW: float = 0
++    SKL: float = 0
++    SPD: float = 0
++    BRV: float = 0
++    DEF: float = 0
++
++def sum_stats(char):
++    return char.HP // 2 + char.POW + char.SKL + char.SPD + char.BRV + char.DEF
++
++def create_char(char: Character, growths: Growths, lvl: int):
++    new_char = Character(char.name, lvl)
++    increase = lvl - char.LVL
++    offset = 50 if increase > 0 else -50
++    new_char.HP = char.HP + int((growths.HP * increase + offset) / 100)
++    new_char.POW = char.POW + int((growths.POW * increase + offset) / 100)
++    new_char.SKL = char.SKL + int((growths.SKL * increase + offset) / 100)
++    new_char.SPD = char.SPD + int((growths.SPD * increase + offset) / 100)
++    new_char.BRV = char.BRV + int((growths.BRV * increase + offset) / 100)
++    new_char.DEF = char.DEF + int((growths.DEF * increase + offset) / 100)
++    return new_char
++
++# Sword users
++myrm = Character('Myrmidon', 1, 18, 7, 12, 7, 8, 1)
++myrm_growths = Growths('Myrmidon', 95, 45, 60, 60, 55, 20)
++errant = Character('Errant', 1, 22, 8, 9, 5, 6, 4)
++errant_growths = Growths('Errant', 105, 50, 40, 50, 50, 35)
++skirm = Character('Skirmisher', 1, 17, 6, 8, 7, 9, 2)
++skirm_growths = Growths('Skirmisher', 85, 40, 50, 65, 65, 25)
++sword_users = [(myrm, myrm_growths), (errant, errant_growths), (skirm, skirm_growths)]
++# Lance users
++armor = Character('Armor', 1, 20, 11, 9, 1, 1, 6)
++armor_growths = Growths('Armor', 100, 60, 55, 20, 20, 55)
++cavalier = Character('Cavalier', 1, 20, 10, 7, 4, 4, 3)
++cav_growths = Growths('Cavalier', 100, 50, 45, 45, 40, 30)
++peg_knight = Character('Peg Knight', 1, 16, 8, 8, 8, 10, 1)
++peg_growths = Growths('Peg Knight', 80, 35, 50, 70, 70, 20)
++wyvern_knight = Character('Wyvern', 1, 22, 11, 6, 3, 4, 5)
++wyvern_growths = Growths('Wyvern', 105, 65, 45, 35, 40, 45)
++lance_users = [(armor, armor_growths), (cavalier, cav_growths), (peg_knight, peg_growths), (wyvern_knight, wyvern_growths)]
++# Greatsword users
++fighter = Character('Fighter', 1, 24, 13, 3, 3, 5, 2)
++fighter_growths = Growths('Fighter', 110, 70, 35, 35, 45, 35)
++raider = Character('Raider', 1, 24, 12, 4, 5, 6, 1)
++raider_growths = Growths('Raider', 120, 60, 40, 50, 50, 25)
++merc = Character('Mercenary', 1, 22, 8, 12, 4, 6, 3)
++merc_growths = Growths('Mercenary', 105, 55, 60, 45, 50, 30)
++knight = Character('Knight', 1, 24, 10, 4, 2, 5, 5)
++knight_growths = Growths('Knight', 110, 65, 45, 25, 45, 45)
++greatsword_users = [(fighter, fighter_growths), (raider, raider_growths), (merc, merc_growths), (knight, knight_growths)]
++# Dagger users
++thief = Character('Thief', 1, 16, 5, 10, 8, 2, 1)
++thief_growths = Growths('Thief', 65, 35, 45, 65, 30, 15)
++dagger_users = [(thief, thief_growths)]
++# Bow users
++archer = Character('Archer', 1, 18, 9, 10, 3, 3, 3)
++archer_growths = Growths('Archer', 95, 55, 55, 40, 35, 30)
++hunter = Character('Hunter', 1, 17, 8, 10, 7, 6, 1)
++hunter_growths = Growths('Hunter', 85, 40, 50, 60, 50, 20)
++nomad = Character('Nomad', 1, 20, 8, 8, 5, 6, 1)
++nomad_growths = Growths('Nomad', 100, 45, 45, 50, 50, 20)
++bow_users = [(archer, archer_growths), (hunter, hunter_growths), (nomad, nomad_growths)]
++
++soldier = Character('Soldier', 1, 18, 7, 8, 3, 2, 3)
++soldier_growths = Growths('Soldier', 95, 50, 55, 35, 30, 30)
++brigand = Character('Brigand', 1, 24, 13, 2, 3, 2, 1)
++brigand_growths = Growths('Brigand', 120, 70, 30, 35, 30, 20)
++weak_users = [(soldier, soldier_growths), (brigand, brigand_growths)]
++
++mage = Character('Mage', 5, 18, 12, 10, 9, 6, 1)
++mage_growths = Growths('Mage', 105, 55, 40, 55, 40, 20)
++
++all_stats = sword_users + lance_users + greatsword_users + dagger_users + bow_users + weak_users
++level_20s = []
++level_30s = []
++for stat, growth in all_stats:
++    c1 = create_char(stat, growth, 1)
++    c5 = create_char(stat, growth, 5)
++    c10 = create_char(stat, growth, 10)
++    c20 = create_char(stat, growth, 20)
++    c30 = create_char(stat, growth, 30)
++    print(c1)
++    print(c5)
++    print(c10)
++    print(c20)
++    level_20s.append(c20)
++    print(c30)
++    level_30s.append(c30)
++    print(sum_stats(c30))
++
++myrm20 = create_char(myrm, myrm_growths, 20)
++fighter20 = create_char(fighter, fighter_growths, 20)
++armor20 = create_char(armor, armor_growths, 20)
++
++def arena(u1, u2):
++    mt1 = max(1, u1.POW - u2.DEF)
++    mt2 = max(1, u2.POW - u1.DEF)
++    hit1 = u1.SKL*4 + 70 - u2.SPD*4
++    hit2 = u2.SKL*4 + 70 - u1.SPD*4
++    as1 = u1.BRV > u2.SPD
++    as2 = u2.BRV > u1.SPD
++
++    print("%s: HP: %d Mt: %d Hit: %d Double: %s" % (u1.name, u1.HP, mt1, hit1, as1))
++    print("%s: HP: %d Mt: %d Hit: %d Double: %s" % (u2.name, u2.HP, mt2, hit2, as2))
++    min_num_rounds_to_ko1 = math.ceil(u2.HP / mt1 / (1.5 if as1 else 1)) if hit1 > 0 else 99
++    min_num_rounds_to_ko2 = math.ceil(u1.HP / mt2 / (1.5 if as2 else 1)) if hit2 > 0 else 99
++    avg_num_rounds_to_ko1 = math.ceil(u2.HP / (mt1 * min(1, hit1/100)) / (1.5 if as1 else 1)) if hit1 > 0 else 99
++    avg_num_rounds_to_ko2 = math.ceil(u1.HP / (mt2 * min(1, hit2/100)) / (1.5 if as2 else 1)) if hit2 > 0 else 99
++    print("%s KOs %s in %d rounds (min: %d rounds)" % (u1.name, u2.name, avg_num_rounds_to_ko1, min_num_rounds_to_ko1))
++    print("%s KOs %s in %d rounds (min: %d rounds)" % (u2.name, u1.name, avg_num_rounds_to_ko2, min_num_rounds_to_ko2))
++
++"""
++arena(myrm, fighter)
++print("")
++arena(myrm, knight)
++print("")
++arena(fighter, knight)
++print("")
++arena(myrm20, fighter20)
++print("")
++arena(myrm20, knight20)
++print("")
++arena(fighter20, knight20)
++print("")
++arena(swordmaster30, warrior30)
++print("")
++arena(swordmaster30, general30)
++print("")
++arena(warrior30, general30)
++print("")
++arena(fighter, merc)
++print("")
++arena(myrm, myrm)
++print("")
++arena(fighter, fighter)
++print("")
++arena(knight, knight)
++"""
++import itertools
++comb = [myrm, armor, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, errant]
++comb = [myrm, armor, fighter]
++# comb = []
++for pair in itertools.combinations(comb, 2):
++    print("")
++    arena(*pair)
++
++comb = [myrm20, armor20, fighter20]
++# comb = []
++for pair in itertools.combinations(comb, 2):
++    print("")
++    arena(*pair)
++
++pow_sort = sorted(level_30s, key=lambda x: x.BRV)
++for char in pow_sort:
++    print(char)
+diff --git a/utilities/value_noise_generator.py b/utilities/value_noise_generator.py
+new file mode 100644
+index 00000000..672db98c
+--- /dev/null
++++ b/utilities/value_noise_generator.py
+@@ -0,0 +1,103 @@
++import random, math
++
++# from app.engine import engine
++
++import time
++from PIL import Image
++
++class ValueNoise():
++    num_octaves = 5
++    pixels_per_lattice = 24
++    pixel_depth = 48 * 4
++
++    def __init__(self, width: int, height: int):
++        self.pixel_width = width
++        self.pixel_height = height
++        self.lattice_width = width // self.pixels_per_lattice
++        self.lattice_height = height // self.pixels_per_lattice
++        self.lattice_depth = self.pixel_depth // self.pixels_per_lattice
++        self.lattice_depth //= 4
++
++        self.noise_map = self.generate_full_noise_map()
++
++    def generate_full_noise_map(self):
++        frequency = 0.25
++        frequency_mult = 2  # lacunarity
++        amplitude_mult = 0.35
++        amplitude = 1
++        true_noise_map = [0 for _ in range(self.pixel_width * self.pixel_height * self.pixel_depth)]
++        for i in range(self.num_octaves):
++            print("Octave: %d" % i)
++            noise_map = self.generate_noise_map(frequency)
++            noise_map = [v * amplitude for v in noise_map]
++            amplitude *= amplitude_mult
++            frequency *= frequency_mult
++            true_noise_map = [n + tn for n, tn in zip(noise_map, true_noise_map)]
++        # normalize map
++        max_value = max(true_noise_map)
++        true_noise_map = [v / max_value for v in true_noise_map]
++        return true_noise_map
++
++    def _interp(self, a, b, t):
++        # t should be in range 0 to 1
++        remap_t = t * t * (3 - 2 * t)
++        return a * (1 - remap_t) + b * remap_t
++
++    def generate_noise_map(self, frequency):
++        randoms = [random.random() for _ in range(self.lattice_width * self.lattice_height * self.lattice_depth)]
++        noise_map = []
++        for pz in range(self.pixel_depth):
++            print(pz)
++            for px in range(self.pixel_width):
++                for py in range(self.pixel_height):
++                    lx = px * frequency / self.pixels_per_lattice
++                    ly = py * frequency / self.pixels_per_lattice
++                    lz = pz * frequency / self.pixels_per_lattice
++                    lx %= self.lattice_width
++                    ly %= self.lattice_height
++                    lz %= self.lattice_depth
++                    flx = math.floor(lx)
++                    fly = math.floor(ly)
++                    flz = math.floor(lz)
++                    tx = lx - flx
++                    ty = ly - fly
++                    tz = lz - flz
++                    rx0 = flx
++                    rx1 = (flx + 1) % self.lattice_width
++                    ry0 = fly
++                    ry1 = (fly + 1) % self.lattice_height
++                    rz0 = flz
++                    rz1 = (flz + 1) % self.lattice_depth
++                    c000 = randoms[rz0 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry0]
++                    c010 = randoms[rz0 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry1]
++                    c001 = randoms[rz0 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry0]
++                    c011 = randoms[rz0 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry1]
++                    c100 = randoms[rz1 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry0]
++                    c110 = randoms[rz1 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry1]
++                    c101 = randoms[rz1 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry0]
++                    c111 = randoms[rz1 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry1]
++                    nx00 = self._interp(c000, c001, tx)
++                    nx01 = self._interp(c010, c011, tx)
++                    nx10 = self._interp(c100, c101, tx)
++                    nx11 = self._interp(c110, c111, tx)
++                    ny0 = self._interp(nx00, nx01, ty)
++                    ny1 = self._interp(nx10, nx11, ty)
++                    final = self._interp(ny0, ny1, tz)
++                    # print("px:%d py:%d %.2f %.2f %d %d %d %d tx:%.2f ty:%.2f c00:%.2f c10:%.2f c01:%.2f c11:%.2f f:%.2f" % (px, py, lx, ly, rx0, rx1, ry0, ry1, tx, ty, c00, c10, c01, c11, final))
++                    noise_map.append(final)
++        return noise_map
++
++    def noise_map_to_pillow(self, noise_map, pz):
++        new_image = Image.new('RGB', (self.pixel_width, self.pixel_height))
++        for px in range(self.pixel_width):
++            for py in range(self.pixel_height):
++                noise_value = int(255 * noise_map[pz * self.pixel_width * self.pixel_height + px * self.pixel_height + py])
++                new_image.putpixel((px, py), (noise_value, noise_value, noise_value))
++        new_image.save("im%03d.png" % pz)
++
++    def save_img(self):
++        for pz in range(self.pixel_depth):
++            self.noise_map_to_pillow(self.noise_map, pz)
++
++VALUE_NOISE = ValueNoise(384, 216)
++VALUE_NOISE.save_img()
diff --git a/fog/im000.png b/fog/im000.png
new file mode 100644
index 00000000..1641772b
Binary files /dev/null and b/fog/im000.png differ
diff --git a/fog/im001.png b/fog/im001.png
new file mode 100644
index 00000000..25c6fa68
Binary files /dev/null and b/fog/im001.png differ
diff --git a/fog/im002.png b/fog/im002.png
new file mode 100644
index 00000000..06a4cfa7
Binary files /dev/null and b/fog/im002.png differ
diff --git a/fog/im003.png b/fog/im003.png
new file mode 100644
index 00000000..beb4977f
Binary files /dev/null and b/fog/im003.png differ
diff --git a/fog/im004.png b/fog/im004.png
new file mode 100644
index 00000000..db9d6dd4
Binary files /dev/null and b/fog/im004.png differ
diff --git a/fog/im005.png b/fog/im005.png
new file mode 100644
index 00000000..aab40938
Binary files /dev/null and b/fog/im005.png differ
diff --git a/fog/im006.png b/fog/im006.png
new file mode 100644
index 00000000..f1c2d8ce
Binary files /dev/null and b/fog/im006.png differ
diff --git a/fog/im007.png b/fog/im007.png
new file mode 100644
index 00000000..040b2cf6
Binary files /dev/null and b/fog/im007.png differ
diff --git a/fog/im008.png b/fog/im008.png
new file mode 100644
index 00000000..555ca94c
Binary files /dev/null and b/fog/im008.png differ
diff --git a/fog/im009.png b/fog/im009.png
new file mode 100644
index 00000000..5d2c07fa
Binary files /dev/null and b/fog/im009.png differ
diff --git a/fog/im010.png b/fog/im010.png
new file mode 100644
index 00000000..76d81328
Binary files /dev/null and b/fog/im010.png differ
diff --git a/fog/im011.png b/fog/im011.png
new file mode 100644
index 00000000..7f3196b5
Binary files /dev/null and b/fog/im011.png differ
diff --git a/fog/im012.png b/fog/im012.png
new file mode 100644
index 00000000..bc2a1fa5
Binary files /dev/null and b/fog/im012.png differ
diff --git a/fog/im013.png b/fog/im013.png
new file mode 100644
index 00000000..5b648052
Binary files /dev/null and b/fog/im013.png differ
diff --git a/fog/im014.png b/fog/im014.png
new file mode 100644
index 00000000..3eed8f3a
Binary files /dev/null and b/fog/im014.png differ
diff --git a/fog/im015.png b/fog/im015.png
new file mode 100644
index 00000000..b086780c
Binary files /dev/null and b/fog/im015.png differ
diff --git a/fog/im016.png b/fog/im016.png
new file mode 100644
index 00000000..ccdc0aa2
Binary files /dev/null and b/fog/im016.png differ
diff --git a/fog/im017.png b/fog/im017.png
new file mode 100644
index 00000000..ce3b5158
Binary files /dev/null and b/fog/im017.png differ
diff --git a/fog/im018.png b/fog/im018.png
new file mode 100644
index 00000000..4419a31c
Binary files /dev/null and b/fog/im018.png differ
diff --git a/fog/im019.png b/fog/im019.png
new file mode 100644
index 00000000..99a9cd6e
Binary files /dev/null and b/fog/im019.png differ
diff --git a/fog/im020.png b/fog/im020.png
new file mode 100644
index 00000000..a358a833
Binary files /dev/null and b/fog/im020.png differ
diff --git a/fog/im021.png b/fog/im021.png
new file mode 100644
index 00000000..e6d907e6
Binary files /dev/null and b/fog/im021.png differ
diff --git a/fog/im022.png b/fog/im022.png
new file mode 100644
index 00000000..bc49e733
Binary files /dev/null and b/fog/im022.png differ
diff --git a/fog/im023.png b/fog/im023.png
new file mode 100644
index 00000000..0a7b84e7
Binary files /dev/null and b/fog/im023.png differ
diff --git a/fog/im024.png b/fog/im024.png
new file mode 100644
index 00000000..40d7212e
Binary files /dev/null and b/fog/im024.png differ
diff --git a/fog/im025.png b/fog/im025.png
new file mode 100644
index 00000000..1738ea29
Binary files /dev/null and b/fog/im025.png differ
diff --git a/fog/im026.png b/fog/im026.png
new file mode 100644
index 00000000..6d4e5860
Binary files /dev/null and b/fog/im026.png differ
diff --git a/fog/im027.png b/fog/im027.png
new file mode 100644
index 00000000..c1e193ca
Binary files /dev/null and b/fog/im027.png differ
diff --git a/fog/im028.png b/fog/im028.png
new file mode 100644
index 00000000..ebe50e50
Binary files /dev/null and b/fog/im028.png differ
diff --git a/fog/im029.png b/fog/im029.png
new file mode 100644
index 00000000..639b8fe3
Binary files /dev/null and b/fog/im029.png differ
diff --git a/fog/im030.png b/fog/im030.png
new file mode 100644
index 00000000..9a276cfa
Binary files /dev/null and b/fog/im030.png differ
diff --git a/fog/im031.png b/fog/im031.png
new file mode 100644
index 00000000..1ff46897
Binary files /dev/null and b/fog/im031.png differ
diff --git a/fog/im032.png b/fog/im032.png
new file mode 100644
index 00000000..d990f7ef
Binary files /dev/null and b/fog/im032.png differ
diff --git a/fog/im033.png b/fog/im033.png
new file mode 100644
index 00000000..e1067a52
Binary files /dev/null and b/fog/im033.png differ
diff --git a/fog/im034.png b/fog/im034.png
new file mode 100644
index 00000000..ed1ec2a8
Binary files /dev/null and b/fog/im034.png differ
diff --git a/fog/im035.png b/fog/im035.png
new file mode 100644
index 00000000..ae6c2abd
Binary files /dev/null and b/fog/im035.png differ
diff --git a/fog/im036.png b/fog/im036.png
new file mode 100644
index 00000000..6250c91e
Binary files /dev/null and b/fog/im036.png differ
diff --git a/fog/im037.png b/fog/im037.png
new file mode 100644
index 00000000..c7173c86
Binary files /dev/null and b/fog/im037.png differ
diff --git a/fog/im038.png b/fog/im038.png
new file mode 100644
index 00000000..a8a73b28
Binary files /dev/null and b/fog/im038.png differ
diff --git a/fog/im039.png b/fog/im039.png
new file mode 100644
index 00000000..55adcc34
Binary files /dev/null and b/fog/im039.png differ
diff --git a/fog/im040.png b/fog/im040.png
new file mode 100644
index 00000000..7af32cc3
Binary files /dev/null and b/fog/im040.png differ
diff --git a/fog/im041.png b/fog/im041.png
new file mode 100644
index 00000000..a42f03c3
Binary files /dev/null and b/fog/im041.png differ
diff --git a/fog/im042.png b/fog/im042.png
new file mode 100644
index 00000000..f97bb9b3
Binary files /dev/null and b/fog/im042.png differ
diff --git a/fog/im043.png b/fog/im043.png
new file mode 100644
index 00000000..a1395c31
Binary files /dev/null and b/fog/im043.png differ
diff --git a/fog/im044.png b/fog/im044.png
new file mode 100644
index 00000000..94bf298c
Binary files /dev/null and b/fog/im044.png differ
diff --git a/fog/im045.png b/fog/im045.png
new file mode 100644
index 00000000..3a8b7107
Binary files /dev/null and b/fog/im045.png differ
diff --git a/fog/im046.png b/fog/im046.png
new file mode 100644
index 00000000..014fe5c1
Binary files /dev/null and b/fog/im046.png differ
diff --git a/fog/im047.png b/fog/im047.png
new file mode 100644
index 00000000..fffeac95
Binary files /dev/null and b/fog/im047.png differ
diff --git a/fog/im048.png b/fog/im048.png
new file mode 100644
index 00000000..5c735a94
Binary files /dev/null and b/fog/im048.png differ
diff --git a/fog/im049.png b/fog/im049.png
new file mode 100644
index 00000000..a541ac0a
Binary files /dev/null and b/fog/im049.png differ
diff --git a/fog/im050.png b/fog/im050.png
new file mode 100644
index 00000000..b7d5385d
Binary files /dev/null and b/fog/im050.png differ
diff --git a/fog/im051.png b/fog/im051.png
new file mode 100644
index 00000000..228e426c
Binary files /dev/null and b/fog/im051.png differ
diff --git a/fog/im052.png b/fog/im052.png
new file mode 100644
index 00000000..a2789946
Binary files /dev/null and b/fog/im052.png differ
diff --git a/fog/im053.png b/fog/im053.png
new file mode 100644
index 00000000..b44abd3a
Binary files /dev/null and b/fog/im053.png differ
diff --git a/fog/im054.png b/fog/im054.png
new file mode 100644
index 00000000..309cad33
Binary files /dev/null and b/fog/im054.png differ
diff --git a/fog/im055.png b/fog/im055.png
new file mode 100644
index 00000000..2ea33550
Binary files /dev/null and b/fog/im055.png differ
diff --git a/fog/im056.png b/fog/im056.png
new file mode 100644
index 00000000..823739f3
Binary files /dev/null and b/fog/im056.png differ
diff --git a/fog/im057.png b/fog/im057.png
new file mode 100644
index 00000000..767f7547
Binary files /dev/null and b/fog/im057.png differ
diff --git a/fog/im058.png b/fog/im058.png
new file mode 100644
index 00000000..b20b906f
Binary files /dev/null and b/fog/im058.png differ
diff --git a/fog/im059.png b/fog/im059.png
new file mode 100644
index 00000000..269db7cb
Binary files /dev/null and b/fog/im059.png differ
diff --git a/fog/im060.png b/fog/im060.png
new file mode 100644
index 00000000..cb769ccd
Binary files /dev/null and b/fog/im060.png differ
diff --git a/fog/im061.png b/fog/im061.png
new file mode 100644
index 00000000..ab2d2255
Binary files /dev/null and b/fog/im061.png differ
diff --git a/fog/im062.png b/fog/im062.png
new file mode 100644
index 00000000..a1be3e57
Binary files /dev/null and b/fog/im062.png differ
diff --git a/fog/im063.png b/fog/im063.png
new file mode 100644
index 00000000..9f53a10a
Binary files /dev/null and b/fog/im063.png differ
diff --git a/fog/im064.png b/fog/im064.png
new file mode 100644
index 00000000..665207bc
Binary files /dev/null and b/fog/im064.png differ
diff --git a/fog/im065.png b/fog/im065.png
new file mode 100644
index 00000000..e9be1283
Binary files /dev/null and b/fog/im065.png differ
diff --git a/fog/im066.png b/fog/im066.png
new file mode 100644
index 00000000..36dca2ac
Binary files /dev/null and b/fog/im066.png differ
diff --git a/fog/im067.png b/fog/im067.png
new file mode 100644
index 00000000..b65c6341
Binary files /dev/null and b/fog/im067.png differ
diff --git a/fog/im068.png b/fog/im068.png
new file mode 100644
index 00000000..269f25de
Binary files /dev/null and b/fog/im068.png differ
diff --git a/fog/im069.png b/fog/im069.png
new file mode 100644
index 00000000..f0caab0e
Binary files /dev/null and b/fog/im069.png differ
diff --git a/fog/im070.png b/fog/im070.png
new file mode 100644
index 00000000..d73dab69
Binary files /dev/null and b/fog/im070.png differ
diff --git a/fog/im071.png b/fog/im071.png
new file mode 100644
index 00000000..a54f8305
Binary files /dev/null and b/fog/im071.png differ
diff --git a/fog/im072.png b/fog/im072.png
new file mode 100644
index 00000000..2afcf811
Binary files /dev/null and b/fog/im072.png differ
diff --git a/fog/im073.png b/fog/im073.png
new file mode 100644
index 00000000..6c38c9a8
Binary files /dev/null and b/fog/im073.png differ
diff --git a/fog/im074.png b/fog/im074.png
new file mode 100644
index 00000000..62071305
Binary files /dev/null and b/fog/im074.png differ
diff --git a/fog/im075.png b/fog/im075.png
new file mode 100644
index 00000000..2a1027b5
Binary files /dev/null and b/fog/im075.png differ
diff --git a/fog/im076.png b/fog/im076.png
new file mode 100644
index 00000000..7d4c1133
Binary files /dev/null and b/fog/im076.png differ
diff --git a/fog/im077.png b/fog/im077.png
new file mode 100644
index 00000000..44872557
Binary files /dev/null and b/fog/im077.png differ
diff --git a/fog/im078.png b/fog/im078.png
new file mode 100644
index 00000000..12bed522
Binary files /dev/null and b/fog/im078.png differ
diff --git a/fog/im079.png b/fog/im079.png
new file mode 100644
index 00000000..a3322f62
Binary files /dev/null and b/fog/im079.png differ
diff --git a/fog/im080.png b/fog/im080.png
new file mode 100644
index 00000000..80337067
Binary files /dev/null and b/fog/im080.png differ
diff --git a/fog/im081.png b/fog/im081.png
new file mode 100644
index 00000000..5f08f959
Binary files /dev/null and b/fog/im081.png differ
diff --git a/fog/im082.png b/fog/im082.png
new file mode 100644
index 00000000..a15c0767
Binary files /dev/null and b/fog/im082.png differ
diff --git a/fog/im083.png b/fog/im083.png
new file mode 100644
index 00000000..4886e766
Binary files /dev/null and b/fog/im083.png differ
diff --git a/fog/im084.png b/fog/im084.png
new file mode 100644
index 00000000..dd990a1a
Binary files /dev/null and b/fog/im084.png differ
diff --git a/fog/im085.png b/fog/im085.png
new file mode 100644
index 00000000..f184d515
Binary files /dev/null and b/fog/im085.png differ
diff --git a/fog/im086.png b/fog/im086.png
new file mode 100644
index 00000000..91a32689
Binary files /dev/null and b/fog/im086.png differ
diff --git a/fog/im087.png b/fog/im087.png
new file mode 100644
index 00000000..9b402b87
Binary files /dev/null and b/fog/im087.png differ
diff --git a/fog/im088.png b/fog/im088.png
new file mode 100644
index 00000000..21e7f303
Binary files /dev/null and b/fog/im088.png differ
diff --git a/fog/im089.png b/fog/im089.png
new file mode 100644
index 00000000..cb76b06a
Binary files /dev/null and b/fog/im089.png differ
diff --git a/fog/im090.png b/fog/im090.png
new file mode 100644
index 00000000..781fd24b
Binary files /dev/null and b/fog/im090.png differ
diff --git a/fog/im091.png b/fog/im091.png
new file mode 100644
index 00000000..94242d2e
Binary files /dev/null and b/fog/im091.png differ
diff --git a/fog/im092.png b/fog/im092.png
new file mode 100644
index 00000000..18d95442
Binary files /dev/null and b/fog/im092.png differ
diff --git a/fog/im093.png b/fog/im093.png
new file mode 100644
index 00000000..8d61120a
Binary files /dev/null and b/fog/im093.png differ
diff --git a/fog/im094.png b/fog/im094.png
new file mode 100644
index 00000000..ae386b22
Binary files /dev/null and b/fog/im094.png differ
diff --git a/fog/im095.png b/fog/im095.png
new file mode 100644
index 00000000..3a0fefaf
Binary files /dev/null and b/fog/im095.png differ
diff --git a/fog/im096.png b/fog/im096.png
new file mode 100644
index 00000000..1a9bffb8
Binary files /dev/null and b/fog/im096.png differ
diff --git a/fog/im097.png b/fog/im097.png
new file mode 100644
index 00000000..3a0fefaf
Binary files /dev/null and b/fog/im097.png differ
diff --git a/fog/im098.png b/fog/im098.png
new file mode 100644
index 00000000..ae386b22
Binary files /dev/null and b/fog/im098.png differ
diff --git a/fog/im099.png b/fog/im099.png
new file mode 100644
index 00000000..8d61120a
Binary files /dev/null and b/fog/im099.png differ
diff --git a/fog/im100.png b/fog/im100.png
new file mode 100644
index 00000000..18d95442
Binary files /dev/null and b/fog/im100.png differ
diff --git a/fog/im101.png b/fog/im101.png
new file mode 100644
index 00000000..94242d2e
Binary files /dev/null and b/fog/im101.png differ
diff --git a/fog/im102.png b/fog/im102.png
new file mode 100644
index 00000000..781fd24b
Binary files /dev/null and b/fog/im102.png differ
diff --git a/fog/im103.png b/fog/im103.png
new file mode 100644
index 00000000..cb76b06a
Binary files /dev/null and b/fog/im103.png differ
diff --git a/fog/im104.png b/fog/im104.png
new file mode 100644
index 00000000..21e7f303
Binary files /dev/null and b/fog/im104.png differ
diff --git a/fog/im105.png b/fog/im105.png
new file mode 100644
index 00000000..9b402b87
Binary files /dev/null and b/fog/im105.png differ
diff --git a/fog/im106.png b/fog/im106.png
new file mode 100644
index 00000000..91a32689
Binary files /dev/null and b/fog/im106.png differ
diff --git a/fog/im107.png b/fog/im107.png
new file mode 100644
index 00000000..f184d515
Binary files /dev/null and b/fog/im107.png differ
diff --git a/fog/im108.png b/fog/im108.png
new file mode 100644
index 00000000..dd990a1a
Binary files /dev/null and b/fog/im108.png differ
diff --git a/fog/im109.png b/fog/im109.png
new file mode 100644
index 00000000..4886e766
Binary files /dev/null and b/fog/im109.png differ
diff --git a/fog/im110.png b/fog/im110.png
new file mode 100644
index 00000000..a15c0767
Binary files /dev/null and b/fog/im110.png differ
diff --git a/fog/im111.png b/fog/im111.png
new file mode 100644
index 00000000..5f08f959
Binary files /dev/null and b/fog/im111.png differ
diff --git a/fog/im112.png b/fog/im112.png
new file mode 100644
index 00000000..80337067
Binary files /dev/null and b/fog/im112.png differ
diff --git a/fog/im113.png b/fog/im113.png
new file mode 100644
index 00000000..a3322f62
Binary files /dev/null and b/fog/im113.png differ
diff --git a/fog/im114.png b/fog/im114.png
new file mode 100644
index 00000000..12bed522
Binary files /dev/null and b/fog/im114.png differ
diff --git a/fog/im115.png b/fog/im115.png
new file mode 100644
index 00000000..44872557
Binary files /dev/null and b/fog/im115.png differ
diff --git a/fog/im116.png b/fog/im116.png
new file mode 100644
index 00000000..7d4c1133
Binary files /dev/null and b/fog/im116.png differ
diff --git a/fog/im117.png b/fog/im117.png
new file mode 100644
index 00000000..2a1027b5
Binary files /dev/null and b/fog/im117.png differ
diff --git a/fog/im118.png b/fog/im118.png
new file mode 100644
index 00000000..62071305
Binary files /dev/null and b/fog/im118.png differ
diff --git a/fog/im119.png b/fog/im119.png
new file mode 100644
index 00000000..6c38c9a8
Binary files /dev/null and b/fog/im119.png differ
diff --git a/fog/im120.png b/fog/im120.png
new file mode 100644
index 00000000..2afcf811
Binary files /dev/null and b/fog/im120.png differ
diff --git a/fog/im121.png b/fog/im121.png
new file mode 100644
index 00000000..a54f8305
Binary files /dev/null and b/fog/im121.png differ
diff --git a/fog/im122.png b/fog/im122.png
new file mode 100644
index 00000000..d73dab69
Binary files /dev/null and b/fog/im122.png differ
diff --git a/fog/im123.png b/fog/im123.png
new file mode 100644
index 00000000..f0caab0e
Binary files /dev/null and b/fog/im123.png differ
diff --git a/fog/im124.png b/fog/im124.png
new file mode 100644
index 00000000..269f25de
Binary files /dev/null and b/fog/im124.png differ
diff --git a/fog/im125.png b/fog/im125.png
new file mode 100644
index 00000000..b65c6341
Binary files /dev/null and b/fog/im125.png differ
diff --git a/fog/im126.png b/fog/im126.png
new file mode 100644
index 00000000..36dca2ac
Binary files /dev/null and b/fog/im126.png differ
diff --git a/fog/im127.png b/fog/im127.png
new file mode 100644
index 00000000..e9be1283
Binary files /dev/null and b/fog/im127.png differ
diff --git a/fog/im128.png b/fog/im128.png
new file mode 100644
index 00000000..665207bc
Binary files /dev/null and b/fog/im128.png differ
diff --git a/fog/im129.png b/fog/im129.png
new file mode 100644
index 00000000..9f53a10a
Binary files /dev/null and b/fog/im129.png differ
diff --git a/fog/im130.png b/fog/im130.png
new file mode 100644
index 00000000..a1be3e57
Binary files /dev/null and b/fog/im130.png differ
diff --git a/fog/im131.png b/fog/im131.png
new file mode 100644
index 00000000..ab2d2255
Binary files /dev/null and b/fog/im131.png differ
diff --git a/fog/im132.png b/fog/im132.png
new file mode 100644
index 00000000..cb769ccd
Binary files /dev/null and b/fog/im132.png differ
diff --git a/fog/im133.png b/fog/im133.png
new file mode 100644
index 00000000..269db7cb
Binary files /dev/null and b/fog/im133.png differ
diff --git a/fog/im134.png b/fog/im134.png
new file mode 100644
index 00000000..b20b906f
Binary files /dev/null and b/fog/im134.png differ
diff --git a/fog/im135.png b/fog/im135.png
new file mode 100644
index 00000000..767f7547
Binary files /dev/null and b/fog/im135.png differ
diff --git a/fog/im136.png b/fog/im136.png
new file mode 100644
index 00000000..823739f3
Binary files /dev/null and b/fog/im136.png differ
diff --git a/fog/im137.png b/fog/im137.png
new file mode 100644
index 00000000..2ea33550
Binary files /dev/null and b/fog/im137.png differ
diff --git a/fog/im138.png b/fog/im138.png
new file mode 100644
index 00000000..309cad33
Binary files /dev/null and b/fog/im138.png differ
diff --git a/fog/im139.png b/fog/im139.png
new file mode 100644
index 00000000..b44abd3a
Binary files /dev/null and b/fog/im139.png differ
diff --git a/fog/im140.png b/fog/im140.png
new file mode 100644
index 00000000..a2789946
Binary files /dev/null and b/fog/im140.png differ
diff --git a/fog/im141.png b/fog/im141.png
new file mode 100644
index 00000000..228e426c
Binary files /dev/null and b/fog/im141.png differ
diff --git a/fog/im142.png b/fog/im142.png
new file mode 100644
index 00000000..b7d5385d
Binary files /dev/null and b/fog/im142.png differ
diff --git a/fog/im143.png b/fog/im143.png
new file mode 100644
index 00000000..a541ac0a
Binary files /dev/null and b/fog/im143.png differ
diff --git a/fog/im144.png b/fog/im144.png
new file mode 100644
index 00000000..5c735a94
Binary files /dev/null and b/fog/im144.png differ
diff --git a/fog/im145.png b/fog/im145.png
new file mode 100644
index 00000000..fffeac95
Binary files /dev/null and b/fog/im145.png differ
diff --git a/fog/im146.png b/fog/im146.png
new file mode 100644
index 00000000..014fe5c1
Binary files /dev/null and b/fog/im146.png differ
diff --git a/fog/im147.png b/fog/im147.png
new file mode 100644
index 00000000..3a8b7107
Binary files /dev/null and b/fog/im147.png differ
diff --git a/fog/im148.png b/fog/im148.png
new file mode 100644
index 00000000..94bf298c
Binary files /dev/null and b/fog/im148.png differ
diff --git a/fog/im149.png b/fog/im149.png
new file mode 100644
index 00000000..a1395c31
Binary files /dev/null and b/fog/im149.png differ
diff --git a/fog/im150.png b/fog/im150.png
new file mode 100644
index 00000000..f97bb9b3
Binary files /dev/null and b/fog/im150.png differ
diff --git a/fog/im151.png b/fog/im151.png
new file mode 100644
index 00000000..a42f03c3
Binary files /dev/null and b/fog/im151.png differ
diff --git a/fog/im152.png b/fog/im152.png
new file mode 100644
index 00000000..7af32cc3
Binary files /dev/null and b/fog/im152.png differ
diff --git a/fog/im153.png b/fog/im153.png
new file mode 100644
index 00000000..55adcc34
Binary files /dev/null and b/fog/im153.png differ
diff --git a/fog/im154.png b/fog/im154.png
new file mode 100644
index 00000000..a8a73b28
Binary files /dev/null and b/fog/im154.png differ
diff --git a/fog/im155.png b/fog/im155.png
new file mode 100644
index 00000000..c7173c86
Binary files /dev/null and b/fog/im155.png differ
diff --git a/fog/im156.png b/fog/im156.png
new file mode 100644
index 00000000..6250c91e
Binary files /dev/null and b/fog/im156.png differ
diff --git a/fog/im157.png b/fog/im157.png
new file mode 100644
index 00000000..ae6c2abd
Binary files /dev/null and b/fog/im157.png differ
diff --git a/fog/im158.png b/fog/im158.png
new file mode 100644
index 00000000..ed1ec2a8
Binary files /dev/null and b/fog/im158.png differ
diff --git a/fog/im159.png b/fog/im159.png
new file mode 100644
index 00000000..e1067a52
Binary files /dev/null and b/fog/im159.png differ
diff --git a/fog/im160.png b/fog/im160.png
new file mode 100644
index 00000000..d990f7ef
Binary files /dev/null and b/fog/im160.png differ
diff --git a/fog/im161.png b/fog/im161.png
new file mode 100644
index 00000000..1ff46897
Binary files /dev/null and b/fog/im161.png differ
diff --git a/fog/im162.png b/fog/im162.png
new file mode 100644
index 00000000..9a276cfa
Binary files /dev/null and b/fog/im162.png differ
diff --git a/fog/im163.png b/fog/im163.png
new file mode 100644
index 00000000..639b8fe3
Binary files /dev/null and b/fog/im163.png differ
diff --git a/fog/im164.png b/fog/im164.png
new file mode 100644
index 00000000..ebe50e50
Binary files /dev/null and b/fog/im164.png differ
diff --git a/fog/im165.png b/fog/im165.png
new file mode 100644
index 00000000..c1e193ca
Binary files /dev/null and b/fog/im165.png differ
diff --git a/fog/im166.png b/fog/im166.png
new file mode 100644
index 00000000..6d4e5860
Binary files /dev/null and b/fog/im166.png differ
diff --git a/fog/im167.png b/fog/im167.png
new file mode 100644
index 00000000..1738ea29
Binary files /dev/null and b/fog/im167.png differ
diff --git a/fog/im168.png b/fog/im168.png
new file mode 100644
index 00000000..40d7212e
Binary files /dev/null and b/fog/im168.png differ
diff --git a/fog/im169.png b/fog/im169.png
new file mode 100644
index 00000000..0a7b84e7
Binary files /dev/null and b/fog/im169.png differ
diff --git a/fog/im170.png b/fog/im170.png
new file mode 100644
index 00000000..bc49e733
Binary files /dev/null and b/fog/im170.png differ
diff --git a/fog/im171.png b/fog/im171.png
new file mode 100644
index 00000000..e6d907e6
Binary files /dev/null and b/fog/im171.png differ
diff --git a/fog/im172.png b/fog/im172.png
new file mode 100644
index 00000000..a358a833
Binary files /dev/null and b/fog/im172.png differ
diff --git a/fog/im173.png b/fog/im173.png
new file mode 100644
index 00000000..99a9cd6e
Binary files /dev/null and b/fog/im173.png differ
diff --git a/fog/im174.png b/fog/im174.png
new file mode 100644
index 00000000..4419a31c
Binary files /dev/null and b/fog/im174.png differ
diff --git a/fog/im175.png b/fog/im175.png
new file mode 100644
index 00000000..ce3b5158
Binary files /dev/null and b/fog/im175.png differ
diff --git a/fog/im176.png b/fog/im176.png
new file mode 100644
index 00000000..ccdc0aa2
Binary files /dev/null and b/fog/im176.png differ
diff --git a/fog/im177.png b/fog/im177.png
new file mode 100644
index 00000000..b086780c
Binary files /dev/null and b/fog/im177.png differ
diff --git a/fog/im178.png b/fog/im178.png
new file mode 100644
index 00000000..3eed8f3a
Binary files /dev/null and b/fog/im178.png differ
diff --git a/fog/im179.png b/fog/im179.png
new file mode 100644
index 00000000..5b648052
Binary files /dev/null and b/fog/im179.png differ
diff --git a/fog/im180.png b/fog/im180.png
new file mode 100644
index 00000000..bc2a1fa5
Binary files /dev/null and b/fog/im180.png differ
diff --git a/fog/im181.png b/fog/im181.png
new file mode 100644
index 00000000..7f3196b5
Binary files /dev/null and b/fog/im181.png differ
diff --git a/fog/im182.png b/fog/im182.png
new file mode 100644
index 00000000..76d81328
Binary files /dev/null and b/fog/im182.png differ
diff --git a/fog/im183.png b/fog/im183.png
new file mode 100644
index 00000000..5d2c07fa
Binary files /dev/null and b/fog/im183.png differ
diff --git a/fog/im184.png b/fog/im184.png
new file mode 100644
index 00000000..555ca94c
Binary files /dev/null and b/fog/im184.png differ
diff --git a/fog/im185.png b/fog/im185.png
new file mode 100644
index 00000000..040b2cf6
Binary files /dev/null and b/fog/im185.png differ
diff --git a/fog/im186.png b/fog/im186.png
new file mode 100644
index 00000000..f1c2d8ce
Binary files /dev/null and b/fog/im186.png differ
diff --git a/fog/im187.png b/fog/im187.png
new file mode 100644
index 00000000..aab40938
Binary files /dev/null and b/fog/im187.png differ
diff --git a/fog/im188.png b/fog/im188.png
new file mode 100644
index 00000000..db9d6dd4
Binary files /dev/null and b/fog/im188.png differ
diff --git a/fog/im189.png b/fog/im189.png
new file mode 100644
index 00000000..beb4977f
Binary files /dev/null and b/fog/im189.png differ
diff --git a/fog/im190.png b/fog/im190.png
new file mode 100644
index 00000000..06a4cfa7
Binary files /dev/null and b/fog/im190.png differ
diff --git a/fog/im191.png b/fog/im191.png
new file mode 100644
index 00000000..25c6fa68
Binary files /dev/null and b/fog/im191.png differ
diff --git a/resources/fonts/Small.idx b/resources/fonts/Small.idx
deleted file mode 100644
index 7c80fe60..00000000
--- a/resources/fonts/Small.idx
+++ /dev/null
@@ -1,159 +0,0 @@
-width       8
-height      16
-0   0   6   7
-1   1   6   7
-2   2   6   7
-3   3   6   7
-4   4   6   7
-5   5   6   7
-6   6   6   7
-7   7   6   7
-8   8   6   7
-9   9   6   7
-A   0   1   5
-B   1   1   5
-C   2   1   5
-D   3   1   5
-E   4   1   5
-F   5   1   5
-G   6   1   6
-H   7   1   5
-I   8   1   4
-J   9   1   6
-K   10   1   6
-L   11   1   4
-M   12   1   6
-N   13   1   6
-O   14   1   6
-P   15   1   5
-Q   16   1   7
-R   17   1   5
-S   18   1   5
-T   19   1   6
-U   20   1   6
-V   21   1   6
-W   22   1   7
-X   23   1   8
-Y   24   1   6
-Z   25   1   6
-a   0   0   6
-b   1   0   5
-c   2   0   5
-d   3   0   5
-e   4   0   5
-f   5   0   4
-g   6   0   6
-h   7   0   5
-i   8   0   2
-j   9   0   4
-k   10   0   5
-l   11   0   2
-m   12   0   6
-n   13   0   5
-o   14   0   5
-p   15   0   5
-q   16   0   5
-r   17   0   4
-s   18   0   5
-t   19   0   4
-u   20   0   5
-v   21   0   6
-w   22   0   6
-x   23   0   6
-y   24   0   5
-z   25   0   5
-á   0   2   6      
-à   1   2   6
-â   2   2   6
-å   3   2   6
-ä   4   2   6
-é   5   2   5
-è   6   2   5
-ê   7   2   5
-ë   8   2   5
-í   9    2   3
-ì   10   2   3
-î   11   2   3
-ï   12   2   3
-ó   14   2   5
-ò   15   2   5
-ô   16   2   5
-ö   17   2   5
-ø   18   2   6
-ú   20   2   5
-ù   21   2   5
-û   22   2   5
-ü   23   2   5
-ý   24   2   5
-ÿ   25   2   5
-æ   26   2   8   
-Á   0   3   5
-À   1   3   5
-Â   2   3   6
-Ä   4   3   6
-Å   3   3   6
-É   5   3   5
-È   6   3   5
-Ê   7   3   5
-Ë   8   3   5
-Í   9   3   4
-Ì   10   3   4
-Î   11   3   4
-Ï   12   3   4
-Ó   14   3   6
-Ò   15   3   6
-Ô   16   3   7
-Ö   17   3   7
-Ø   18   3   7   
-Ú   20   3   6
-Ù   21   3   6
-Û   22   3   7
-Ü   23   3   7
-Ý   24   3   6
-Ÿ   25   3   6
-Æ   26   3   8
-ç   2   4   5
-ð   3   4   6
-ñ   12   4   5
-ŋ   13   4   5
-þ   15   4   5
-ß   18   4   6
-ƿ   22   4   5
-œ   26   4   8
-Ç   2   5   5
-Ð   3   5   6
-Ñ   12   5   6
-Þ   15   5   5
-⁊   18   5   5
-Ƿ   22   5   5
-Œ   26   5   8
-!   13   6   3
-¡   26   1   3
-#   22   6   7
-&   23   6   7
-(   14   6   4
-)   15   6   4
--   16   6   7
-+   26   6   7
-\   18   6   6
-;   20   6   2
-:   21   6   2
-'   25   6   3
-,   11   6   2
-.   10   6   2
-/   17   6   6
-?   19   6   7
-¿   26   0   7
-space 27 1   4
-"   24   6   4
-<   11   7   8
->   21   7   8
-$   12   6   8
-{   7   7   8
-}   15   7   8
-~   0   7   8
-`   1   7   8
-@   2   7   8
-^   3   7   8
-*   4   7   8
-%   18  7   8
\ No newline at end of file
diff --git a/resources/fonts/runes-white.png b/resources/fonts/runes-white.png
new file mode 100644
index 00000000..a34361a1
Binary files /dev/null and b/resources/fonts/runes-white.png differ
diff --git a/resources/fonts/runes.idx b/resources/fonts/runes.idx
new file mode 100644
index 00000000..39ac0c7d
--- /dev/null
+++ b/resources/fonts/runes.idx
@@ -0,0 +1,71 @@
+width       8
+height      16
+0   0   2   7
+1   1   2   7
+2   2   2   7
+3   3   2   7
+4   4   2   7
+5   5   2   7
+6   6   2   7
+7   7   2   7
+8   8   2   7
+9   9   2   7
+A   0   0   6
+Á   1   0   6
+E   2   0   6
+É   3   0   6
+I   4   0   3
+Í   5   0   6
+O   6   0   6
+Ó   7   0   6
+U   8   0   6
+Ú   9   0   6
+Ö   10   0   6
+Ï   11   0   6
+Ü   12   0   6
+Ä   13   0   6
+B   0   1   5
+D   1   1   6
+F   2   1   5
+G   3   1   5
+H   4   1   5
+J   5   1   6
+K   6   1   5
+L   7   1   5
+M   8   1   6
+N   9   1   6
+P   10   1   5
+R   11   1   6
+S   12   1   6
+T   13   1   5
+V   14   1   5
+W   15   1   6
+Y   16   1   5
+Z   17   1   6
+C   18   1   6
+Ç   19   1   5
+Þ   20   1   5
+X   21   1   6
+Ë   22   1   5
+!   13   2   3
+¡   26   1   3
+#   22   2   7
+&   16   0   7
+<   27   1   6
+>   27   0   6   
+(   14   2   4
+)   15   2   4
+-   16   2   6
++   26   2   7
+\   18   2   6
+;   20   2   2
+:   21   2   2
+'   25   2   3
+,   11   2   2
+.   10   2   2
+/   17   2   6
+?   19   2   7
+¿   26   2   7
+space 25 0   4
+"   24   2   4
+_   27   2   7
\ No newline at end of file
diff --git a/resources/fonts/small-white.png b/resources/fonts/small-white.png
index 99e84d3f..49a7e7b2 100644
Binary files a/resources/fonts/small-white.png and b/resources/fonts/small-white.png differ
diff --git a/resources/fonts/small.idx b/resources/fonts/small.idx
index 7c80fe60..b6edfa7b 100644
--- a/resources/fonts/small.idx
+++ b/resources/fonts/small.idx
@@ -14,21 +14,21 @@ A   0   1   5
 B   1   1   5
 C   2   1   5
 D   3   1   5
-E   4   1   5
+E   4   1   4
 F   5   1   5
 G   6   1   6
 H   7   1   5
 I   8   1   4
 J   9   1   6
-K   10   1   6
+K   10   1   5
 L   11   1   4
 M   12   1   6
 N   13   1   6
-O   14   1   6
+O   14   1   5
 P   15   1   5
 Q   16   1   7
 R   17   1   5
-S   18   1   5
+S   18   1   4
 T   19   1   6
 U   20   1   6
 V   21   1   6
diff --git a/run_engine.py b/run_engine.py
index 30f917b7..1839b03d 100644
--- a/run_engine.py
+++ b/run_engine.py
@@ -53,10 +53,10 @@ if __name__ == '__main__':
         source_generator.generate_component_system_source()
 
     try:
-        find_and_run_project()
+        # find_and_run_project()
         # main('lion_throne')
         # test_play('lion_throne')
-        # test_play('sacred_stones')
+        test_play('sacred_stones')
     except Exception as e:
         logging.exception(e)
         inform_error()
diff --git a/sacred_stones.ltproj/resources/tilemaps/tilemap.json b/sacred_stones.ltproj/resources/tilemaps/tilemap.json
index e0599842..71936fde 100644
--- a/sacred_stones.ltproj/resources/tilemaps/tilemap.json
+++ b/sacred_stones.ltproj/resources/tilemaps/tilemap.json
@@ -2444,7 +2444,7 @@
     {
         "nid": "Chapter 2",
         "size": [
-            15,
+            17,
             15
         ],
         "autotile_fps": 29,
@@ -4254,6 +4254,216 @@
                             14,
                             8
                         ]
+                    ],
+                    "15,0": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,1": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,2": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,3": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,4": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,5": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,6": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,7": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,8": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,9": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,10": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,11": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,12": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,13": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "15,14": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,0": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,1": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,2": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,3": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,4": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,5": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,6": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,7": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,8": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,9": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,10": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,11": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,12": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,13": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
+                    ],
+                    "16,14": [
+                        "Chpt2",
+                        [
+                            0,
+                            5
+                        ]
                     ]
                 }
             },
diff --git a/sprites/info_menu/info_menu_background.png b/sprites/info_menu/info_menu_background.png
new file mode 100644
index 00000000..6c1f5df8
Binary files /dev/null and b/sprites/info_menu/info_menu_background.png differ
diff --git a/sprites/info_menu/stat_screen_background.png b/sprites/info_menu/stat_screen_background.png
new file mode 100644
index 00000000..4da73a5c
Binary files /dev/null and b/sprites/info_menu/stat_screen_background.png differ
diff --git a/sprites/info_menu/stat_screen_background_old.png b/sprites/info_menu/stat_screen_background_old.png
new file mode 100644
index 00000000..a4f7d0ac
Binary files /dev/null and b/sprites/info_menu/stat_screen_background_old.png differ
diff --git a/sprites/info_menu/stat_screen_background_v1.png b/sprites/info_menu/stat_screen_background_v1.png
new file mode 100644
index 00000000..4c4e72c8
Binary files /dev/null and b/sprites/info_menu/stat_screen_background_v1.png differ
diff --git a/sprites/particles/particle_fog_mote.png b/sprites/particles/particle_fog_mote.png
new file mode 100644
index 00000000..b1a02bbd
Binary files /dev/null and b/sprites/particles/particle_fog_mote.png differ
diff --git a/utilities/class_data.txt b/utilities/class_data.txt
new file mode 100644
index 00000000..f9e849c7
--- /dev/null
+++ b/utilities/class_data.txt
@@ -0,0 +1,73 @@
+POW: Low: 3 35% High: 7 70%
+Dagger users get +2 base
+Sword users get +3 base
+Bow users get +4 base
+Lance users get +5 base
+Greatsword users get +6 base
+1. Peg Knight, Thief (3, 35%)
+2. Skirmisher, Hunter (4, 40%)
+3. Myrmidon, Nomad (4, 45%)
+4. Cavalier, Errant, Soldier (5, 50%)
+5. Archer, Mercenary (5, 55%)
+6. Raider, Armor (6, 60%)
+7. Knight, Wyvern (6, 65%)
+8. Fighter, Brigand (7, 70%)
+
+DEF: Low: 0 15% High: 6 55%
+1. Thief (1, 15%)
+2. Peg Knight, Hunter, Nomad, Myrmidon, Brigand (1, 20%)
+3. Raider, Skirmisher (2, 25%)
+4. Cavalier, Mercenary, Archer, Soldier (3, 30%)
+5. Fighter (2, 35%)
+5. Errant (4, 35%)
+6. Wyvern, Knight (5, 45%)
+7. Armor (6, 55%)
+
+HP: Low: 16 65% High: 24 120%
+1. Thief (16, 65%)
+2. Peg Knight (16, 80%)
+3. Hunter, Skirmisher (17, 85%)
+4. Archer, Myrmidon, Soldier (18, 95%)
+5. Cavalier, Nomad, Armor (20, 100%)
+6. Wyvern, Mercenary, Errant (22, 105%)
+7. Fighter, Knight (24, 110%)
+8. Raider, Brigand (24, 120%)
+
+SKL: Low 3 35% High: 7 60%
+Dagger users get +5 base
+Sword users get +5 base
+Bow users get +4 base
+Lance users get +2 base
+Greatsword users get +0 base
+1. Brigand (2, 30%)
+1. Fighter (3, 35%)
+2. Errant, Raider (4, 40%)
+3. Wyvern Rider, Knight, Nomad (4, 45%)
+4. Cavalier, Thief (5, 45%)
+5. Peg Knight, Skirmisher, Hunter (6, 50%)
+6. Archer, Soldier (6, 55%)
+6. Armor (7, 55%)
+7. Myrmidon, Mercenary (7, 60%)
+
+SPD: Low 1 25% High: 8 70%
+1. Armor (1, 20%)
+1. Knight (2, 25%)
+2. Wyvern Rider, Fighter, Soldier, Brigand (3, 35%)
+3. Archer (3, 40%)
+4. Cavalier, Mercenary (4, 45%)
+5. Raider, Nomad, Errant (5, 50%)
+6. Myrmidon, Hunter (7, 60%)
+7. Skirmisher (7, 65%)
+8. Thief (8, 65%)
+8. Peg Knight (8, 70%)
+
+BRV: Low 3 35% High: 7 60%
+1. Armor (1, 20%)
+2. Thief, Soldier, Brigand (2, 30%)
+2. Archer (3, 35%)
+3. Cavalier, Wyvern Rider (4, 40%)
+4. Fighter, Knight (5, 45%)
+5. Mercenary, Hunter, Raider, Nomad, Errant (6, 50%)
+6. Myrmidon (8, 55%)
+7. Skirmisher (9, 65%)
+8. Peg Knight (10, 70%)
\ No newline at end of file
diff --git a/utilities/memento_mori_todo.txt b/utilities/memento_mori_todo.txt
new file mode 100644
index 00000000..dc716770
--- /dev/null
+++ b/utilities/memento_mori_todo.txt
@@ -0,0 +1,74 @@
+Enemies:
+Thieves
+Skirmishers
+Brigands
+Mercenaries
+Hunter
+Mage?
+
+Goals:
+
+Open treasure chests
+Save Civilians
+Recruit Skirmisher/Thief Girl (Piper?)
+Recruit Millie
+
+For vertical slice
+Chapter 3 and 4
+Alternate forms of Chapter 3 and 4
+Overworld
+Implement Skills
+Write Script
+How does pair up work?
+    - Adjacent units can lend an attack, dealing half their normal damage
+    - Higher support bonuses grant stat buffs (or maybe by default and class or stat based?)
+    - Higher support bonuses grant chance to block or limit an attack (crit -> hit, hit -> glance, glance -> miss?)??
+Combat UI
+ - Unit who is talking gets nametag
+Implement Wyllt
+No Free Roam Base:
+    - Instead, after every 3rd chapter, forced free roam "dream" sequence where you can talk to each character in the party, and perhaps even dead characters.
+    - You can also get items and even find items.
+    - Certain choices you make in the free roam section can change things up
+    - Then you wake up back in the overworld map
+Dream conversations
+Title Screen
+Portraits
+Personal Skills / Grave Weapons
+ - Tile bonuses
+    - Forest (+3 SKL, +3 SPD)
+    - Hill (+1 POW, +2 BRV)
+    - Mountain (+2 POW, +3 BRV)
+    - River (-3 SPD, -1 DEF)
+    - Pillar (+3 SPD)
+    - Fort (+3 DEF))
+    - Plain (no bonus)
+    - Sand (no bonus)
+    - Snow (no bonus)
+    - Stairs (-2 SPD)
+Playtest playtest playtest
+
+Portraits:
+Ash (M) Pale skin, dark colors
+Pale (F) Dark skin, white hair, nature wild girl mystical waif aesthetic
+Cedric (M) Blond hair
+Aelfred (M) Red hair
+Ceabbi (F) Blond hair
+Ceathrun (F) Blond hair
+Magnus (M) Blue hair
+Istrid (F) Witch, Purple hair
+Tristan (M) Ophie 
+Isolde (F) Green hair
+---
+Aelfwynn (F) Red hair
+Eadan (M) Green hair
+Bjorn (M) Blond hair
+Millie (F) Blue hair
+Anna (F) Orange hair
+Willow (F) Black hair
+Wound (Dog)
+Sorrel (M) Dark skin, brown hair
+Clover (F) Dark skin, brown hair
+Rhun (M) Amber hair
+*Piper (F) Dark skin, purple hair?
+*Rhodri (M) Amber hair, strong lad
diff --git a/utilities/testing_stats_v2.py b/utilities/testing_stats_v2.py
index 5ad4948c..7dec1c70 100644
--- a/utilities/testing_stats_v2.py
+++ b/utilities/testing_stats_v2.py
@@ -12,31 +12,98 @@ class Character():
     BRV: int = 0
     DEF: int = 0
 
-myrm = Character('Myrmidon', 5, 19, 11, 17, 13, 12, 2)
-fighter = Character('Fighter', 5, 29, 19, 9, 7, 6, 2)
-knight = Character('Knight', 5, 24, 15, 16, 4, 3, 8)
-merc = Character('Mercenary', 5, 26, 14, 18, 9, 9, 3)
-cavalier = Character('Cavalier', 5, 23, 14, 13, 8, 7, 3)
-peg_knight = Character('Peg Knight', 5, 17, 10, 15, 14, 11, 1)
-wyvern_knight = Character('Wyvern', 5, 27, 18, 12, 6, 8, 6)
-thief = Character('Thief', 5, 17, 9, 14, 15, 8, 1)
-soldier = Character('Soldier', 5, 20, 14, 15, 5, 1, 3)
-brigand = Character('Brigand', 5, 30, 18, 8, 6, 9, 0)
-lord = Character('Lord', 5, 25, 13, 15, 10, 10, 3)
+@dataclass
+class Growths():
+    name: str = ''
+    HP: float = 0
+    POW: float = 0
+    SKL: float = 0
+    SPD: float = 0
+    BRV: float = 0
+    DEF: float = 0
+
+def sum_stats(char):
+    return char.HP // 2 + char.POW + char.SKL + char.SPD + char.BRV + char.DEF
+
+def create_char(char: Character, growths: Growths, lvl: int):
+    new_char = Character(char.name, lvl)
+    increase = lvl - char.LVL
+    offset = 50 if increase > 0 else -50
+    new_char.HP = char.HP + int((growths.HP * increase + offset) / 100)
+    new_char.POW = char.POW + int((growths.POW * increase + offset) / 100)
+    new_char.SKL = char.SKL + int((growths.SKL * increase + offset) / 100)
+    new_char.SPD = char.SPD + int((growths.SPD * increase + offset) / 100)
+    new_char.BRV = char.BRV + int((growths.BRV * increase + offset) / 100)
+    new_char.DEF = char.DEF + int((growths.DEF * increase + offset) / 100)
+    return new_char
+
+myrm = Character('Myrmidon', 1, 19, 10, 15, 11, 11, 2)
+fighter = Character('Fighter', 1, 29, 15, 6, 5, 7, 3)
+armor = Character('Armor', 1, 24, 13, 14, 2, 2, 8)
+merc = Character('Mercenary', 1, 26, 12, 16, 7, 8, 3)
+cavalier = Character('Cavalier', 1, 23, 12, 11, 6, 5, 5)
+peg_knight = Character('Peg Knight', 1, 17, 9, 13, 11, 10, 1)
+wyvern_knight = Character('Wyvern', 1, 27, 14, 10, 4, 6, 7)
+nomad = Character('Nomad', 1, 23, 12, 11, 6, 5, 5)
+thief = Character('Thief', 1, 17, 8, 12, 12, 7, 1)
+skirm = Character('Skirmisher', 1, 17, 8, 12, 12, 7, 1)
+errant = Character('Errant', 1, 25, 11, 13, 9, 9, 3)
+knight = Character('Knight', 1, 25, 11, 13, 9, 9, 3)
+archer = Character('Archer', 1, 20, 11, 15, 4, 2, 2)
+hunter = Character('Hunter', 1, 18, 10, 12, 10, 9, 1)
+raider = Character('Raider', 1, 30, 15, 6, 4, 9, 1)
+soldier = Character('Soldier', 1, 20, 12, 15, 3, 1, 4)
+brigand = Character('Brigand', 1, 30, 15, 6, 4, 9, 1)
+
+mage = Character('Mage', 5, 18, 12, 10, 9, 6, 1)
 
-myrm20 = Character('Myrmidon', 20, 32, 20, 26, 25, 20, 6)
-fighter20 = Character('Fighter', 20, 46, 29, 15, 12, 14, 9)
-knight20 = Character('Knight', 20, 36, 24, 27, 7, 8, 16)
+myrm_growths = Growths('Myrmidon', 95, 45, 65, 65, 55, 25)
+fighter_growths = Growths('Fighter', 145, 70, 45, 40, 45, 35)
+armor_growths = Growths('Armor', 115, 55, 70, 25, 25, 55)
+merc_growths = Growths('Mercenary', 130, 55, 60, 55, 60, 30)
+cav_growths = Growths('Cavalier', 110, 55, 65, 45, 40, 40)
+peg_growths = Growths('Peg Knight', 85, 35, 50, 75, 70, 20)
+wyvern_growths = Growths('Wyvern', 135, 60, 45, 40, 50, 45)
+nomad_growths = Growths('Nomad', 110, 55, 65, 45, 40, 40)
+thief_growths = Growths('Thief', 90, 30, 45, 80, 35, 20)
+skirm_growths = Growths('Skirmisher', 90, 30, 45, 80, 35, 20)
+errant_growths = Growths('Errant', 120, 50, 60, 55, 65, 45)
+knight_growths = Growths('Knight', 120, 50, 60, 55, 65, 45)
+archer_growths = Growths('Archer', 100, 55, 70, 40, 35, 30)
+hunter_growths = Growths('Hunter', 90, 45, 50, 70, 45, 25)
+raider_growths = Growths('Raider', 155, 60, 25, 40, 55, 25)
+soldier_growths = Growths('Soldier', 105, 55, 60, 35, 25, 45)
+brigand_growths = Growths('Brigand', 155, 60, 25, 40, 55, 25)
 
-swordmaster30 = Character('Swordmaster', 30, 47, 29, 36, 34, 29, 11)
-warrior30 = Character('Warrior', 30, 68, 39, 23, 20, 24, 16)
-general30 = Character('General', 30, 56, 34, 36, 12, 14, 24)
+mage_growths = Growths('Mage', 105, 55, 40, 55, 40, 20)
+
+for stat, growth in [(myrm, myrm_growths), (fighter, fighter_growths), (knight, knight_growths),
+                     (merc, merc_growths), (cavalier, cav_growths), (peg_knight, peg_growths),
+                     (wyvern_knight, wyvern_growths), (thief, thief_growths), (soldier, soldier_growths),
+                     (brigand, brigand_growths), (errant, errant_growths), (archer, archer_growths), 
+                     (hunter, hunter_growths), (mage, mage_growths)]:
+    c1 = create_char(stat, growth, 1)
+    c5 = create_char(stat, growth, 5)
+    c10 = create_char(stat, growth, 10)
+    c20 = create_char(stat, growth, 20)
+    c30 = create_char(stat, growth, 30)
+    print(c1)
+    print(c5)
+    print(c10)
+    print(c20)
+    print(c30)
+    print(sum_stats(c30))
+
+myrm20 = create_char(myrm, myrm_growths, 20)
+fighter20 = create_char(fighter, fighter_growths, 20)
+knight20 = create_char(knight, knight_growths, 20)
+errant20 = create_char(errant, errant_growths, 20)
 
 def arena(u1, u2):
-    mt1 = u1.POW - u2.DEF
-    mt2 = u2.POW - u1.DEF
-    hit1 = u1.SKL*5 + 50 - u2.SPD*5
-    hit2 = u2.SKL*5 + 50 - u1.SPD*5
+    mt1 = max(1, u1.POW - u2.DEF)
+    mt2 = max(1, u2.POW - u1.DEF)
+    hit1 = u1.SKL*4 + 50 - u2.SPD*4 - 10
+    hit2 = u2.SKL*4 + 50 - u1.SPD*4 - 10
     as1 = u1.BRV > u2.SPD
     as2 = u2.BRV > u1.SPD
 
@@ -77,6 +144,15 @@ print("")
 arena(knight, knight)
 """
 import itertools
-for pair in itertools.combinations([myrm, knight, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, lord], 2):
+comb = [myrm, armor, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, errant]
+comb = [myrm, armor, fighter]
+# comb = []
+for pair in itertools.combinations(comb, 2):
+    print("")
+    arena(*pair)
+
+comb = [myrm20, knight20, fighter20]
+# comb = []
+for pair in itertools.combinations(comb, 2):
     print("")
     arena(*pair)
diff --git a/utilities/testing_stats_v3.py b/utilities/testing_stats_v3.py
new file mode 100644
index 00000000..f38cde8c
--- /dev/null
+++ b/utilities/testing_stats_v3.py
@@ -0,0 +1,172 @@
+import math
+from dataclasses import dataclass
+
+@dataclass
+class Character():
+    name: str = ''
+    LVL: int = 1
+    HP: int = 1
+    POW: int = 0
+    SKL: int = 0
+    SPD: int = 0
+    BRV: int = 0
+    DEF: int = 0
+
+@dataclass
+class Growths():
+    name: str = ''
+    HP: float = 0
+    POW: float = 0
+    SKL: float = 0
+    SPD: float = 0
+    BRV: float = 0
+    DEF: float = 0
+
+def sum_stats(char):
+    return char.HP // 2 + char.POW + char.SKL + char.SPD + char.BRV + char.DEF
+
+def create_char(char: Character, growths: Growths, lvl: int):
+    new_char = Character(char.name, lvl)
+    increase = lvl - char.LVL
+    offset = 50 if increase > 0 else -50
+    new_char.HP = char.HP + int((growths.HP * increase + offset) / 100)
+    new_char.POW = char.POW + int((growths.POW * increase + offset) / 100)
+    new_char.SKL = char.SKL + int((growths.SKL * increase + offset) / 100)
+    new_char.SPD = char.SPD + int((growths.SPD * increase + offset) / 100)
+    new_char.BRV = char.BRV + int((growths.BRV * increase + offset) / 100)
+    new_char.DEF = char.DEF + int((growths.DEF * increase + offset) / 100)
+    return new_char
+
+# Sword users
+myrm = Character('Myrmidon', 1, 18, 7, 12, 7, 8, 1)
+myrm_growths = Growths('Myrmidon', 95, 45, 60, 60, 55, 20)
+errant = Character('Errant', 1, 22, 8, 9, 5, 6, 4)
+errant_growths = Growths('Errant', 105, 50, 40, 50, 50, 35)
+skirm = Character('Skirmisher', 1, 17, 6, 8, 7, 9, 2)
+skirm_growths = Growths('Skirmisher', 85, 40, 50, 65, 65, 25)
+sword_users = [(myrm, myrm_growths), (errant, errant_growths), (skirm, skirm_growths)]
+# Lance users
+armor = Character('Armor', 1, 20, 11, 9, 1, 1, 6)
+armor_growths = Growths('Armor', 100, 60, 55, 20, 20, 55)
+cavalier = Character('Cavalier', 1, 20, 10, 7, 4, 4, 3)
+cav_growths = Growths('Cavalier', 100, 50, 45, 45, 40, 30)
+peg_knight = Character('Peg Knight', 1, 16, 8, 8, 8, 10, 1)
+peg_growths = Growths('Peg Knight', 80, 35, 50, 70, 70, 20)
+wyvern_knight = Character('Wyvern', 1, 22, 11, 6, 3, 4, 5)
+wyvern_growths = Growths('Wyvern', 105, 65, 45, 35, 40, 45)
+lance_users = [(armor, armor_growths), (cavalier, cav_growths), (peg_knight, peg_growths), (wyvern_knight, wyvern_growths)]
+# Greatsword users
+fighter = Character('Fighter', 1, 24, 13, 3, 3, 5, 2)
+fighter_growths = Growths('Fighter', 110, 70, 35, 35, 45, 35)
+raider = Character('Raider', 1, 24, 12, 4, 5, 6, 1)
+raider_growths = Growths('Raider', 120, 60, 40, 50, 50, 25)
+merc = Character('Mercenary', 1, 22, 8, 12, 4, 6, 3)
+merc_growths = Growths('Mercenary', 105, 55, 60, 45, 50, 30)
+knight = Character('Knight', 1, 24, 10, 4, 2, 5, 5)
+knight_growths = Growths('Knight', 110, 65, 45, 25, 45, 45)
+greatsword_users = [(fighter, fighter_growths), (raider, raider_growths), (merc, merc_growths), (knight, knight_growths)]
+# Dagger users
+thief = Character('Thief', 1, 16, 5, 10, 8, 2, 1)
+thief_growths = Growths('Thief', 65, 35, 45, 65, 30, 15)
+dagger_users = [(thief, thief_growths)]
+# Bow users
+archer = Character('Archer', 1, 18, 9, 10, 3, 3, 3)
+archer_growths = Growths('Archer', 95, 55, 55, 40, 35, 30)
+hunter = Character('Hunter', 1, 17, 8, 10, 7, 6, 1)
+hunter_growths = Growths('Hunter', 85, 40, 50, 60, 50, 20)
+nomad = Character('Nomad', 1, 20, 8, 8, 5, 6, 1)
+nomad_growths = Growths('Nomad', 100, 45, 45, 50, 50, 20)
+bow_users = [(archer, archer_growths), (hunter, hunter_growths), (nomad, nomad_growths)]
+
+soldier = Character('Soldier', 1, 18, 7, 8, 3, 2, 3)
+soldier_growths = Growths('Soldier', 95, 50, 55, 35, 30, 30)
+brigand = Character('Brigand', 1, 24, 13, 2, 3, 2, 1)
+brigand_growths = Growths('Brigand', 120, 70, 30, 35, 30, 20)
+weak_users = [(soldier, soldier_growths), (brigand, brigand_growths)]
+
+mage = Character('Mage', 5, 18, 12, 10, 9, 6, 1)
+mage_growths = Growths('Mage', 105, 55, 40, 55, 40, 20)
+
+all_stats = sword_users + lance_users + greatsword_users + dagger_users + bow_users + weak_users
+level_20s = []
+level_30s = []
+for stat, growth in all_stats:
+    c1 = create_char(stat, growth, 1)
+    c5 = create_char(stat, growth, 5)
+    c10 = create_char(stat, growth, 10)
+    c20 = create_char(stat, growth, 20)
+    c30 = create_char(stat, growth, 30)
+    print(c1)
+    print(c5)
+    print(c10)
+    print(c20)
+    level_20s.append(c20)
+    print(c30)
+    level_30s.append(c30)
+    print(sum_stats(c30))
+
+myrm20 = create_char(myrm, myrm_growths, 20)
+fighter20 = create_char(fighter, fighter_growths, 20)
+armor20 = create_char(armor, armor_growths, 20)
+
+def arena(u1, u2):
+    mt1 = max(1, u1.POW - u2.DEF)
+    mt2 = max(1, u2.POW - u1.DEF)
+    hit1 = u1.SKL*4 + 70 - u2.SPD*4
+    hit2 = u2.SKL*4 + 70 - u1.SPD*4
+    as1 = u1.BRV > u2.SPD
+    as2 = u2.BRV > u1.SPD
+
+    print("%s: HP: %d Mt: %d Hit: %d Double: %s" % (u1.name, u1.HP, mt1, hit1, as1))
+    print("%s: HP: %d Mt: %d Hit: %d Double: %s" % (u2.name, u2.HP, mt2, hit2, as2))
+    min_num_rounds_to_ko1 = math.ceil(u2.HP / mt1 / (1.5 if as1 else 1)) if hit1 > 0 else 99
+    min_num_rounds_to_ko2 = math.ceil(u1.HP / mt2 / (1.5 if as2 else 1)) if hit2 > 0 else 99
+    avg_num_rounds_to_ko1 = math.ceil(u2.HP / (mt1 * min(1, hit1/100)) / (1.5 if as1 else 1)) if hit1 > 0 else 99
+    avg_num_rounds_to_ko2 = math.ceil(u1.HP / (mt2 * min(1, hit2/100)) / (1.5 if as2 else 1)) if hit2 > 0 else 99
+    print("%s KOs %s in %d rounds (min: %d rounds)" % (u1.name, u2.name, avg_num_rounds_to_ko1, min_num_rounds_to_ko1))
+    print("%s KOs %s in %d rounds (min: %d rounds)" % (u2.name, u1.name, avg_num_rounds_to_ko2, min_num_rounds_to_ko2))
+
+"""
+arena(myrm, fighter)
+print("")
+arena(myrm, knight)
+print("")
+arena(fighter, knight)
+print("")
+arena(myrm20, fighter20)
+print("")
+arena(myrm20, knight20)
+print("")
+arena(fighter20, knight20)
+print("")
+arena(swordmaster30, warrior30)
+print("")
+arena(swordmaster30, general30)
+print("")
+arena(warrior30, general30)
+print("")
+arena(fighter, merc)
+print("")
+arena(myrm, myrm)
+print("")
+arena(fighter, fighter)
+print("")
+arena(knight, knight)
+"""
+import itertools
+comb = [myrm, armor, fighter, merc, cavalier, peg_knight, wyvern_knight, thief, soldier, brigand, errant]
+comb = [myrm, armor, fighter]
+# comb = []
+for pair in itertools.combinations(comb, 2):
+    print("")
+    arena(*pair)
+
+comb = [myrm20, armor20, fighter20]
+# comb = []
+for pair in itertools.combinations(comb, 2):
+    print("")
+    arena(*pair)
+
+pow_sort = sorted(level_30s, key=lambda x: x.BRV)
+for char in pow_sort:
+    print(char)
diff --git a/utilities/value_noise_generator.py b/utilities/value_noise_generator.py
new file mode 100644
index 00000000..672db98c
--- /dev/null
+++ b/utilities/value_noise_generator.py
@@ -0,0 +1,103 @@
+import random, math
+
+# from app.engine import engine
+
+import time
+from PIL import Image
+
+class ValueNoise():
+    num_octaves = 5
+    pixels_per_lattice = 24
+    pixel_depth = 48 * 4
+
+    def __init__(self, width: int, height: int):
+        self.pixel_width = width
+        self.pixel_height = height
+        self.lattice_width = width // self.pixels_per_lattice
+        self.lattice_height = height // self.pixels_per_lattice
+        self.lattice_depth = self.pixel_depth // self.pixels_per_lattice
+        self.lattice_depth //= 4
+
+        self.noise_map = self.generate_full_noise_map()
+
+    def generate_full_noise_map(self):
+        frequency = 0.25
+        frequency_mult = 2  # lacunarity
+        amplitude_mult = 0.35
+        amplitude = 1
+        true_noise_map = [0 for _ in range(self.pixel_width * self.pixel_height * self.pixel_depth)]
+        for i in range(self.num_octaves):
+            print("Octave: %d" % i)
+            noise_map = self.generate_noise_map(frequency)
+            noise_map = [v * amplitude for v in noise_map]
+            amplitude *= amplitude_mult
+            frequency *= frequency_mult
+            true_noise_map = [n + tn for n, tn in zip(noise_map, true_noise_map)]
+        # normalize map
+        max_value = max(true_noise_map)
+        true_noise_map = [v / max_value for v in true_noise_map]
+        return true_noise_map
+
+    def _interp(self, a, b, t):
+        # t should be in range 0 to 1
+        remap_t = t * t * (3 - 2 * t)
+        return a * (1 - remap_t) + b * remap_t
+
+    def generate_noise_map(self, frequency):
+        randoms = [random.random() for _ in range(self.lattice_width * self.lattice_height * self.lattice_depth)]
+        noise_map = []
+        for pz in range(self.pixel_depth):
+            print(pz)
+            for px in range(self.pixel_width):
+                for py in range(self.pixel_height):
+                    lx = px * frequency / self.pixels_per_lattice
+                    ly = py * frequency / self.pixels_per_lattice
+                    lz = pz * frequency / self.pixels_per_lattice
+                    lx %= self.lattice_width
+                    ly %= self.lattice_height
+                    lz %= self.lattice_depth
+                    flx = math.floor(lx)
+                    fly = math.floor(ly)
+                    flz = math.floor(lz)
+                    tx = lx - flx
+                    ty = ly - fly
+                    tz = lz - flz
+                    rx0 = flx
+                    rx1 = (flx + 1) % self.lattice_width
+                    ry0 = fly
+                    ry1 = (fly + 1) % self.lattice_height
+                    rz0 = flz
+                    rz1 = (flz + 1) % self.lattice_depth
+                    c000 = randoms[rz0 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry0]
+                    c010 = randoms[rz0 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry1]
+                    c001 = randoms[rz0 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry0]
+                    c011 = randoms[rz0 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry1]
+                    c100 = randoms[rz1 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry0]
+                    c110 = randoms[rz1 * self.lattice_width * self.lattice_height + rx0 * self.lattice_height + ry1]
+                    c101 = randoms[rz1 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry0]
+                    c111 = randoms[rz1 * self.lattice_width * self.lattice_height + rx1 * self.lattice_height + ry1]
+                    nx00 = self._interp(c000, c001, tx)
+                    nx01 = self._interp(c010, c011, tx)
+                    nx10 = self._interp(c100, c101, tx)
+                    nx11 = self._interp(c110, c111, tx)
+                    ny0 = self._interp(nx00, nx01, ty)
+                    ny1 = self._interp(nx10, nx11, ty)
+                    final = self._interp(ny0, ny1, tz)
+                    # print("px:%d py:%d %.2f %.2f %d %d %d %d tx:%.2f ty:%.2f c00:%.2f c10:%.2f c01:%.2f c11:%.2f f:%.2f" % (px, py, lx, ly, rx0, rx1, ry0, ry1, tx, ty, c00, c10, c01, c11, final))
+                    noise_map.append(final)
+        return noise_map
+
+    def noise_map_to_pillow(self, noise_map, pz):
+        new_image = Image.new('RGB', (self.pixel_width, self.pixel_height))
+        for px in range(self.pixel_width):
+            for py in range(self.pixel_height):
+                noise_value = int(255 * noise_map[pz * self.pixel_width * self.pixel_height + px * self.pixel_height + py])
+                new_image.putpixel((px, py), (noise_value, noise_value, noise_value))
+        new_image.save("im%03d.png" % pz)
+
+    def save_img(self):
+        for pz in range(self.pixel_depth):
+            self.noise_map_to_pillow(self.noise_map, pz)
+
+VALUE_NOISE = ValueNoise(384, 216)
+VALUE_NOISE.save_img()
